<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="设计模式-解释器模式-Interpreter Pattern [TOC]\nOverview 解释器模式（Interpreter Pattern）是一种行为设计模式 它主要用于定义如何评估语言的语法或表达式，是一种用于解释执行语言的模式 这种模式涉及到创建一个表达式接口，该接口能够解释一个特定的上下文 解释器模式通常用于解析和执行语言的语法规则，如计算表达式、解析文本文件等 1.解释器模式（Interpreter Pattern） 解释器模式（Interpreter Pattern）是一种行为设计模式，它主要用于定义如何评估语言的语法或表达式，是一种用于解释执行语言的模式。这种模式涉及到创建一个表达式接口，该接口能够解释一个特定的上下文。解释器模式通常用于解析和执行语言的语法规则，如计算表达式、解析文本文件等。\n"><title>design pattern Interpreter Pattern</title>
<link rel=canonical href=https://wesigj.github.io/p/design-pattern-interpreter-pattern/><link rel=stylesheet href=/scss/style.min.fb788271c6df6928bf35246ecbbfeb1eb9a17bcbe87d71daa3085497c92c891b.css><meta property='og:title' content="design pattern Interpreter Pattern"><meta property='og:description' content="设计模式-解释器模式-Interpreter Pattern [TOC]\nOverview 解释器模式（Interpreter Pattern）是一种行为设计模式 它主要用于定义如何评估语言的语法或表达式，是一种用于解释执行语言的模式 这种模式涉及到创建一个表达式接口，该接口能够解释一个特定的上下文 解释器模式通常用于解析和执行语言的语法规则，如计算表达式、解析文本文件等 1.解释器模式（Interpreter Pattern） 解释器模式（Interpreter Pattern）是一种行为设计模式，它主要用于定义如何评估语言的语法或表达式，是一种用于解释执行语言的模式。这种模式涉及到创建一个表达式接口，该接口能够解释一个特定的上下文。解释器模式通常用于解析和执行语言的语法规则，如计算表达式、解析文本文件等。\n"><meta property='og:url' content='https://wesigj.github.io/p/design-pattern-interpreter-pattern/'><meta property='og:site_name' content="Wesigj's blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='design_pattern'><meta property='article:published_time' content='2024-09-08T00:08:00+08:00'><meta property='article:modified_time' content='2024-09-08T00:08:00+08:00'><meta name=twitter:title content="design pattern Interpreter Pattern"><meta name=twitter:description content="设计模式-解释器模式-Interpreter Pattern [TOC]\nOverview 解释器模式（Interpreter Pattern）是一种行为设计模式 它主要用于定义如何评估语言的语法或表达式，是一种用于解释执行语言的模式 这种模式涉及到创建一个表达式接口，该接口能够解释一个特定的上下文 解释器模式通常用于解析和执行语言的语法规则，如计算表达式、解析文本文件等 1.解释器模式（Interpreter Pattern） 解释器模式（Interpreter Pattern）是一种行为设计模式，它主要用于定义如何评估语言的语法或表达式，是一种用于解释执行语言的模式。这种模式涉及到创建一个表达式接口，该接口能够解释一个特定的上下文。解释器模式通常用于解析和执行语言的语法规则，如计算表达式、解析文本文件等。\n"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu7443220043442625548.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Wesigj's blog</a></h1><h2 class=site-description>路漫漫其修远兮，吾将上下而求索。</h2></div></header><ol class=menu-social><li><a href=https://github.com/wesigj target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/_index.zh-cn/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#overview>Overview</a></li><li><a href=#1解释器模式interpreter-pattern>1.解释器模式（Interpreter Pattern）</a><ol><li><a href=#11组成要素>1.1.组成要素</a></li><li><a href=#12适用场景>1.2.适用场景</a></li><li><a href=#13优点>1.3.优点</a></li><li><a href=#14缺点>1.4.缺点</a></li><li><a href=#15示例代码c>1.5.示例代码（C++）</a></li></ol></li><li><a href=#2解释器模式优缺点>2.解释器模式优缺点</a><ol><li><a href=#21优点>2.1.优点</a></li><li><a href=#22缺点>2.2.缺点</a></li></ol></li><li><a href=#3解释器模式在实际开发中有哪些常见的应用场景>3.解释器模式在实际开发中有哪些常见的应用场景？</a></li><li><a href=#4如何优化解释器模式以提高其性能>4.如何优化解释器模式以提高其性能？</a></li><li><a href=#5使用编译器技术将解释器转化为即时编译器有哪些潜在的优势和挑战>5.使用编译器技术将解释器转化为即时编译器有哪些潜在的优势和挑战？</a><ol><li><a href=#51优势>5.1.优势</a></li><li><a href=#52挑战>5.2.挑战</a></li></ol></li><li><a href=#6如何实现缓存计算结果以提高解释器模式的性能>6.如何实现缓存计算结果以提高解释器模式的性能？</a><ol><li><a href=#61示例代码c>6.1.示例代码（C++）</a></li></ol></li><li><a href=#7在多线程环境下如何确保缓存的线程安全>7.在多线程环境下，如何确保缓存的线程安全？</a></li><li><a href=#8在优化抽象语法树ast时有哪些常见的优化技术>8.在优化抽象语法树（AST）时，有哪些常见的优化技术？</a></li><li><a href=#9能否提供一些具体的ast优化案例以便我更好地理解这些技术是如何应用的>9.能否提供一些具体的AST优化案例，以便我更好地理解这些技术是如何应用的？</a></li><li><a href=#10在进行ast优化时如何确定哪些优化技术是必要的>10.在进行AST优化时，如何确定哪些优化技术是必要的？</a></li><li><a href=#11在进行ast优化时如何确定哪些优化技术最适合我的项目需求>11.在进行AST优化时，如何确定哪些优化技术最适合我的项目需求？</a></li><li><a href=#12能否提供一些关于如何分析ast以识别优化机会的指导>12.能否提供一些关于如何分析AST以识别优化机会的指导？</a></li><li><a href=#关于作者>关于作者</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/design_pattern/ style=background-color:#2a9d8f;color:#fff>design_pattern</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/design-pattern-interpreter-pattern/>design pattern Interpreter Pattern</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Sep 08, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>19 minute read</time></div></footer></div></header><section class=article-content><h1 id=设计模式-解释器模式-interpreter-pattern>设计模式-解释器模式-Interpreter Pattern</h1><p>[TOC]</p><h2 id=overview>Overview</h2><ul><li>解释器模式（Interpreter Pattern）是一种行为设计模式</li><li>它主要用于定义如何评估语言的语法或表达式，是一种用于解释执行语言的模式</li><li>这种模式涉及到创建一个表达式接口，该接口能够解释一个特定的上下文</li><li>解释器模式通常用于解析和执行语言的语法规则，如计算表达式、解析文本文件等</li></ul><hr><h2 id=1解释器模式interpreter-pattern>1.解释器模式（Interpreter Pattern）</h2><p>解释器模式（Interpreter Pattern）是一种行为设计模式，它主要用于定义如何评估语言的语法或表达式，是一种用于解释执行语言的模式。这种模式涉及到创建一个表达式接口，该接口能够解释一个特定的上下文。解释器模式通常用于解析和执行语言的语法规则，如计算表达式、解析文本文件等。</p><h3 id=11组成要素>1.1.组成要素</h3><ol><li><p><strong>抽象表达式（AbstractExpression）</strong>：</p><ul><li>定义解释器的接口，通常包含一个 <code>interpret()</code> 方法，用于解释或执行表达式。</li></ul></li><li><p><strong>终结符表达式（TerminalExpression）</strong>：</p><ul><li>实现抽象表达式接口，代表语法中的终结符。终结符是最简单的表达式，没有子表达式。</li></ul></li><li><p><strong>非终结符表达式（NonterminalExpression）</strong>：</p><ul><li>也实现抽象表达式接口，代表语法中的非终结符。非终结符可以包含子表达式。</li></ul></li><li><p><strong>上下文（Context）</strong>：</p><ul><li>通常包含解释器之外的环境信息，这些信息对于解释器是必要的。</li></ul></li><li><p><strong>客户端（Client）</strong>：</p><ul><li>构建或配置具体的表达式，并使用解释器来解释或执行表达式。</li></ul></li></ol><h3 id=12适用场景>1.2.适用场景</h3><ol><li><p><strong>需要解释一种语言</strong>：</p><ul><li>当你需要解释一种语言（如简单的编程语言、查询语言等）时，可以使用解释器模式。</li></ul></li><li><p><strong>语法或表达式树的需求</strong>：</p><ul><li>当你需要处理复杂的语法或表达式树时，解释器模式可以提供一种结构化的方法。</li></ul></li><li><p><strong>易于改变的语法规则</strong>：</p><ul><li>当语法规则经常变化，且你希望在不修改现有代码的情况下轻松添加新的语法规则时。</li></ul></li></ol><h3 id=13优点>1.3.优点</h3><ol><li><p><strong>易于扩展</strong>：</p><ul><li>新的解释表达式可以很容易地加入到系统中，无需修改现有代码。</li></ul></li><li><p><strong>分离语法和语义</strong>：</p><ul><li>可以将语法分析和语义解释分离，使得系统更加模块化。</li></ul></li><li><p><strong>易于实现简单语法</strong>：</p><ul><li>对于简单的语法，实现起来相对简单直观。</li></ul></li></ol><h3 id=14缺点>1.4.缺点</h3><ol><li><p><strong>性能问题</strong>：</p><ul><li>对于复杂的文法，解释器模式可能导致性能问题。</li></ul></li><li><p><strong>难以维护</strong>：</p><ul><li>当语法规则非常复杂时，解释器模式可能导致系统难以维护。</li></ul></li><li><p><strong>难以优化</strong>：</p><ul><li>优化解释器模式的性能可能比较困难。</li></ul></li></ol><h3 id=15示例代码c>1.5.示例代码（C++）</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;memory&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;map&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 抽象表达式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Expression</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=n>interpret</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>context</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Expression</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 终结符表达式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>TerminalExpression</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Expression</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>symbol</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>TerminalExpression</span><span class=p>(</span><span class=kt>char</span> <span class=n>symbol</span><span class=p>)</span> <span class=o>:</span> <span class=n>symbol</span><span class=p>(</span><span class=n>symbol</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>interpret</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>context</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>context</span><span class=p>[</span><span class=n>symbol</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 非终结符表达式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>NonterminalExpression</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Expression</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Expression</span><span class=o>&gt;</span> <span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>NonterminalExpression</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Expression</span><span class=o>&gt;</span> <span class=n>expr</span><span class=p>)</span> <span class=o>:</span> <span class=n>expr</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>expr</span><span class=p>))</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>interpret</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>context</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>expr</span><span class=o>-&gt;</span><span class=n>interpret</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 客户端代码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>context</span> <span class=o>=</span> <span class=p>{{</span><span class=sc>&#39;a&#39;</span><span class=p>,</span> <span class=mi>1</span><span class=p>},</span> <span class=p>{</span><span class=sc>&#39;b&#39;</span><span class=p>,</span> <span class=mi>2</span><span class=p>}};</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Expression</span><span class=o>&gt;</span> <span class=n>expr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>TerminalExpression</span><span class=o>&gt;</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Interpretation: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>expr</span><span class=o>-&gt;</span><span class=n>interpret</span><span class=p>(</span><span class=n>context</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在这个示例中，<code>Expression</code> 是抽象表达式接口，<code>TerminalExpression</code> 是终结符表达式，它直接解释上下文中的值。<code>NonterminalExpression</code> 是非终结符表达式，它可以包含其他表达式。客户端代码创建了一个表达式并解释了上下文中的一个值。</p><p>解释器模式在实际应用中可以用于构建表达式求值器、语法解析器、解释执行特定领域的语言等。</p><h2 id=2解释器模式优缺点>2.解释器模式优缺点</h2><p>解释器模式（Interpreter Pattern）的优缺点如下：</p><h3 id=21优点>2.1.优点</h3><ol><li><p><strong>易于扩展</strong>：</p><ul><li>新的操作和文法可以很容易地添加到解释器中，而不需要修改已有的代码，这符合开闭原则。</li></ul></li><li><p><strong>分离性</strong>：</p><ul><li>将文法规则的定义与文法的解释逻辑分离，使得文法规则的变化或扩展不会影响到解释器的实现。</li></ul></li><li><p><strong>可定制性</strong>：</p><ul><li>用户可以定制自己的文法规则，并且可以创建自己的解释器来解释特定的语言。</li></ul></li><li><p><strong>易于实现简单文法</strong>：</p><ul><li>对于简单的文法，实现起来相对简单直观。</li></ul></li><li><p><strong>提高复用性</strong>：</p><ul><li>可以将重复的解释逻辑封装在解释器中，提高代码的复用性。</li></ul></li><li><p><strong>易于维护和修改</strong>：</p><ul><li>由于文法规则和解释逻辑的分离，使得维护和修改变得更加容易。</li></ul></li></ol><h3 id=22缺点>2.2.缺点</h3><ol><li><p><strong>性能问题</strong>：</p><ul><li>解释器模式通常使用大量的循环和递归调用来解释和执行语句，这可能导致性能问题，特别是在复杂或者大量的文法规则时。</li></ul></li><li><p><strong>会引起类膨胀</strong>：</p><ul><li>每条规则至少需要定义一个类，当文法规则很多时，会导致系统中存在大量的类，这会增加系统的复杂性。</li></ul></li><li><p><strong>可应用场景有限</strong>：</p><ul><li>解释器模式通常只适用于问题可以清晰定义文法规则的情况，对于不适合定义文法的问题，使用解释器模式可能并不合适。</li></ul></li><li><p><strong>难以处理复杂的文法</strong>：</p><ul><li>当文法非常复杂时，使用解释器模式可能会导致系统难以管理和维护。</li></ul></li><li><p><strong>调试困难</strong>：</p><ul><li>解释器模式的逻辑可能非常复杂，尤其是当涉及到递归和大量的条件判断时，这使得调试变得困难。</li></ul></li><li><p><strong>可能导致重复代码</strong>：</p><ul><li>在某些情况下，为了实现特定的文法规则，可能会在不同的表达式类中编写相似的代码，导致代码重复。</li></ul></li><li><p><strong>难以优化</strong>：</p><ul><li>由于解释器模式的动态解释特性，对于性能的优化可能比较困难，尤其是当需要对解释执行的结果进行优化时。</li></ul></li></ol><p>总的来说，解释器模式在处理语言或表达式解析这类问题时非常有用，但需要权衡其可能带来的性能和复杂性问题。在实际应用中，如果问题域适合使用解释器模式，并且能够接受其潜在的缺点，那么它是一个强大的工具。</p><h2 id=3解释器模式在实际开发中有哪些常见的应用场景>3.解释器模式在实际开发中有哪些常见的应用场景？</h2><p>解释器模式是一种行为设计模式，它适用于以下类型的编程问题：</p><ol><li><p><strong>需要解释一种语言</strong>：当你需要解释一种语言（如简单的编程语言、查询语言等）时，可以使用解释器模式。</p></li><li><p><strong>语法或表达式树的需求</strong>：当你需要处理复杂的语法或表达式树时，解释器模式可以提供一种结构化的方法。</p></li><li><p><strong>易于改变的语法规则</strong>：当你希望在不修改现有代码的情况下轻松添加新的语法规则时。</p></li><li><p><strong>日志处理</strong>：在处理日志时，如果有很多服务会产生大量的日志，并且需要对日志进行解析和生成报表，可以使用解释器模式。</p></li><li><p><strong>表达式求值器</strong>：在处理复杂的数学表达式或逻辑表达式时，解释器模式非常有用。</p></li><li><p><strong>配置文件解析</strong>：当应用程序需要从配置文件中读取参数和设置时，解释器模式可以用来解析配置文件的内容。</p></li><li><p><strong>编译器设计</strong>：解释器模式在编译器设计中非常常见，用于将源代码转换为机器代码。</p></li><li><p><strong>数据库查询语言</strong>：在数据库系统中，解释器模式用于解释和执行查询语言，如 SQL。</p></li><li><p><strong>正则表达式</strong>：解释器模式可以用于解析和执行正则表达式。</p></li><li><p><strong>模板引擎</strong>：在Web开发中，模板引擎可能会使用解释器模式来解释模板中的表达式。</p></li><li><p><strong>自然语言处理</strong>：在聊天机器人或虚拟助手中，解释器模式可以用于理解和处理用户的自然语言输入。</p></li><li><p><strong>领域特定语言（DSL）</strong>：在特定领域中，如金融交易系统，可能会开发自己的DSL来描述交易策略，解释器模式可以用来实现这些DSL。</p></li></ol><p>在实际开发中，使用解释器模式时需要考虑其优缺点。它提供了良好的扩展性和灵活性，但可能会导致性能问题、系统复杂度增加以及难以维护。因此，它通常适用于语法简单、执行效率不是关键问题、以及问题重复出现且可以用简单语言表达的场景。</p><p>在实现解释器模式时，通常会构建一个抽象表达式接口，定义终结符和非终结符表达式类，以及一个上下文环境类，客户端代码则负责构建表达式并调用解释器进行解释。</p><h2 id=4如何优化解释器模式以提高其性能>4.如何优化解释器模式以提高其性能？</h2><p>为了优化解释器模式以提高其性能，可以采取以下几种策略：</p><ol><li><p><strong>缓存计算结果</strong>：对于重复使用的表达式节点，可以通过缓存其计算结果来避免重复计算，这样可以显著提高解释器的执行效率 。</p></li><li><p><strong>使用编译器技术</strong>：将解释器的解析和执行过程分为两个阶段，首先将源代码解析为中间表示形式（如字节码或机器码），然后通过编译器技术对中间表示进行优化和执行，这种方式可以将解释器转化为即时编译器，从而提高性能 。</p></li><li><p><strong>优化抽象语法树（AST）</strong>：通过优化AST的结构和遍历算法，减少不必要的计算和内存消耗。例如，可以使用尾递归优化、剪枝策略等技术，简化和优化AST的构建和遍历过程 。</p></li><li><p><strong>避免重复解析</strong>：如果需要多次处理相同的输入数据，可以考虑预解析所有可能的输入数据并将结果保存起来，这样在后续处理过程中，无需再次解析输入数据，只需查找预解析的结果即可 。</p></li><li><p><strong>并行解析</strong>：如果解释器需要处理大量输入数据，可以考虑将解析过程并行化，以利用多核处理器的计算能力 。</p></li><li><p><strong>延迟解析</strong>：在某些情况下，输入数据的某些部分可能并不需要立即解析。例如，当解释器用于处理配置文件时，可以只解析当前需要的配置项，而将其他配置项的解析推迟到实际需要时 。</p></li><li><p><strong>优化解析算法</strong>：使用更高效的算法来解析输入数据，以减少解析过程中的时间开销。例如，可以使用词法分析器和语法分析器生成器（如Flex和Bison）来构建解析器，这些工具可以生成高效的解析代码，从而提高解析性能 。</p></li><li><p><strong>部分解析缓存</strong>：在某些情况下，输入数据可能包含许多重复的子结构。为了避免重复解析这些子结构，可以将它们的解析结果存储在缓存中。当遇到相同的子结构时，直接从缓存中获取解析结果，从而提高解析速度 。</p></li><li><p><strong>表达式求值缓存</strong>：在解释器模式中，不同的表达式对象可能需要执行相似的计算过程。为了避免重复进行这些计算，可以在表达式对象中添加一个缓存层，用于存储计算结果。当需要执行相同的计算时，可以直接从缓存中获取结果，从而提高表达式求值的性能 。</p></li></ol><p>通过这些优化策略，可以在保持解释器模式带来的好处的同时，减少其可能引入的性能问题。在实际应用中，需要根据具体情况灵活选择和调整这些策略。</p><h2 id=5使用编译器技术将解释器转化为即时编译器有哪些潜在的优势和挑战>5.使用编译器技术将解释器转化为即时编译器有哪些潜在的优势和挑战？</h2><p>使用编译器技术将解释器转化为即时编译器（JIT，Just-In-Time compilation）的潜在优势和挑战如下：</p><h3 id=51优势>5.1.优势</h3><ol><li><p><strong>性能提升</strong>：即时编译器在运行时将热点代码编译成优化的机器码，可以显著提高程序的执行速度，尤其是在循环和频繁调用的方法上 。</p></li><li><p><strong>优化的代码</strong>：JIT编译器可以根据程序的实际运行情况来进行优化，如方法内联、逃逸分析、循环展开等，这些优化可以减少内存消耗和提高执行效率 。</p></li><li><p><strong>动态优化</strong>：即时编译器可以在程序运行过程中根据收集到的统计信息进行动态优化，适应程序的行为变化，这是静态编译器无法做到的 。</p></li><li><p><strong>资源利用</strong>：JIT编译器可以选择性地编译热点代码，避免了对不常执行的代码进行编译，从而节省了编译资源和内存空间 。</p></li><li><p><strong>跨平台性</strong>：即时编译器保留了Java的跨平台特性，同时提供了接近本地编译语言的性能 。</p></li></ol><h3 id=52挑战>5.2.挑战</h3><ol><li><p><strong>启动延迟</strong>：即时编译器需要在程序运行时进行编译，这可能会导致程序启动速度变慢，尤其是在代码量较大时 。</p></li><li><p><strong>内存消耗</strong>：即时编译器生成的机器码需要存储在内存中，这可能会增加内存的消耗，尤其是在代码缓存（codeCache）较小的环境下 。</p></li><li><p><strong>编译器复杂性</strong>：实现一个高效的即时编译器需要复杂的编译技术，包括中间表示（IR）、优化算法和代码生成等，这增加了编译器的复杂性 。</p></li><li><p><strong>稳定性问题</strong>：由于即时编译器在运行时进行编译，如果编译过程中出现问题，可能会影响程序的稳定性 。</p></li><li><p><strong>调试难度</strong>：即时编译器生成的机器码可能会使得调试变得更加困难，因为源代码和执行的机器码之间没有直接的映射关系 。</p></li><li><p><strong>资源竞争</strong>：在高并发环境下，即时编译器可能会与应用程序的其他部分竞争CPU资源，这可能会影响整体性能 。</p></li></ol><p>总的来说，即时编译器通过在运行时优化代码，可以显著提高程序的性能，但同时也带来了一些挑战，如启动延迟、内存消耗和编译器复杂性等。开发者需要根据具体的应用场景和性能要求来权衡是否使用即时编译器技术。</p><h2 id=6如何实现缓存计算结果以提高解释器模式的性能>6.如何实现缓存计算结果以提高解释器模式的性能？</h2><p>在解释器模式中实现缓存计算结果以提高性能，通常涉及到以下几个步骤：</p><ol><li><p><strong>确定可缓存的操作</strong>：</p><ul><li>识别出解释器模式中重复执行且开销较大的操作，这些操作的计算结果可以在一段时间内被复用。</li></ul></li><li><p><strong>使用缓存机制</strong>：</p><ul><li>设计一个缓存机制，可以是一个简单的哈希表，也可以是一个更复杂的缓存库，用于存储计算结果。</li></ul></li><li><p><strong>实现缓存逻辑</strong>：</p><ul><li>在解释器的 <code>interpret()</code> 方法中，添加逻辑来检查所需结果是否已经在缓存中。</li><li>如果结果在缓存中，直接返回缓存的结果，而不执行实际的计算。</li><li>如果结果不在缓存中，执行计算，然后将结果存储在缓存中，再返回结果。</li></ul></li><li><p><strong>考虑缓存失效策略</strong>：</p><ul><li>确定缓存数据的有效期，以及何时应该更新或删除缓存中的数据。</li><li>实现缓存失效策略，比如最近最少使用（LRU）算法，以确保缓存数据的有效性。</li></ul></li><li><p><strong>线程安全</strong>：</p><ul><li>如果在多线程环境中使用缓存，确保缓存的访问是线程安全的，避免并发问题。</li></ul></li><li><p><strong>监控和调优</strong>：</p><ul><li>监控缓存命中率和性能，根据实际使用情况调整缓存大小和失效策略。</li></ul></li></ol><h3 id=61示例代码c>6.1.示例代码（C++）</h3><p>以下是一个简单的示例，演示了如何在解释器模式中实现缓存计算结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unordered_map&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;memory&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 抽象表达式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Expression</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>int</span> <span class=n>interpret</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Expression</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 具体表达式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>TerminalExpression</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Expression</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>TerminalExpression</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=o>:</span> <span class=n>value</span><span class=p>(</span><span class=n>value</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>interpret</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Calculating terminal expression...&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 复杂表达式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>ComplexExpression</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Expression</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Expression</span><span class=o>&gt;</span> <span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Expression</span><span class=o>&gt;</span> <span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>operation</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ComplexExpression</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Expression</span><span class=o>&gt;</span> <span class=n>left</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Expression</span><span class=o>&gt;</span> <span class=n>right</span><span class=p>,</span> <span class=kt>char</span> <span class=n>operation</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>left</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>left</span><span class=p>)),</span> <span class=n>right</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>right</span><span class=p>)),</span> <span class=n>operation</span><span class=p>(</span><span class=n>operation</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>interpret</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Calculating complex expression...&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>leftResult</span> <span class=o>=</span> <span class=n>left</span><span class=o>-&gt;</span><span class=n>interpret</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>rightResult</span> <span class=o>=</span> <span class=n>right</span><span class=o>-&gt;</span><span class=n>interpret</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>operation</span> <span class=o>==</span> <span class=sc>&#39;+&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>leftResult</span> <span class=o>+</span> <span class=n>rightResult</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>operation</span> <span class=o>==</span> <span class=sc>&#39;-&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>leftResult</span> <span class=o>-</span> <span class=n>rightResult</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 缓存装饰器
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>CachedExpression</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Expression</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Expression</span><span class=o>&gt;</span> <span class=n>expr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>cache</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>CachedExpression</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Expression</span><span class=o>&gt;</span> <span class=n>expr</span><span class=p>)</span> <span class=o>:</span> <span class=n>expr</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>expr</span><span class=p>))</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>interpret</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>key</span> <span class=o>=</span> <span class=s>&#34;CachedExpression&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>cache</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>)</span> <span class=o>!=</span> <span class=n>cache</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Using cached result...&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>cache</span><span class=p>[</span><span class=n>key</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>expr</span><span class=o>-&gt;</span><span class=n>interpret</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>cache</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>terminal</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>TerminalExpression</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>complexExpr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>ComplexExpression</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>terminal</span><span class=p>),</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>TerminalExpression</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=sc>&#39;+&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>cachedExpr</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>CachedExpression</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>complexExpr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 第一次计算，会执行并缓存结果
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;First interpretation: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>cachedExpr</span><span class=o>-&gt;</span><span class=n>interpret</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 第二次计算，会使用缓存的结果
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Second interpretation: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>cachedExpr</span><span class=o>-&gt;</span><span class=n>interpret</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在这个示例中，<code>CachedExpression</code> 是一个装饰器，它包装了实际的表达式，并实现了缓存逻辑。当 <code>interpret()</code> 方法被调用时，它会检查缓存中是否存在结果，如果存在，则直接返回缓存的结果；如果不存在，则执行计算，并将结果存储在缓存中。</p><p>通过这种方式，可以显著减少重复计算，提高解释器模式的性能。</p><h2 id=7在多线程环境下如何确保缓存的线程安全>7.在多线程环境下，如何确保缓存的线程安全？</h2><p>在多线程环境下，确保缓存的线程安全通常涉及以下几个策略：</p><ol><li><p><strong>使用同步机制</strong>：</p><ul><li>可以通过在缓存访问代码块中添加同步锁（如 <code>synchronized</code> 关键字）来确保同一时间只有一个线程可以修改缓存。这种方式简单但可能会影响性能，因为它限制了并发访问。</li></ul></li><li><p><strong>使用并发数据结构</strong>：</p><ul><li>利用 <code>java.util.concurrent</code> 包中提供的线程安全的数据结构，如 <code>ConcurrentHashMap</code>，可以减少锁的需要，提供更好的并发性能。</li></ul></li><li><p><strong>使用原子操作</strong>：</p><ul><li>对于简单的缓存操作，可以使用原子类（如 <code>AtomicInteger</code>），这些类提供了无锁的线程安全操作。</li></ul></li><li><p><strong>使用锁分段技术</strong>：</p><ul><li>锁分段是一种减少锁竞争的技术，通过将数据结构分成多个段，每段使用一个锁，从而允许多个线程同时操作不同段的数据。</li></ul></li><li><p><strong>使用无锁编程技术</strong>：</p><ul><li>利用 <code>Compare-and-Swap</code>（CAS）等原子操作来实现无锁的数据结构，这通常比传统的锁机制有更高的并发性能。</li></ul></li><li><p><strong>使用现代缓存框架</strong>：</p><ul><li>现代缓存框架如 Caffeine 已经内置了线程安全的支持。Caffeine 使用细粒度的锁定机制来保护共享资源，确保并发访问的正确性和一致性。它还提供了丰富的配置选项，如自动刷新、过期策略等，这些都是在保证线程安全的前提下进行的。</li></ul></li><li><p><strong>避免缓存污染</strong>：</p><ul><li>确保缓存中的数据不会被不正确的并发操作污染。例如，使用 <code>volatile</code> 关键字或者锁来确保缓存的可见性和有序性。</li></ul></li><li><p><strong>内存屏障</strong>：</p><ul><li>在某些情况下，可能需要使用内存屏障来确保操作的顺序性和内存的可见性。</li></ul></li><li><p><strong>减少缓存的共享</strong>：</p><ul><li>尽可能减少多个线程对同一缓存数据的共享，可以通过将缓存数据复制到线程私有的存储中来避免共享。</li></ul></li><li><p><strong>监控和调优</strong>：</p><ul><li>使用缓存框架提供的监控工具来观察缓存的性能和线程安全问题，根据实际情况进行调优。</li></ul></li></ol><p>通过上述策略，可以在多线程环境中有效地确保缓存的线程安全，同时保持良好的性能。在实际应用中，可能需要根据具体的业务场景和性能要求来选择和组合这些策略。</p><h2 id=8在优化抽象语法树ast时有哪些常见的优化技术>8.在优化抽象语法树（AST）时，有哪些常见的优化技术？</h2><p>在优化抽象语法树（AST）时，以下是一些常见的优化技术：</p><ol><li><p><strong>节点匹配优化</strong>：</p><ul><li>改进AST节点匹配算法，确保在比较两个AST时能够更准确地识别出相同的节点，减少不必要的编辑操作。</li></ul></li><li><p><strong>编辑脚本简化</strong>：</p><ul><li>通过合并相似的编辑操作（如连续的插入或删除）来简化生成的编辑脚本，从而减少编辑操作的数量。</li></ul></li><li><p><strong>启发式算法</strong>：</p><ul><li>使用启发式算法来优化节点的移动和更新操作，减少不必要的节点操作，提高AST编辑脚本的质量。</li></ul></li><li><p><strong>超参数优化</strong>：</p><ul><li>根据特定的AST特性和差异，调整AST比较算法中的超参数，如相似度阈值、节点大小限制等，以提高差异计算的准确性。</li></ul></li><li><p><strong>算法配置优化</strong>：</p><ul><li>通过全局或局部的超参数优化，找到最佳的算法配置，以适应不同的编程语言或AST元模型。</li></ul></li><li><p><strong>数据驱动的方法</strong>：</p><ul><li>使用数据驱动的方法，如DAT（Diff Auto Tuning），来自动调整AST比较算法的参数，以优化编辑脚本的长度和质量。</li></ul></li><li><p><strong>统计验证</strong>：</p><ul><li>通过统计验证和交叉验证来评估AST优化技术的有效性，确保优化方法在不同场景下都能保持一致的性能提升。</li></ul></li><li><p><strong>算法比较</strong>：</p><ul><li>比较不同的AST比较算法，选择或组合最有效的算法来处理特定的AST结构。</li></ul></li><li><p><strong>性能评估</strong>：</p><ul><li>对AST优化技术进行性能评估，包括执行时间、内存消耗和编辑脚本的质量，以找到最佳的优化策略。</li></ul></li><li><p><strong>自动化工具</strong>：</p><ul><li>开发自动化工具来支持AST优化过程，包括自动调整参数、自动评估优化效果和自动应用优化策略。</li></ul></li></ol><p>这些优化技术可以帮助提高AST处理的性能，减少不必要的计算，提高AST编辑脚本的质量和可读性。在实际应用中，可能需要根据具体的AST结构和差异计算需求来选择合适的优化策略。</p><h2 id=9能否提供一些具体的ast优化案例以便我更好地理解这些技术是如何应用的>9.能否提供一些具体的AST优化案例，以便我更好地理解这些技术是如何应用的？</h2><p>在优化抽象语法树（AST）时，以下是一些具体的优化技术：</p><ol><li><p><strong>常量折叠</strong>：在编译时计算常量表达式的值，而不是在运行时计算。这可以减少运行时的计算负担，并可能消除不必要的计算。</p></li><li><p><strong>死代码消除</strong>：移除那些不会被执行或者对程序输出没有影响的代码部分。这可以通过分析AST来识别未使用的变量和代码路径。</p></li><li><p><strong>循环优化</strong>：对循环结构进行优化，例如循环展开、循环融合、循环拆分等，以减少循环开销和提高缓存利用率。</p></li><li><p><strong>表达式简化</strong>：通过简化复杂的表达式来减少运行时的计算量。例如，将复杂的算术表达式分解为简单的步骤。</p></li><li><p><strong>内存访问优化</strong>：优化数据结构的布局，以减少内存访问延迟和提高数据的局部性。</p></li><li><p><strong>指令重排</strong>：在不影响程序语义的前提下，重新排列指令的顺序，以提高指令流水线的效率。</p></li><li><p><strong>代码内联</strong>：将函数调用的代码直接插入到调用点，以减少函数调用的开销。</p></li><li><p><strong>条件编译</strong>：在编译时根据条件删除或添加代码段，以适应不同的编译环境或配置。</p></li><li><p><strong>消除冗余代码</strong>：通过分析AST来识别并删除重复的代码块，减少代码的冗余。</p></li><li><p><strong>优化数据类型</strong>：在AST中识别并优化数据类型，例如使用更小的数据类型来减少内存使用。</p></li><li><p><strong>控制流分析</strong>：通过分析AST中的控制流，识别并优化条件判断、循环和分支结构。</p></li><li><p><strong>代码生成优化</strong>：在代码生成阶段，根据目标平台的特点优化生成的机器码。</p></li></ol><p>这些优化技术可以单独使用，也可以组合使用，以实现最佳的性能提升。在实际应用中，需要根据具体的程序特性和运行环境来选择最合适的优化策略。</p><h2 id=10在进行ast优化时如何确定哪些优化技术是必要的>10.在进行AST优化时，如何确定哪些优化技术是必要的？</h2><p>在进行AST优化时，确定哪些优化技术是必要的，通常需要考虑以下几个方面：</p><ol><li><p><strong>代码复杂度</strong>：如果代码中包含复杂的表达式或深层嵌套的结构，可能需要应用优化技术如常量折叠、表达式简化或循环优化。</p></li><li><p><strong>性能瓶颈</strong>：通过性能分析工具识别出程序的性能瓶颈，针对这些瓶颈应用优化技术，如循环展开、指令重排或内存访问优化。</p></li><li><p><strong>运行时特性</strong>：考虑代码的运行时特性，如热点代码识别，对频繁执行的代码段进行优化。</p></li><li><p><strong>目标平台</strong>：不同的目标平台可能对某些优化技术有更好的支持，根据目标平台的特点选择合适的优化技术。</p></li><li><p><strong>代码可读性</strong>：在不牺牲代码可读性的前提下进行优化，确保优化后的代码仍然易于理解和维护。</p></li><li><p><strong>开发和维护成本</strong>：权衡优化带来的性能提升和所需的开发及维护成本，选择性价比最高的优化技术。</p></li><li><p><strong>特定场景需求</strong>：根据特定的应用场景，如前端框架的模板优化、数据库查询优化等，选择适合的优化技术。</p></li><li><p><strong>社区和工具支持</strong>：利用现有的工具和社区资源，如Babel插件、代码分析工具等，来辅助确定和实施优化。</p></li></ol><p>通过综合考虑上述因素，可以更有针对性地选择和应用AST优化技术，以提高程序的性能和可维护性。在实际开发中，可能需要多次迭代和测试，以找到最佳的优化策略。</p><h2 id=11在进行ast优化时如何确定哪些优化技术最适合我的项目需求>11.在进行AST优化时，如何确定哪些优化技术最适合我的项目需求？</h2><p>在进行AST优化时，确定哪些优化技术最适合项目需求，可以通过以下几个步骤进行：</p><ol><li><p><strong>性能分析</strong>：首先，使用性能分析工具来识别代码中的瓶颈和热点。这将帮助你了解哪些部分的代码最需要优化。</p></li><li><p><strong>代码复杂度评估</strong>：分析代码的复杂度，确定是否存在复杂的表达式或深层嵌套的结构，这些可能是优化的目标。</p></li><li><p><strong>项目需求分析</strong>：根据项目的具体需求，确定哪些优化技术能够带来最大的性能提升。例如，如果项目需要快速响应，那么循环优化可能是重点。</p></li><li><p><strong>目标平台特性</strong>：考虑目标平台的特性，选择能够在该平台上发挥最大效能的优化技术。</p></li><li><p><strong>开发和维护成本</strong>：评估不同优化技术的开发和维护成本，选择性价比最高的技术。</p></li><li><p><strong>社区和工具支持</strong>：利用现有的工具和社区资源，如Babel插件、代码分析工具等，来辅助确定和实施优化。</p></li><li><p><strong>测试和验证</strong>：对选定的优化技术进行测试和验证，确保它们能够达到预期的效果，并且不会引入新的问题。</p></li><li><p><strong>持续迭代</strong>：优化是一个持续的过程，需要不断地评估和调整优化策略，以适应项目的发展和变化。</p></li></ol><p>通过上述步骤，你可以更有针对性地选择和应用AST优化技术，以提高程序的性能和可维护性。在实际开发中，可能需要多次迭代和测试，以找到最佳的优化策略。</p><h2 id=12能否提供一些关于如何分析ast以识别优化机会的指导>12.能否提供一些关于如何分析AST以识别优化机会的指导？</h2><p>在进行AST优化时，确定哪些优化技术最适合项目需求，可以通过以下几个步骤进行：</p><ol><li><p><strong>性能分析</strong>：首先，使用性能分析工具来识别代码中的瓶颈和热点。这将帮助你了解哪些部分的代码最需要优化。</p></li><li><p><strong>代码复杂度评估</strong>：分析代码的复杂度，确定是否存在复杂的表达式或深层嵌套的结构，这些可能是优化的目标。</p></li><li><p><strong>项目需求分析</strong>：根据项目的具体需求，确定哪些优化技术能够带来最大的性能提升。例如，如果项目需要快速响应，那么循环优化可能是重点。</p></li><li><p><strong>目标平台特性</strong>：考虑目标平台的特性，选择能够在该平台上发挥最大效能的优化技术。</p></li><li><p><strong>开发和维护成本</strong>：评估不同优化技术的开发和维护成本，选择性价比最高的技术。</p></li><li><p><strong>社区和工具支持</strong>：利用现有的工具和社区资源，如Babel插件、代码分析工具等，来辅助确定和实施优化。</p></li><li><p><strong>测试和验证</strong>：对选定的优化技术进行测试和验证，确保它们能够达到预期的效果，并且不会引入新的问题。</p></li><li><p><strong>持续迭代</strong>：优化是一个持续的过程，需要不断地评估和调整优化策略，以适应项目的发展和变化。</p></li></ol><p>通过上述步骤，你可以更有针对性地选择和应用AST优化技术，以提高程序的性能和可维护性。在实际开发中，可能需要多次迭代和测试，以找到最佳的优化策略。</p><hr><h2 id=关于作者>关于作者</h2><ul><li>微信公众号:WeSiGJ</li><li>GitHub:<a class=link href=https://github.com/wesigj/cplusplusboys target=_blank rel=noopener>https://github.com/wesigj/cplusplusboys</a></li><li>CSDN:<a class=link href=https://blog.csdn.net/wesigj target=_blank rel=noopener>https://blog.csdn.net/wesigj</a></li><li>微博:</li><li>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</li></ul><img src=/./img/wechat.jpg width=60%></section><footer class=article-footer><section class=article-tags><a href=/tags/design_pattern/>Design_pattern</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/design-pattern-chain-of-responsibility-pattern/><div class=article-details><h2 class=article-title>design pattern Chain of Responsibility Pattern</h2></div></a></article><article><a href=/p/design-pattern-command-pattern/><div class=article-details><h2 class=article-title>design pattern Command Pattern</h2></div></a></article><article><a href=/p/design-pattern-composite-pattern/><div class=article-details><h2 class=article-title>design pattern Composite Pattern</h2></div></a></article><article><a href=/p/design-pattern-facade-pattern/><div class=article-details><h2 class=article-title>design pattern Facade Pattern</h2></div></a></article><article><a href=/p/design-pattern-factory-method-pattern/><div class=article-details><h2 class=article-title>design pattern Factory Method Pattern</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 Wesigj's blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.27.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>