<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on WESIGJ</title><link>https://wesigj.github.io/categories/c++/</link><description>Recent content in C++ on WESIGJ</description><generator>Hugo</generator><language>en</language><copyright>Wesigj</copyright><lastBuildDate>Sat, 07 Sep 2024 15:07:39 +0800</lastBuildDate><atom:link href="https://wesigj.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ basic abstract</title><link>https://wesigj.github.io/p/c-basic-abstract/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-abstract/</guid><description>&lt;h1 id="c面试基础系列-abstract">C++面试基础系列-abstract&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>在C++中，&lt;code>abstract&lt;/code>这个概念主要与抽象类&lt;code>（Abstract Class）&lt;/code>相关。抽象类是一种不能被实例化的类，它通常包含至少一个纯虚函数&lt;code>（Pure Virtual Function）&lt;/code>。抽象类用于定义接口或行为规范，可以被其他类继承并实现具体的功能。&lt;/p>
&lt;h2 id="1abstract关键点">1.abstract关键点&lt;/h2>
&lt;p>以下是一些关于C++中抽象类的关键点：&lt;/p>
&lt;ul>
&lt;li>纯虚函数：
&lt;ul>
&lt;li>纯虚函数是在基类中声明但没有实现的虚函数，其声明方式是在函数声明的末尾加上= 0。&lt;/li>
&lt;li>例如：&lt;code>virtual void doSomething() = 0;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>抽象类的定义：
&lt;ul>
&lt;li>包含至少一个纯虚函数的类就是抽象类。&lt;/li>
&lt;li>抽象类不能被直接实例化，但可以被用作其他类的基类。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>继承抽象类：
&lt;ul>
&lt;li>派生类必须实现基类中的所有纯虚函数，否则派生类也会是抽象类。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>接口定义：
&lt;ul>
&lt;li>抽象类通常用于定义接口，让不同的派生类实现相同的接口。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>多态性：
&lt;ul>
&lt;li>抽象类支持多态性，可以通过基类指针或引用调用派生类重写的虚函数。
示例：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 抽象类声明
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">Shape&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">draw&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 纯虚函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">virtual&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="n">Shape&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="c1">// 虚析构函数，确保派生类析构正确性
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 派生类实现抽象类
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">Circle&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Shape&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">draw&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="k">override&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 绘制圆形的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 使用抽象类
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">Shape&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">shape&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Circle&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">shape&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">draw&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">delete&lt;/span> &lt;span class="n">shape&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>抽象类的作用：
&lt;ul>
&lt;li>强制实现接口：确保所有派生类都实现了抽象类中定义的纯虚函数。&lt;/li>
&lt;li>代码复用：基类可以提供一些通用的实现，派生类可以重写或继承这些实现。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>设计原则：
&lt;ul>
&lt;li>遵循里氏替换原则（Liskov Substitution Principle），确保派生类可以替换其基类。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>注意事项：
&lt;ul>
&lt;li>抽象类通常包含虚析构函数，以确保派生类的析构函数被正确调用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>C++11及以后版本：
&lt;ul>
&lt;li>C++11引入了final关键字，可以修饰类或成员函数，表示它们不能被进一步继承或重写。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>抽象类是C++面向对象编程中的一个重要概念，它有助于实现代码的模块化和可扩展性。通过使用抽象类，开发者可以定义清晰的接口，并在不同的派生类中实现这些接口的具体行为。&lt;/p></description></item><item><title>C++ basic assert</title><link>https://wesigj.github.io/p/c-basic-assert/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-assert/</guid><description>&lt;h1 id="c面试基础系列-assert">C++面试基础系列-assert&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;h2 id="1assert关键点">1.assert关键点&lt;/h2>
&lt;p>在C++中，&lt;code>assert&lt;/code>宏是断言机制的一部分，用于在开发过程中检查程序的逻辑错误。如果断言的条件不满足，程序将终止执行，并通常会输出相关的错误信息。&lt;/p>
&lt;p>以下是一些关于C++中&lt;code>assert&lt;/code>宏的关键点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>定义：&lt;code>assert&lt;/code>宏定义在&lt;code>&amp;lt;cassert&amp;gt;&lt;/code>或&lt;code>&amp;lt;assert.h&amp;gt;&lt;/code>头文件中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>语法：&lt;code>assert&lt;/code>宏的基本语法是&lt;code>assert(expression)&lt;/code>，其中&lt;code>expression&lt;/code>是一个在运行时求值的表达式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>行为：如果&lt;code>expression&lt;/code>的值为&lt;code>true&lt;/code>，程序继续正常执行。如果&lt;code>expression&lt;/code>的值为&lt;code>false&lt;/code>，则程序将打印一条错误消息，并终止执行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调试：&lt;code>assert&lt;/code>宏通常用于调试阶段，以确保程序的某些关键条件得到满足。在发布版本中，可以通过预处理器指令NDEBUG来禁用assert宏。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>示例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;cassert&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 如果x大于5，程序继续执行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;x的值是：&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 如果x小于20，程序继续执行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>自定义消息：C++11开始支持使用&lt;code>static_assert&lt;/code>进行编译时断言，并且可以传递一个字符串作为错误消息：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">static_assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;int类型必须至少占用4个字节&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>编译时断言：&lt;code>static_assert&lt;/code>是在编译时检查条件是否为真的断言，如果条件为假，编译器将报错并停止编译过程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>性能：由于&lt;code>assert&lt;/code>在运行时检查条件，因此在性能敏感的应用中应谨慎使用，或者在发布版本中禁用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>禁用断言：可以通过定义NDEBUG宏来禁用所有&lt;code>assert&lt;/code>宏：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define NDEBUG
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;cassert&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>使用断言是一种很好的实践，可以帮助开发者及早发现和修复错误。然而，它们不应该被用作错误处理的主要手段，因为它们在生产环境中可能被禁用。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="关于作者">关于作者&lt;/h2>
&lt;ul>
&lt;li>微信公众号:WeSiGJ&lt;/li>
&lt;li>GitHub:&lt;a href="https://github.com/wesigj/cplusplusboys">https://github.com/wesigj/cplusplusboys&lt;/a>&lt;/li>
&lt;li>CSDN:&lt;a href="https://blog.csdn.net/wesigj">https://blog.csdn.net/wesigj&lt;/a>&lt;/li>
&lt;li>微博:&lt;/li>
&lt;li>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。&lt;/li>
&lt;/ul>
&lt;img src=https://wesigj.github.io/./img/wechat.jpg width=60% /></description></item><item><title>C++ basic bit_field</title><link>https://wesigj.github.io/p/c-basic-bit_field/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-bit_field/</guid><description>&lt;h1 id="c面试基础系列-bit_field">C++面试基础系列-bit_field&lt;/h1>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>“ 位域 “ 或 “ 位段 “(Bit field)为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。&lt;/p>
&lt;ul>
&lt;li>优点
&lt;ul>
&lt;li>它可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。&lt;/li>
&lt;li>位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>而这种数据结构的缺点在于，位段实现依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>关键点：
&lt;ul>
&lt;li>位域在内存中的布局是与机器有关的&lt;/li>
&lt;li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定&lt;/li>
&lt;li>取地址运算符（&amp;amp;）不能作用于位域，任何指针都无法指向类的位域&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1bit_field位域">1.bit_field位域&lt;/h2>
&lt;p>在C和C++编程中，&lt;code>bit_field&lt;/code>（位字段）是一种数据结构技术，它允许程序员访问和操作内存中存储的整数的特定部分。以下是位字段的一些关键点：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>内存节省&lt;/strong> ：位字段允许程序员将多个数据项存储在一个小的存储单元内，从而节省内存空间。&lt;/li>
&lt;li>&lt;strong>数据表示&lt;/strong> ：位字段通常用于表示具有固定位宽的数据，例如状态标志、控制位或特定的配置选项。&lt;/li>
&lt;li>&lt;strong>声明方式&lt;/strong> ：&lt;/li>
&lt;li>&lt;strong>位宽指定&lt;/strong> ：在声明位字段时，可以通过冒号(&lt;code>:&lt;/code>)后跟数字来指定每个字段的位宽。&lt;/li>
&lt;li>&lt;strong>位操作&lt;/strong> ：位字段常用于位操作，如位与(&lt;code>&amp;amp;&lt;/code>)、位或(&lt;code>|&lt;/code>)、位异或(&lt;code>^&lt;/code>)、位非(&lt;code>~&lt;/code>)和位移操作。&lt;/li>
&lt;li>&lt;strong>数据对齐&lt;/strong> ：位字段可能会影响数据的内存对齐，编译器可能会在位字段结构体中添加填充位以满足对齐要求。&lt;/li>
&lt;li>&lt;strong>可移植性问题&lt;/strong> ：位字段的布局（即位字段在内存中的顺序）可能依赖于编译器和平台，因此可能存在可移植性问题。&lt;/li>
&lt;li>&lt;strong>访问方式&lt;/strong> ：位字段通常作为结构体的成员来访问，可以结合点(&lt;code>.&lt;/code>)或箭头(&lt;code>-&amp;gt;&lt;/code>)操作符使用。&lt;/li>
&lt;li>&lt;strong>应用场景&lt;/strong> ：
&lt;ul>
&lt;li>硬件设备寄存器的访问。&lt;/li>
&lt;li>状态机的状态表示。&lt;/li>
&lt;li>配置选项的存储。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>限制&lt;/strong> ：位字段的使用应谨慎，因为它们可能会使代码难以理解和维护，且容易出错。&lt;/li>
&lt;li>&lt;strong>类型安全&lt;/strong> ：位字段本身是强类型，但位字段的运算可能导致隐式类型转换。&lt;/li>
&lt;li>&lt;strong>编译器特性&lt;/strong> ：某些编译器可能提供特定的特性或扩展来支持位字段的声明和操作。&lt;/li>
&lt;/ol>
&lt;p>位字段是C和C++中一种强大的特性，尤其适用于需要精细控制内存使用和硬件级编程的场合。然而，由于它们可能带来的复杂性和可移植性问题，建议仅在确实需要时才使用位字段。&lt;/p>
&lt;h2 id="2bit_field字节对齐">2.bit_field字节对齐&lt;/h2>
&lt;h3 id="21位域的声明">2.1.位域的声明&lt;/h3>
&lt;p>位域通常使用结构体声明， 该结构声明为每个位域成员设置名称，并决定其宽度：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">bit_field_name&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">type&lt;/span> &lt;span class="nl">member_name&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">width&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">Elements&lt;/th>
 &lt;th style="text-align: left">Description&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">bit_field_name&lt;/td>
 &lt;td style="text-align: left">位域结构名&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">type&lt;/td>
 &lt;td style="text-align: left">位域成员的类型，必须为 int、signed int 或者 unsigned int 类型&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">member_name&lt;/td>
 &lt;td style="text-align: left">位域成员名&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">width&lt;/td>
 &lt;td style="text-align: left">规定成员所占的位数&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">BitField&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nl">is_enabled&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 1位用于表示是否启用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 3位用于表示是否启用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nl">has_data&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 1位用于表示是否有数据
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nl">length1&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 3位用于表示是否有数据
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nl">length2&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 8位用于表示是否有数据
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 可以继续添加更多位字段
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>length1其容量为 2^3 = 8，即赋值范围应为 [0,7]。&lt;/li>
&lt;li>length2其容量为 2^8 = 256，即赋值范围应为 [0,255]。&lt;/li>
&lt;li>未命名的位域，表示占位，字节对齐，仅起填充作用，并无实际意义。&lt;/li>
&lt;/ul>
&lt;h3 id="22位域的对齐">2.2.位域的对齐&lt;/h3>
&lt;p>一个位域成员不允许跨越两个 unsigned int 的边界，如果成员声明的总位数超过了一个 unsigned int 的大小， 那么编译器会自动移位位域成员，使其按照 unsigned int 的边界对齐。
例如：&lt;/p></description></item><item><title>C++ basic bit_operation</title><link>https://wesigj.github.io/p/c-basic-bit_operation/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-bit_operation/</guid><description>&lt;h1 id="c面试基础系列-bit_operation">C++面试基础系列-bit_operation&lt;/h1>
&lt;hr>
&lt;h2 id="1bit_operation定义">1.bit_operation定义&lt;/h2>
&lt;p>位操作也叫位运算，计算机底层基于二进制计算，所以位运算的运算效率更高，速度更快。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于正数来说，其反码和原码一致。对负数来说，反码就是对除去最高符号位之外的所有二进制位取反。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于正数来说，其补码与反码一致。对负数来说，补码就是对反码做通常意义上的加一操作（含进位）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>整数在计算机中是以补码的形式储存的，这就是为什么我们要介绍原码、反码和补码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>补码的好处：&lt;/p>
&lt;ul>
&lt;li>其一是明确了整数「0」的表示（否则可以有 0000 0000 和 1000 0000 两种方式表示），&lt;/li>
&lt;li>其二是对整数的加法只需要统一的一套电路来处理即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">20&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mo">0001&lt;/span> &lt;span class="mo">0100&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">原码&lt;/span>&lt;span class="n">Source&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mo">0001&lt;/span> &lt;span class="mo">0100&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">反码&lt;/span>&lt;span class="n">Inverse&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mo">0001&lt;/span> &lt;span class="mo">0100&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">补码&lt;/span>&lt;span class="n">complement&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">-&lt;/span>&lt;span class="mi">20&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1001&lt;/span> &lt;span class="mo">0100&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">原码&lt;/span>&lt;span class="n">Source&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1110&lt;/span> &lt;span class="mi">1011&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">反码&lt;/span>&lt;span class="n">Inverse&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1110&lt;/span> &lt;span class="mi">1100&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">补码&lt;/span>&lt;span class="n">complement&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="2bit_operation位运算符号类型">2.bit_operation位运算符号类型&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">符号&lt;/th>
 &lt;th style="text-align: left">描述&lt;/th>
 &lt;th style="text-align: left">运算规则&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">&amp;amp;&lt;/td>
 &lt;td style="text-align: left">与&lt;/td>
 &lt;td style="text-align: left">两个位都为1时，结果才为1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">|&lt;/td>
 &lt;td style="text-align: left">或&lt;/td>
 &lt;td style="text-align: left">两个位都为0时，结果才为0&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">^&lt;/td>
 &lt;td style="text-align: left">异或&lt;/td>
 &lt;td style="text-align: left">两个位相同为0，相异为1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">~&lt;/td>
 &lt;td style="text-align: left">取反&lt;/td>
 &lt;td style="text-align: left">0变1，1变0&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&amp;laquo;&lt;/td>
 &lt;td style="text-align: left">左移&lt;/td>
 &lt;td style="text-align: left">各二进位全部左移若干位，高位丢弃，低位补0&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&amp;raquo;&lt;/td>
 &lt;td style="text-align: left">右移&lt;/td>
 &lt;td style="text-align: left">各二进位全部右移若干位，高位补0或符号位补齐&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="3位运算的常用操作总结">3.位运算的常用操作总结&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">功 能&lt;/th>
 &lt;th style="text-align: left">位运算&lt;/th>
 &lt;th style="text-align: left">示例&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>方法一：提取最右边的1出来&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x &amp;amp; (~x + 1)&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>100101000 -&amp;gt; 000001000&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>方法二：提取最右边的1出来&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x &amp;amp; (-x)&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>100101000 -&amp;gt; 000001000&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>从右边开始，把最后一个 $1$ 改写成 $0$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x &amp;amp; (x - 1)&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>100101000 -&amp;gt; 100100000&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>去掉右边起第一个 $1$ 的左边&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x &amp;amp; (x ^ (x - 1))&lt;/code> 或 &lt;code>x &amp;amp; (-x)&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>100101000 -&amp;gt; 1000&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>去掉最后一位&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x &amp;gt;&amp;gt; 1&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>101101 -&amp;gt; 10110&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>取右数第 $k$ 位&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x &amp;gt;&amp;gt; (k - 1) &amp;amp; 1&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>1101101 -&amp;gt; 1, k = 4&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>取末尾 $3$ 位&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x &amp;amp; 7&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>1101101 -&amp;gt; 101&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>取末尾 $k$ 位&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x &amp;amp; 15&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>1101101 -&amp;gt; 1101, k = 4&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>只保留右边连续的 $1$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>(x ^ (x + 1)) &amp;gt;&amp;gt; 1&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>100101111 -&amp;gt; 1111&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>右数第 $k$ 位取反&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x ^ (1 &amp;lt;&amp;lt; (k - 1))&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>101001 -&amp;gt; 101101, k = 3&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>在最后加一个 $0$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x &amp;lt;&amp;lt; 1&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>101101 -&amp;gt; 1011010&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>在最后加一个 $1$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>(x &amp;lt;&amp;lt; 1) + 1&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>101101 -&amp;gt; 1011011&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>把右数第 $k$ 位变成 $0$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x &amp;amp; ~(1 &amp;lt;&amp;lt; (k - 1))&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>101101 -&amp;gt; 101001, k = 3&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>把右数第 $k$ 位变成 $1$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x | (1 &amp;lt;&amp;lt; (k - 1))&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>101001 -&amp;gt; 101101, k = 3&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>把右边起第一个 $0$ 变成 $1$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x | (x + 1)&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>100101111 -&amp;gt; 100111111&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>把右边连续的 $0$ 变成 $1$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x | (x - 1)&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>11011000 -&amp;gt; 11011111&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>把右边连续的 $1$ 变成 $0$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x &amp;amp; (x + 1)&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>100101111 -&amp;gt; 100100000&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>把最后一位变成 $0$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x | 1 - 1&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>101101 -&amp;gt; 101100&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>把最后一位变成 $1$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x | 1&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>101100 -&amp;gt; 101101&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>把末尾 $k$ 位变成 $1$&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x | (1 &amp;lt;&amp;lt; k - 1)&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>101001 -&amp;gt; 101111, k = 4&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>最后一位取反&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x ^ 1&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>101101 -&amp;gt; 101100&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;strong>末尾 $k$ 位取反&lt;/strong>&lt;/td>
 &lt;td style="text-align: left">&lt;code>x ^ (1 &amp;lt;&amp;lt; k - 1)&lt;/code>&lt;/td>
 &lt;td style="text-align: left">&lt;code>101001 -&amp;gt; 100110, k = 4&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="4位运算与宏定义">4.位运算与宏定义&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define bitRead(value, bit) (((value) &amp;gt;&amp;gt; (bit)) &amp;amp; 0x01)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define bitSet(value, bit) ((value) |= (1UL &amp;lt;&amp;lt; (bit)))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define bitClear(value, bit) ((value) &amp;amp;= ~(1UL &amp;lt;&amp;lt; (bit)))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define bitReverse(value, bit) ((value) ^= (1UL &amp;lt;&amp;lt; (bit)))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define bitWrite(value, bit, bitvalue) ((bitvalue) ? bitSet(value, bit) : bitClear(value, bit))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define lowByte(w) ((w) &amp;amp; 0xff)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define highByte(w) ((w) &amp;gt;&amp;gt; 8)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define bitRigthmostGet(value) ((value) &amp;amp; (-value))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define bitRigthmostClear(value) ((value) &amp;amp; (value-1))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//嵌入式中位操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="cp">#define SET_BIT(REG, BIT) ((REG) |= (BIT))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define CLEAR_BIT(REG, BIT) ((REG) &amp;amp;= ~(BIT))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define READ_BIT(REG, BIT) ((REG) &amp;amp; (BIT))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//嵌入式中寄存器操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="cp">#define CLEAR_REG(REG) ((REG) = (0x0))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define WRITE_REG(REG, VAL) ((REG) = (VAL))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define READ_REG(REG) ((REG))
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define MODIFY_REG(REG, CLEARMASK, SETMASK) WRITE_REG((REG), (((READ_REG(REG)) &amp;amp; (~(CLEARMASK))) | (SETMASK)))
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="5二进制枚举子集">5.二进制枚举子集&lt;/h2>
&lt;p>除了上面的这些常见操作，我们经常常使用二进制数第 $1 \sim n$ 位上 $0$ 或 $1$ 的状态来表示一个由 $1 \sim n$ 组成的集合。也就是说通过二进制来枚举子集。&lt;/p></description></item><item><title>C++ basic const</title><link>https://wesigj.github.io/p/c-basic-const/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-const/</guid><description>&lt;hr>
&lt;h1 id="c面试基础系列-const">C++面试基础系列-const&lt;/h1>
&lt;h2 id="1const含义">1.const含义&lt;/h2>
&lt;p>const表示常类型，其值不可更改。&lt;/p>
&lt;h2 id="2const作用">2.const作用&lt;/h2>
&lt;ul>
&lt;li>修饰常量&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">66&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>类型检查
&lt;ul>
&lt;li>const具有类型，并支持所有类型&lt;/li>
&lt;li>const修饰，名为常量，具备不可更改属性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>防更改，保护作用，增加程序健壮性&lt;/li>
&lt;li>节省空间，内存
&lt;ul>
&lt;li>从汇编上看，const实质是使用内存地址访问，#define是立即数&lt;/li>
&lt;li>const常量存储在内存中，只有一个内存地址，#define是预编译时，拷贝到代码中，不占用内存空间（RAM），占用ROM。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3const作用域">3.const作用域&lt;/h2>
&lt;ul>
&lt;li>const 常量具有块作用域（如果定义在函数或代码块内部）或文件作用域（如果定义在所有函数外部），遵循C语言的普通作用域规则。&lt;/li>
&lt;li>#define 定义的宏在预处理阶段展开，没有作用域的概念，除非使用 #undef 取消定义。&lt;/li>
&lt;/ul>
&lt;h2 id="4修饰常量">4.修饰常量&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="mi">66&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//ERROR can not change const constant
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="5const与指针">5.const与指针&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//指向const常类型的普通指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//同上
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//指向int类型的常指针
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="c1">//指向const常类型的常指针
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>有趣的解析方法&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//p is a pointer to const char
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//同上
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//p is a const pointer to char
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//p is a const pointer to const char
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="51指向常量的指针">5.1.指向常量的指针&lt;/h3>
&lt;ul>
&lt;li>指向常量的指针，其中常量不可修改&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># *p=10; &lt;/span>&lt;span class="c1">//error 不能修改常量
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// int *p = &amp;amp;a; //error 常量必须用常指针指向
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>允许把非const对象的地址赋给指向const对象的指针&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">p&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="52常指针">5.2.常指针&lt;/h3>
&lt;p>const指针定义时，必须初始化，const指针不可变，但指向的值可变。&lt;/p></description></item><item><title>C++ basic decltype</title><link>https://wesigj.github.io/p/c-basic-decltype/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-decltype/</guid><description>&lt;h1 id="c面试基础系列-decltype">C++面试基础系列-decltype&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;ul>
&lt;li>在C++中，&lt;code>decltype&lt;/code> 是一个类型推导关键字，它用于确定表达式的类型。&lt;code>decltype&lt;/code> 可以在编译时确定一个变量或表达式的类型，而不需要显式地声明类型。这在模板编程和泛型编程中非常有用，尤其是在C++11及以后的版本中。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="1decltype关键点">1.decltype关键点&lt;/h2>
&lt;p>以下是 &lt;code>decltype&lt;/code> 的一些关键点：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>基本用法&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>decltype&lt;/code> 的基本语法是 &lt;code>decltype(表达式)&lt;/code>，它返回表达式的类型。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>引用修饰符&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>如果表达式是一个左值，&lt;code>decltype&lt;/code> 将返回带有引用修饰符的类型（例如 &lt;code>int&amp;amp;&lt;/code>）。如果表达式是一个右值，返回的类型将不包含引用修饰符（例如 &lt;code>int&lt;/code>）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数组和函数类型&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>decltype&lt;/code> 不会从数组或函数类型中推导出 &lt;code>pointer&lt;/code> 类型，而是保持原始类型（例如 &lt;code>int[]&lt;/code> 或 &lt;code>void()&lt;/code>）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>结合 &lt;code>auto&lt;/code> 关键字&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>decltype&lt;/code> 经常与 &lt;code>auto&lt;/code> 关键字结合使用，以实现类型推导。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>模板参数推导&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>在模板参数推导中，&lt;code>decltype&lt;/code> 可以用于推导出模板参数的类型。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>lambda 表达式&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>对于 lambda 表达式，&lt;code>decltype&lt;/code> 推导出的类型是 &lt;code>std::function&lt;/code> 的实例类型。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="示例代码">示例代码&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;vector&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;functional&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;typeinfo&amp;gt;&lt;/span>&lt;span class="cp"> &lt;/span>&lt;span class="c1">// 需要包含这个头文件来使用 typeid
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">exampleFunction&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Type of i: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="k">typeid&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 注意：这里不需要使用 decltype，因为 i 已经是 int&amp;amp; 类型
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">3.14&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Type of a: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="k">typeid&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// decltype(a) 是不必要的，因为 a 已经是一个 int 类型的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">auto&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 使用 auto 推导 x 的类型为 int
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Type of x: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="k">typeid&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 移除 exampleFunction 的调用，因为它没有返回值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// auto y = exampleFunction(a); // 这行是错误的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 代码中 auto y = exampleFunction(a); 这一行存在问题，因为 exampleFunction 函数没有返回值，所以尝试将一个没有返回值的函数调用赋值给变量 y 是不正确的。auto 关键字在这里会推导出 void 类型，因为 exampleFunction 的返回类型是 void。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// decltype 推导 lambda 表达式的类型
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">auto&lt;/span> &lt;span class="n">lambda&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[](&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Type of lambda: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="k">typeid&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lambda&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>在这个示例中，&lt;code>decltype&lt;/code> 用于推导不同表达式的类型。注意，&lt;code>typeid&lt;/code> 用于输出类型信息，它需要包含 &lt;code>&amp;lt;typeinfo&amp;gt;&lt;/code> 头文件。&lt;code>decltype&lt;/code> 在这里用于推导变量 &lt;code>a&lt;/code> 的类型，以及 &lt;code>auto&lt;/code> 变量 &lt;code>x&lt;/code> 的类型。对于 &lt;code>exampleFunction&lt;/code> 函数，&lt;code>decltype&lt;/code> 推导了函数参数 &lt;code>i&lt;/code> 的类型。最后，对于 lambda 表达式，&lt;code>decltype&lt;/code> 推导出了一个 &lt;code>std::function&lt;/code> 类型。
&lt;br>
请注意，typeid(lambda).name() 可能不会返回一个有用的字符串，因为 lambda 表达式产生的函数对象类型通常不是多态类型，name() 方法对于非多态类型可能返回空指针。如果你想要打印 lambda 表达式的类型，你可能需要使用其他方法，例如直接使用 std::cout 来输出类型信息。&lt;/p></description></item><item><title>C++ basic double_colon(::)</title><link>https://wesigj.github.io/p/c-basic-double_colon/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-double_colon/</guid><description>&lt;h1 id="c面试基础系列-double_colon">C++面试基础系列-double_colon(::)&lt;/h1>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;ul>
&lt;li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间&lt;/li>
&lt;li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的&lt;/li>
&lt;li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的&lt;/li>
&lt;/ul>
&lt;h2 id="1double_colon关键点">1.double_colon(::)关键点&lt;/h2>
&lt;p>在C和C++中，双冒号 :: 被称为作用域解析运算符（scope resolution operator），但它在两种语言中的使用和含义略有不同：&lt;/p>
&lt;ul>
&lt;li>C语言中的::
&lt;ul>
&lt;li>在C语言中，:: 几乎不被使用，因为它主要用于指定全局作用域，而C语言中大部分变量和函数默认就是全局作用域的。不过，:: 可以用来明确指出全局变量或函数，尤其是在与静态成员函数一起使用时。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>C++中的::
&lt;ul>
&lt;li>在C++中，:: 的使用要普遍得多，因为它用于解决作用域的问题，尤其是在类（class）和命名空间（namespace）中。&lt;/li>
&lt;li>用于访问类的静态成员变量或静态成员函数：ClassName::staticMember。&lt;/li>
&lt;li>用于访问命名空间中的成员：NamespaceName::member。&lt;/li>
&lt;li>用于在类内部访问全局变量或函数，避免与局部变量或成员变量的名称冲突：::globalVariable。&lt;/li>
&lt;li>用于在派生类中访问基类的成员：BaseClassName::member。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>全局作用域：
&lt;ul>
&lt;li>在C++中，如果需要明确指出某个实体属于全局作用域，可以使用 ::。例如，在一个函数内部，如果你想要访问全局变量，可以使用 ::globalVariable。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>类型转换：
&lt;ul>
&lt;li>在C++中，:: 也用于类型转换，称为静态类型转换或类类型转换，例如 Type::pointer。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>模板参数：
&lt;ul>
&lt;li>在C++模板编程中，:: 用于指定模板参数的命名空间或类作用域，例如 std::vector&lt;code>&amp;lt;int&amp;gt;&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>匿名空间：
&lt;ul>
&lt;li>在C++中，:: 还可以用于匿名命名空间，这是一种特殊的命名空间，它提供了文件内唯一的作用域。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>C++11中的统一初始化：&lt;/li>
&lt;li>从C++11开始，:: 不再是统一初始化（Uniform Initialization）的一部分。统一初始化使用花括号 {} 而不是 ::。&lt;/li>
&lt;/ul>
&lt;p>总结来说，:: 在C++中是一个关键的运算符，用于处理作用域相关的问题，而在C语言中，由于作用域规则的不同，:: 的使用相对较少。&lt;/p>
&lt;h2 id="2double_colon使用示例">2.double_colon(::)使用示例&lt;/h2>
&lt;p>在C++中，双冒号 :: 是作用域解析运算符（scope resolution operator），用于明确指出我们访问的是特定作用域内的实体。以下是 :: 的一些主要用途和示例：&lt;/p>
&lt;h3 id="21访问类成员">2.1.访问类成员&lt;/h3>
&lt;p>使用 :: 来访问类的成员变量和成员函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">memberVar&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">memberFunc&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MyClass&lt;/span> &lt;span class="n">myObj&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myObj&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">memberVar&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 访问成员变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">myObj&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">memberFunc&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 访问成员函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="22静态成员访问">2.2.静态成员访问&lt;/h3>
&lt;p>使用 :: 来访问类的静态成员，因为静态成员不属于类的任何特定对象。&lt;/p></description></item><item><title>C++ basic enum</title><link>https://wesigj.github.io/p/c-basic-enum/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-enum/</guid><description>&lt;h1 id="c面试基础系列-enum">C++面试基础系列-enum&lt;/h1>
&lt;h2 id="1enum关键点">1.enum关键点&lt;/h2>
&lt;p>enum（枚举）是一种数据类型，在C和C++语言中用来定义命名的整数值集合。枚举为一组相关的常量提供了一种更加清晰和易于理解的表示方式。&lt;/p>
&lt;p>以下是enum的一些关键点：&lt;/p>
&lt;h3 id="11定义枚举类型">1.1.定义枚举类型&lt;/h3>
&lt;p>使用enum关键字定义枚举类型，可以指定底层的整数类型（如int、unsigned int等），如果不指定，默认为`int。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">enum&lt;/span> &lt;span class="nc">Color&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">RED&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GREEN&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BLUE&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="12枚举成员">1.2.枚举成员&lt;/h3>
&lt;p>枚举成员是枚举类型的值，它们在定义时自动从0开始编号，每个成员依次加1。&lt;/p>
&lt;h3 id="13指定底层类型">1.3.指定底层类型&lt;/h3>
&lt;p>可以为枚举成员指定底层类型，改变它们的存储大小和范围。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">enum&lt;/span> &lt;span class="nc">Color&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="kt">uint8_t&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">RED&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GREEN&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BLUE&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="14前向声明">1.4.前向声明&lt;/h3>
&lt;p>在C++中，可以对枚举类型进行前向声明，但需要在后续的定义中指定其成员。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// C++前向声明
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">enum&lt;/span> &lt;span class="nc">Color&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ... 后续定义
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">enum&lt;/span> &lt;span class="nc">Color&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">RED&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GREEN&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BLUE&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="15作用域">1.5.作用域&lt;/h3>
&lt;p>在C++中，枚举类型具有作用域，其成员名称在枚举类型的作用域内有效。C语言中的枚举成员是全局的，除非使用enum { member1, member2, &amp;hellip; }语法。&lt;/p>
&lt;h3 id="16类型安全">1.6.类型安全&lt;/h3>
&lt;p>枚举提供了类型安全，不同枚举类型的值不能互相赋值或比较，除非显式地进行类型转换。&lt;/p>
&lt;h3 id="17与整数的兼容性">1.7.与整数的兼容性&lt;/h3>
&lt;p>枚举类型可以与整数类型进行比较和赋值，但这样做可能会破坏类型安全。&lt;/p>
&lt;h3 id="18迭代器">1.8.迭代器&lt;/h3>
&lt;p>C++11标准引入了基于范围的for循环，可以方便地遍历枚举类型的所有值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">Color&lt;/span> &lt;span class="nl">c&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">RED&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GREEN&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BLUE&lt;/span>&lt;span class="p">})&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用c
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="19强类型枚举c11">1.9.强类型枚举（C++11）&lt;/h3>
&lt;p>C++11引入了强类型枚举，使用enum class关键字定义，增强了类型安全。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">enum&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Color&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">RED&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GREEN&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BLUE&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="110位字段枚举">1.10.位字段枚举&lt;/h3>
&lt;p>枚举类型可以用于定义位字段，表示一组标志位的组合。&lt;/p>
&lt;h3 id="111枚举作为函数参数和返回类型">1.11.枚举作为函数参数和返回类型&lt;/h3>
&lt;p>枚举类型可以作为函数的参数和返回类型，提供清晰的函数接口。&lt;/p>
&lt;p>枚举是一种非常有用的语言特性，它提高了代码的可读性和可维护性，特别是在处理一组相关的常量时。在嵌入式编程、状态机实现、配置选项等方面都有广泛应用。&lt;/p>
&lt;h2 id="2enum与namespace">2.enum与namespace&lt;/h2>
&lt;ul>
&lt;li>解决作用域不受限带来的命名冲突问题
&lt;ul>
&lt;li>给枚举变量命名时加前缀&lt;/li>
&lt;li>C 程序中，为了一致性我们会把所有常量统一加上前缀。但是这样定义枚举变量的代码就显得累赘。&lt;/li>
&lt;li>C 程序中可能不得不这样做。不过 C++ 程序员恐怕都不喜欢这种方法。替代方案是命名空间:&lt;/li>
&lt;li>下面代码可以用 &lt;code>Color::Type c = Color::RED;&lt;/code> 来定义新的枚举变量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="k">namespace&lt;/span> &lt;span class="n">Color&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">enum&lt;/span> &lt;span class="nc">Type&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RED&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">15&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">YELLOW&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">BLUE&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不过，因为命名空间是可以随后被扩充内容的，所以它提供的作用域封闭性不高。在大项目中，还是有可能不同人给不同的东西起同样的枚举类型名。&lt;/p></description></item><item><title>C++ basic explicit</title><link>https://wesigj.github.io/p/c-basic-explicit/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-explicit/</guid><description>&lt;h1 id="c面试基础系列-explicit">C++面试基础系列-explicit&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;h2 id="1explicit">1.explicit&lt;/h2>
&lt;p>在 C++ 中，&amp;ldquo;explicit&amp;rdquo; 关键字用于类构造函数，以防止隐式类型转换和复制初始化。使用 &lt;code>explicit&lt;/code> 可以提高代码的安全性，因为它要求在转换类型时必须明确地进行。下面是一些关于 &lt;code>explicit&lt;/code> 的使用场景和示例：&lt;/p>
&lt;h3 id="11使用场景">1.1.使用场景&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>防止隐式转换&lt;/strong>：当你希望类的构造函数只用于显示转换，而不是由编译器隐式执行时。&lt;/li>
&lt;li>&lt;strong>避免歧义&lt;/strong>：在多构造函数的情况下，&lt;code>explicit&lt;/code> 可以避免编译器在选择调用哪个构造函数时产生歧义。&lt;/li>
&lt;/ol>
&lt;h3 id="12语法">1.2.语法&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">explicit&lt;/span> &lt;span class="n">MyClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Type&lt;/span> &lt;span class="n">param&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 构造函数实现
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 其他成员和方法
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="13示例">1.3.示例&lt;/h3>
&lt;h4 id="131防止隐式类型转换">1.3.1.防止隐式类型转换&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">NumericString&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">explicit&lt;/span> &lt;span class="n">NumericString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 初始化逻辑，可能包括检查字符串是否只包含数字
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">NumericString&lt;/span> &lt;span class="n">ns&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;123&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 正确，显示转换
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// NumericString ns2 = &amp;#34;123&amp;#34;; // 错误，因为构造函数是 explicit 的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="132构造函数重载解析">1.3.2.构造函数重载解析&lt;/h4>
&lt;p>如果有多个构造函数，&lt;code>explicit&lt;/code> 可以帮助编译器确定应该调用哪个构造函数。&lt;/p></description></item><item><title>C++ basic extern</title><link>https://wesigj.github.io/p/c-basic-extern/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-extern/</guid><description>&lt;h1 id="c面试基础系列-extern">C++面试基础系列-extern&lt;/h1>
&lt;h2 id="1extern关键点">1.extern关键点&lt;/h2>
&lt;p>在C和C++中，&lt;code>extern&lt;/code>是一个关键字，用于声明一个变量或函数是在其他文件或编译单元中定义的，即它具有外部链接。以下是 &lt;code>extern&lt;/code>的一些关键点：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>外部链接&lt;/strong> ：&lt;code>extern&lt;/code>关键字声明的变量或函数具有外部链接，这意味着它们可以在多个文件中访问。&lt;/li>
&lt;li>&lt;strong>声明而非定义&lt;/strong> ：使用 &lt;code>extern&lt;/code>是声明一个已经在其他地方定义的变量或函数，而不是定义它们。&lt;/li>
&lt;li>&lt;strong>多文件共享&lt;/strong> ：当你想在多个文件中使用同一个全局变量或函数时，可以在其他文件中使用 &lt;code>extern&lt;/code>来声明它们。&lt;/li>
&lt;li>&lt;strong>定义位置&lt;/strong> ：被 &lt;code>extern&lt;/code>声明的变量或函数必须在某个文件中有确切的定义（带有类型和存储期的声明）。&lt;/li>
&lt;li>&lt;strong>头文件中使用&lt;/strong> ：&lt;code>extern&lt;/code>经常与头文件一起使用，允许在多个源文件中包含同一个头文件，而不会因多重包含而导致变量或函数被多次定义。&lt;/li>
&lt;li>&lt;strong>C++中的使用&lt;/strong> ：在C++中，&lt;code>extern&lt;/code>也可以用于声明C语言编写的库中的变量和函数，因为它可以用来指定C语言的外部链接。&lt;/li>
&lt;li>&lt;strong>存储期&lt;/strong> ：&lt;code>extern&lt;/code>声明的变量具有静态存储期，即它们在程序的整个运行期间都存在。&lt;/li>
&lt;li>&lt;strong>作用域&lt;/strong> ：&lt;code>extern&lt;/code>声明的变量或函数在声明它们的文件中是可见的，但它们的作用域限制在声明它们的块内，除非它们在全局作用域中声明。&lt;/li>
&lt;li>&lt;strong>初始化&lt;/strong> ：&lt;code>extern&lt;/code>声明的变量不能在声明时初始化，因为它们已经在其他地方定义并初始化了。&lt;/li>
&lt;li>示例：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// file1.c
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">globalVar&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">42&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 定义并初始化一个全局变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// file2.c
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">extern&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">globalVar&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 声明 globalVar，它在 file1.c 中定义
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在上述示例中，&lt;code>globalVar&lt;/code>在 &lt;code>file1.c&lt;/code>中定义并初始化。在 &lt;code>file2.c&lt;/code>中，使用 &lt;code>extern&lt;/code>关键字来声明 &lt;code>globalVar&lt;/code>，表示它在其他地方定义，这样 &lt;code>file2.c&lt;/code>就可以访问 &lt;code>globalVar&lt;/code>了。&lt;/p>
&lt;p>&lt;code>extern&lt;/code>是C和C++中实现不同文件间全局变量和函数共享的重要机制。&lt;/p>
&lt;h2 id="2c-extern-c">2.C++ extern &lt;code>&amp;quot;C&amp;quot;&lt;/code>&lt;/h2>
&lt;p>在C++中使用C语言编写的库时，&lt;code>extern &amp;quot;C&amp;quot;&lt;/code>（注意C是大写的）是一个特殊的声明，它告诉C++编译器按照C语言的规则来处理被声明的实体。这主要是因为C++支持函数重载，而C语言不支持。以下是 &lt;code>extern &amp;quot;C&amp;quot;&lt;/code>的一些特别作用：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>语言链接指示&lt;/strong> ：&lt;code>extern &amp;quot;C&amp;quot;&lt;/code>指示编译器，被声明的函数或变量遵循C语言的链接规则，而不是C++的命名规则（Name Mangling）。&lt;/li>
&lt;li>&lt;strong>避免名称重整（Name Mangling）&lt;/strong> ：C++编译器会对函数名进行编码（即名称重整），以支持函数重载。而C语言没有函数重载的概念，其函数名在编译后不会改变。使用 &lt;code>extern &amp;quot;C&amp;quot;&lt;/code>可以防止C++编译器对C函数名进行重整。&lt;/li>
&lt;li>&lt;strong>兼容C库&lt;/strong> ：当需要链接C语言编写的库时，使用 &lt;code>extern &amp;quot;C&amp;quot;&lt;/code>可以确保C++代码能够正确调用C库中的函数和变量。&lt;/li>
&lt;li>&lt;strong>C++和C的互操作&lt;/strong> ：&lt;code>extern &amp;quot;C&amp;quot;&lt;/code>是C++代码与C代码进行互操作的一种方式，使得C++程序能够直接调用C语言的函数和访问全局变量。&lt;/li>
&lt;li>&lt;strong>头文件包含&lt;/strong> ：在使用C语言库的头文件时，通常也会用 &lt;code>extern &amp;quot;C&amp;quot;&lt;/code>将整个头文件的内容包裹起来，以确保所有引用的函数和变量都遵循C语言的链接规则。&lt;/li>
&lt;li>&lt;strong>全局作用域&lt;/strong> ：&lt;code>extern &amp;quot;C&amp;quot;&lt;/code>声明通常放在全局作用域中，以确保整个程序中的C++代码都遵循相同的链接规则。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>extern &amp;quot;C&amp;quot;&lt;/code>是C++中处理C语言库的重要工具，它确保了C++代码能够与C语言代码无缝集成和互操作。&lt;/p></description></item><item><title>C++ basic Features</title><link>https://wesigj.github.io/p/c-basic-features/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-features/</guid><description>&lt;h1 id="c面试基础系列-cfeatures">C++面试基础系列-C++Features&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;h2 id="1cfeatures">1.C++Features&lt;/h2>
&lt;ul>
&lt;li>C++与C的区别在于C++拥有更多的新特性&lt;/li>
&lt;li>&amp;ldquo;Explicit C++&amp;quot;（显式C++）通常指的是在C++编程中明确地、直接地使用C++的特性和语法，而不是隐式地或通过兼容C的方式。这通常意味着充分利用C++的面向对象编程（OOP）特性，例如
&lt;ul>
&lt;li>类（classes）、&lt;/li>
&lt;li>对象（objects）、&lt;/li>
&lt;li>继承（inheritance）、&lt;/li>
&lt;li>多态（polymorphism）、&lt;/li>
&lt;li>抽象（abstraction）、&lt;/li>
&lt;li>封装（encapsulation）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>以下是一些显式C++编程的关键概念和实践：&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>类和对象&lt;/strong>：使用类来创建复杂的数据结构，这些结构可以包含数据成员和成员函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">privateData&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MyClass&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">privateData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="c1">// 构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">privateData&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="nf">get&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">privateData&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>构造函数和析构函数&lt;/strong>：显式地定义构造函数来初始化对象，定义析构函数来执行清理工作。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">MyClass&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">MyClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">initialValue&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">privateData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">initialValue&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">~&lt;/span>&lt;span class="n">MyClass&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 清理工作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>继承&lt;/strong>：使用继承来创建基于现有类的新的类，实现代码复用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">DerivedClass&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">BaseClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 继承BaseClass的成员
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>多态&lt;/strong>：通过虚函数实现多态性，允许通过基类指针或引用调用派生类的方法。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Base&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">doSomething&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="cm">/* ... */&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Derived&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Base&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">doSomething&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">override&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="cm">/* ... */&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>抽象类&lt;/strong>：使用纯虚函数创建抽象类，这些类不能被实例化，但可以作为其他类的接口。&lt;/p></description></item><item><title>C++ basic friend</title><link>https://wesigj.github.io/p/c-basic-friend/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-friend/</guid><description>&lt;h1 id="c面试基础系列-friend">C++面试基础系列-friend&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>在C++中，&lt;code>friend&lt;/code>是一个关键字，它用于声明友元函数或友元类。友元是一种特殊的实体，它不是类的成员，但有权访问类的私有（&lt;code>private&lt;/code>）和保护（&lt;code>protected&lt;/code>）成员。使用&lt;code>friend&lt;/code>可以突破类的封装性，让特定的函数或类访问类的内部细节。&lt;/p>
&lt;h2 id="1friend友元的常见用法">1.friend友元的常见用法&lt;/h2>
&lt;p>以下是一些关于&lt;code>friend&lt;/code>在C++中的用法：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>友元函数&lt;/strong>：可以声明为友元的函数能够访问类的非公共成员。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">privateData&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MyClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">privateData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">friend&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">accessPrivateData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">MyClass&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 声明友元函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">accessPrivateData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">MyClass&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 直接访问obj的私有成员
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">privateData&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>友元类&lt;/strong>：可以声明为友元的类的所有成员函数都能够访问声明它的类的私有和保护成员。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">FriendClass&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">privateData&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MyClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">privateData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">friend&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">FriendClass&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 声明友元类
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">FriendClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">accessPrivateData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">MyClass&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 直接访问obj的私有成员
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">privateData&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>友元在多文件编程中的使用&lt;/strong>：在多文件项目中，需要在类声明中和实现文件中都声明友元函数或类。&lt;/p></description></item><item><title>C++ basic inline内联</title><link>https://wesigj.github.io/p/c-basic-inline%E5%86%85%E8%81%94/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-inline%E5%86%85%E8%81%94/</guid><description>&lt;h1 id="c面试基础系列-inline内联">C++面试基础系列-inline内联&lt;/h1>
&lt;p>[toc]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;ul>
&lt;li>inline可以在头文件中声明和定义函数或变量&lt;/li>
&lt;li>不违反一次定义规则（One Definition Rule, ODR）&lt;/li>
&lt;li>会加快程序运行速度（避免函数调用的开销，如建立栈帧、传递参数等操作），但会增加代码ROM使用&lt;/li>
&lt;/ul>
&lt;h2 id="1inline介绍">1.inline介绍&lt;/h2>
&lt;p>在C++中，&lt;code>inline&lt;/code>关键字是一种函数或变量的声明属性，它请求编译器在编译时将函数或变量的定义嵌入到每个使用该函数或变量的地方，从而避免函数调用的开销。使用&lt;code>inline&lt;/code>可以提高程序的执行效率，尤其是在调用小型函数时。&lt;/p>
&lt;p>以下是&lt;code>inline&lt;/code>的一些关键点和用法：&lt;/p>
&lt;h3 id="1定义内联函数">1.定义内联函数&lt;/h3>
&lt;p>内联函数是在定义时使用&lt;code>inline&lt;/code>关键字声明的函数。编译器会尝试将这些函数的定义直接嵌入到调用点，从而减少函数调用的开销。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">inline&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2内联函数的声明与定义">2.内联函数的声明与定义&lt;/h3>
&lt;p>内联函数通常在头文件中声明和定义，这样它们的定义可以被多个编译单元（.cpp文件）包含，而不会违反一次定义规则（One Definition Rule, ODR）。&lt;/p>
&lt;h3 id="3编译器的自由裁量权">3.编译器的自由裁量权&lt;/h3>
&lt;p>编译器对是否内联一个函数有最终决定权。即使使用了&lt;code>inline&lt;/code>关键字，编译器也可能出于优化或其他原因选择不内联该函数。&lt;/p>
&lt;h3 id="4内联变量">4.内联变量&lt;/h3>
&lt;p>&lt;code>inline&lt;/code>也可以用于变量，特别是对于常量表达式。内联变量的定义可以在多个编译单元中使用，而不违反ODR。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">inline&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">MAX_SIZE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="5模板函数自动内联">5.模板函数自动内联&lt;/h3>
&lt;p>模板函数在实例化时通常会被编译器视为内联，即使没有显式地使用&lt;code>inline&lt;/code>关键字。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">template&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">typename&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">T&lt;/span> &lt;span class="n">maximum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="nl">a&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="6内联汇编">6.内联汇编&lt;/h3>
&lt;p>&lt;code>inline&lt;/code>还可以与汇编语言一起使用，允许在C++代码中嵌入汇编指令。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">inline&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">readFlag&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">asm&lt;/span> &lt;span class="k">volatile&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;in %1, %0&amp;#34;&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="s">&amp;#34;=a&amp;#34;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="s">&amp;#34;dN&amp;#34;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mh">0x01&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="c1">// x86特定汇编
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="7内联命名空间">7.内联命名空间&lt;/h3>
&lt;p>C++17引入了内联命名空间，它允许在不同的编译单元中使用相同的命名空间名称而不会引起冲突。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">inline&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">experimental&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="8内联函数的限制">8.内联函数的限制&lt;/h3>
&lt;p>内联函数有一些限制，例如它们不能包含循环、跳转语句（如&lt;code>goto&lt;/code>）、递归调用等复杂结构。&lt;/p></description></item><item><title>C++ basic macro_definition宏定义</title><link>https://wesigj.github.io/p/c-basic-macro_definition%E5%AE%8F%E5%AE%9A%E4%B9%89/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-macro_definition%E5%AE%8F%E5%AE%9A%E4%B9%89/</guid><description>&lt;h1 id="c面试基础系列-macro_definition宏定义">C++面试基础系列-macro_definition宏定义&lt;/h1>
&lt;p>[toc]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>在C++中，宏定义是预处理器（preprocessor）的一个功能，它允许你创建一个符号名称来代表一个值或一段代码。宏定义通常在预处理指令&lt;code>#define&lt;/code>后面指定。以下是宏定义的一些关键点和用法：&lt;/p>
&lt;hr>
&lt;h2 id="1宏定义的概念">1.宏定义的概念&lt;/h2>
&lt;h3 id="11-基本宏定义">1.1. 基本宏定义&lt;/h3>
&lt;p>使用&lt;code>#define&lt;/code>指令创建一个宏。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define PI 3.14159
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="12-带参数的宏">1.2. 带参数的宏&lt;/h3>
&lt;p>可以定义带参数的宏，类似于一个没有花括号的内联函数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define SQUARE(x) ((x) * (x))
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="13-条件编译">1.3. 条件编译&lt;/h3>
&lt;p>宏可以用于条件编译，控制代码的编译过程。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define DEBUG_MODE
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#ifdef DEBUG_MODE
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Debug information&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define DEBUG_MODE
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#if define(DEBUG_MODE)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Debug information&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="14-宏的展开">1.4. 宏的展开&lt;/h3>
&lt;p>在预处理阶段，宏将被展开到它们被引用的地方。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;The square of 3 is &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">SQUARE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>预处理器将上述代码展开为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;The square of 3 is &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="15-宏的副作用">1.5. 宏的副作用&lt;/h3>
&lt;p>宏可以导致意外的行为，尤其是如果宏的使用不符合预期或宏的定义不当。&lt;/p></description></item><item><title>C++ basic polymorphic</title><link>https://wesigj.github.io/p/c-basic-polymorphic/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-polymorphic/</guid><description>&lt;h1 id="c面试基础系列-polymorphic">C++面试基础系列-polymorphic&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;ul>
&lt;li>C++ 支持面向对象编程，包括类（Class）和对象（Object）、继承（Inheritance）、封装（Encapsulation）和多态（Polymorphism）。&lt;/li>
&lt;li>C 语言不支持面向对象编程。&lt;/li>
&lt;/ul>
&lt;h2 id="1polymorphic多态性">1.polymorphic多态性&lt;/h2>
&lt;p>在C++中，多态性（Polymorphism）是一个核心概念，它允许我们通过基类的接口来使用派生类的对象。多态性使得代码更加灵活和可扩展，主要有以下几种形式：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>编译时多态（静态绑定）&lt;/strong>：通过函数重载和运算符重载实现，它们在编译时就已经确定。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>运行时多态（动态绑定）&lt;/strong>：通过虚函数实现，调用哪个函数的实现是在运行时根据对象的实际类型来确定的。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="2编译时多态的实现">2.编译时多态的实现&lt;/h2>
&lt;p>编译时多态，也称为静态多态或早绑定（Early Binding），是在编译期间确定函数调用的机制。在C++中，编译时多态主要通过以下几种方式实现：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>函数重载（Function Overloading）&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>允许在同一个作用域内定义多个同名函数，只要它们的参数列表不同（参数类型、数量或顺序不同）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>运算符重载（Operator Overloading）&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>允许为自定义类型定义或修改已有运算符的行为。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>模板（Templates）&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>允许创建泛型类和函数，它们可以在编译时根据模板参数实例化出不同类型的具体实现。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="示例代码">示例代码&lt;/h3>
&lt;h4 id="函数重载示例">函数重载示例&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 函数重载示例
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">void&lt;/span> &lt;span class="nf">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Integer: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">double&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Double: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 调用第一个print函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">3.14&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 调用第二个print函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>print&lt;/code> 函数被重载了两次，一次接受 &lt;code>int&lt;/code> 类型的参数，另一次接受 &lt;code>double&lt;/code> 类型的参数。编译器根据传递给 &lt;code>print&lt;/code> 函数的参数类型来决定调用哪个函数。&lt;/p></description></item><item><title>C++ basic series</title><link>https://wesigj.github.io/p/c-basic-series/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-series/</guid><description>&lt;h1 id="overview">Overview&lt;/h1>
&lt;hr>
&lt;h2 id="c-basic-面试基础知识系列">C++ basic 面试基础知识系列&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-abstract/">abstract&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-assert/">assert&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-bit_field/">bit_field&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-bit_operation/">bit_operation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-features/">C++Features&lt;/a>&lt;/li>
&lt;li>&lt;a href="./Basic/const/README.md">const&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-decltype/">decltype&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-double_colon/">double_colon&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-enum/">enum&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-explicit/">explicit&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-extern/">extern&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-friend/">friend&lt;/a>&lt;/li>
&lt;li>&lt;a href="./Basic/function_pointerANDpointer_function/README.md">function_pointerANDpointer_function&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-inline%E5%86%85%E8%81%94/">inline&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-macro_definition%E5%AE%8F%E5%AE%9A%E4%B9%89/">macro_definition&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/">pointerANDreferance&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-polymorphic/">polymorphic&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-sizeof/">sizeof&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-static/">static&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-struct/">struct&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-this/">this&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-union/">union&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-using/">using&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-%E8%99%9A%E5%87%BD%E6%95%B0virtual/">virtual&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-volatile/">volatile&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-%E8%99%9A%E5%87%BD%E6%95%B0vptr_vtable/">vptr_vtable&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="关于作者">关于作者&lt;/h2>
&lt;ul>
&lt;li>微信公众号:WeSiGJ&lt;/li>
&lt;li>GitHub:&lt;a href="https://github.com/wesigj/cplusplusboys">https://github.com/wesigj/cplusplusboys&lt;/a>&lt;/li>
&lt;li>CSDN:&lt;a href="https://blog.csdn.net/wesigj">https://blog.csdn.net/wesigj&lt;/a>&lt;/li>
&lt;li>微博:&lt;/li>
&lt;li>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。&lt;/li>
&lt;/ul>
&lt;img src=https://wesigj.github.io/./img/wechat.jpg width=60% /></description></item><item><title>C++ basic sizeof</title><link>https://wesigj.github.io/p/c-basic-sizeof/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-sizeof/</guid><description>&lt;h1 id="c面试基础系列-sizeof">C++面试基础系列-sizeof&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;ul>
&lt;li>sizeof，可用于分析数据结构的内存分配，字节对齐
&lt;ul>
&lt;li>类&lt;/li>
&lt;li>结构体&lt;/li>
&lt;li>基础类型int，char等&lt;/li>
&lt;li>数组&lt;/li>
&lt;li>模板&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>sizeof与类，
&lt;ul>
&lt;li>空类的大小为1字节&lt;/li>
&lt;li>虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间&lt;/li>
&lt;li>对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小&lt;/li>
&lt;li>普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小&lt;/li>
&lt;li>虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！&lt;/li>
&lt;li>虚继承,继承基类的vptr。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1sizeof基本用法">1.sizeof基本用法&lt;/h2>
&lt;p>在 C++ 中，&lt;code>sizeof&lt;/code> 运算符用于确定变量或类型在内存中的大小，以字节为单位。&lt;code>sizeof&lt;/code> 是编译时运算符，它的&lt;strong>值在编译时就已经确定，并被用作一个常量表达式。&lt;/strong>&lt;/p>
&lt;p>以下是 &lt;code>sizeof&lt;/code> 的一些用法示例：&lt;/p>
&lt;h3 id="11基本类型">1.1.基本类型&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 输出 &amp;#39;i&amp;#39; 的大小，通常是 4 字节（取决于平台）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="12指针类型">1.2.指针类型&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 输出指针 &amp;#39;p&amp;#39; 的大小，通常是 sizeof(void*)（取决于平台）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="13数组类型">1.3.数组类型&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 输出整个数组 &amp;#39;arr&amp;#39; 的大小，10 * sizeof(int)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="11结构体和类">1.1.结构体和类&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">MyStruct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">MyStruct&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 输出 &amp;#39;MyStruct&amp;#39; 的总大小 4 + 1 + （3）+8 =16
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="14引用类型">1.4.引用类型&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">ref&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ref&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 输出引用 &amp;#39;ref&amp;#39; 的大小，通常等于 int 的大小
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="15动态内存分配">1.5.动态内存分配&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">dynamicArray&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dynamicArray&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 输出指针的大小，不是数组的大小
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">delete&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="n">dynamicArray&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 记得释放内存
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="16sizeof-c11-可变参数模板">1.6.sizeof&amp;hellip; (C++11 可变参数模板)&lt;/h3>
&lt;p>C++11 引入了 &lt;code>sizeof...&lt;/code> 运算符，用于在模板中获取参数包中的参数数量。&lt;/p></description></item><item><title>C++ basic static</title><link>https://wesigj.github.io/p/c-basic-static/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-static/</guid><description>&lt;h1 id="c面试基础系列-static">C++面试基础系列-static&lt;/h1>
&lt;hr>
&lt;h2 id="1static含义">1.static含义&lt;/h2>
&lt;p>static关键字&lt;/p>
&lt;ul>
&lt;li>静态变量和静态类&lt;/li>
&lt;li>类中的静态成员&lt;/li>
&lt;/ul>
&lt;p>在C++中，static 关键字有多个用途，包括定义静态变量、静态成员函数、静态数据成员、静态常量成员以及在函数中定义静态局部变量。以下是对 static 在C++中的详细描述：&lt;/p>
&lt;h2 id="2普通静态变量">2.普通静态变量&lt;/h2>
&lt;h3 id="21静态全局变量">2.1.静态全局变量&lt;/h3>
&lt;p>当 static 用于全局变量时，它限制了变量的链接范围，使其只在定义它的文件内部可见，其他文件无法访问。&lt;/p>
&lt;h3 id="22静态局部变量">2.2.静态局部变量&lt;/h3>
&lt;p>在函数内部定义的 static 变量具有静态存储期。这意味着它们在程序的整个运行期间都存在，而不是仅在函数调用期间。每次函数调用时，static 局部变量都会保留上一次调用的值。&lt;/p>
&lt;h2 id="3类中静态变量">3.类中静态变量&lt;/h2>
&lt;h3 id="31静态成员变量">3.1.静态成员变量&lt;/h3>
&lt;p>类的静态成员变量属于类本身，而不是类的任何特定对象。它们在所有对象之间共享。静态成员变量在所有实例之前或之后初始化，在程序的整个生命周期内保持其值。&lt;/p>
&lt;h3 id="32静态常量成员">3.2.静态常量成员&lt;/h3>
&lt;p>静态常量成员是类的一个特殊成员，它不仅具有静态存储期，还具有 const 特性。它们在定义时必须被初始化，并且不能被修改。&lt;/p>
&lt;h3 id="33静态成员函数">3.3.静态成员函数&lt;/h3>
&lt;p>静态成员函数属于类本身，而不是类的任何对象。它们可以访问类的静态成员，但不能访问非静态成员，因为它们没有 this 指针。静态成员函数可以在没有创建类的对象的情况下被调用。&lt;/p>
&lt;h3 id="34静态类">3.4.静态类&lt;/h3>
&lt;p>从C++11开始，可以定义一个静态类，它只能包含静态成员，不能有构造函数、析构函数或基类。&lt;/p>
&lt;h3 id="35模板中的静态">3.5.模板中的静态&lt;/h3>
&lt;p>在类模板中，静态成员具有特殊的行为。每个实例化的模板类都有自己的静态成员，它们不是共享的。&lt;/p>
&lt;h3 id="36嵌套静态类">3.6.嵌套静态类&lt;/h3>
&lt;p>在C++中，可以在类中定义静态类（也称为嵌套类），这些类在定义它们的类的外部是不可访问的。&lt;/p>
&lt;ul>
&lt;li>初始化：&lt;/li>
&lt;/ul>
&lt;p>静态数据成员通常在类的定义外部进行初始化，而不是在类内部。&lt;/p>
&lt;ul>
&lt;li>作用域：&lt;/li>
&lt;/ul>
&lt;p>静态成员的作用域是整个程序，它们可以在类的任何对象上通过类名直接访问。&lt;/p>
&lt;ul>
&lt;li>内存分配：&lt;/li>
&lt;/ul>
&lt;p>静态成员变量和静态局部变量存储在静态存储区，而不是堆栈或堆上。
以下是一些示例来说明 static 的使用：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 静态全局变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">globalVar&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">42&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 只在定义它的文件内可见
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">function&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 静态局部变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">staticVar&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 函数调用间保留值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">staticVar&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 静态成员变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">staticMember&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 静态常量成员
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">static&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">staticConstMember&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 静态成员函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">staticMemberFunction&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">staticMember&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 可以访问静态成员变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 在类外初始化静态成员变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">MyClass&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">staticMember&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">functionWithStatic&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 使用静态成员
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">MyClass&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">staticMemberFunction&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">localStaticConst&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 局部静态常量，作用域限制在函数内
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;hr>
&lt;h2 id="关于作者">关于作者&lt;/h2>
&lt;ul>
&lt;li>微信公众号:WeSiGJ&lt;/li>
&lt;li>GitHub:&lt;a href="https://github.com/wesigj/cplusplusboys">https://github.com/wesigj/cplusplusboys&lt;/a>&lt;/li>
&lt;li>CSDN:&lt;a href="https://blog.csdn.net/wesigj">https://blog.csdn.net/wesigj&lt;/a>&lt;/li>
&lt;li>微博:&lt;/li>
&lt;li>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。&lt;/li>
&lt;/ul>
&lt;img src=https://wesigj.github.io/./img/wechat.jpg width=60% /></description></item><item><title>C++ basic struct</title><link>https://wesigj.github.io/p/c-basic-struct/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-struct/</guid><description>&lt;h1 id="c面试基础系列-struct">C++面试基础系列-struct&lt;/h1>
&lt;hr>
&lt;h2 id="1c中struct">1.C中struct&lt;/h2>
&lt;ul>
&lt;li>struct里面只能放数据类型（基本数据类型，自定义数据类型，指针等），不能放置函数&lt;/li>
&lt;li>C中不存在public、protected、private，&lt;/li>
&lt;li>C中，定义结构体变量，定义必须加struct。&lt;/li>
&lt;li>C不存在继承&lt;/li>
&lt;li>结构体与函数的名称可以相同&lt;/li>
&lt;/ul>
&lt;h2 id="2c中struct">2.C++中struct&lt;/h2>
&lt;p>C++中strcut基本和class一致&lt;/p>
&lt;ul>
&lt;li>C++中，struct默认是public，class默认是private&lt;/li>
&lt;li>C++中，存在public、protected、private&lt;/li>
&lt;li>C++中，使用时，可以不带strcut&lt;/li>
&lt;li>C++中，可以继承&lt;/li>
&lt;li>C++中，若结构体的名字与函数名相同，可以正常调用！但是定义结构体变量时候只能用带struct的！&lt;/li>
&lt;/ul>
&lt;h3 id="21同名函数">2.1.同名函数&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">A&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">A&lt;/span>&lt;span class="p">(){}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">A&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//ok
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">A&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//error
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="22typedef定义结构体别名">2.2.typedef定义结构体别名&lt;/h3>
&lt;p>A自带struct，不可以直接调用函数&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">a&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">A&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="23继承">2.3.继承&lt;/h3>
&lt;p>struct继承和class是一致&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="nc">Base&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">print&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;print&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">Derived&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Base&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">v2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">print&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Derived&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Derived&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Derived&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">b&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">print&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="3总结">3.总结&lt;/h2>
&lt;h3 id="31c和c中的struct区别">3.1.C和C++中的Struct区别&lt;/h3>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">C&lt;/th>
 &lt;th style="text-align: left">C++&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">不能将函数放在结构体声明&lt;/td>
 &lt;td style="text-align: left">能将函数放在结构体声明&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">在C结构体声明中不能使用C++访问修饰符。&lt;/td>
 &lt;td style="text-align: left">public、protected、private 在C++中可以使用。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">在C中定义结构体变量，如果使用了下面定义必须加struct。&lt;/td>
 &lt;td style="text-align: left">可以不加struct&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">结构体不能继承（没有这一概念）。&lt;/td>
 &lt;td style="text-align: left">可以继承&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">若结构体的名字与函数名相同，可以正常运行且正常的调用！&lt;/td>
 &lt;td style="text-align: left">若结构体的名字与函数名相同，使用结构体，只能使用带struct定义！&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>在C++中，struct和class都可以用来定义自定义数据类型，但它们之间存在一些关键的区别：&lt;/p></description></item><item><title>C++ basic this</title><link>https://wesigj.github.io/p/c-basic-this/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-this/</guid><description>&lt;h1 id="c面试基础系列-this指针">C++面试基础系列-this指针&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;h2 id="1this指针">1.this指针&lt;/h2>
&lt;p>在 C++ 中，&lt;code>this&lt;/code> 指针是一个特殊的指针，它在每个非静态成员函数中自动可用。&lt;code>this&lt;/code> 指向调用成员函数的当前对象实例。以下是 &lt;code>this&lt;/code> 指针的一些关键特性和用法：&lt;/p>
&lt;h3 id="11特性">1.1.特性&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>隐式存在&lt;/strong>：在成员函数中，&lt;code>this&lt;/code> 指针隐式地可用，不需要定义或声明。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>指向当前对象&lt;/strong>：&lt;code>this&lt;/code> 指针指向调用成员函数的对象。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>类型为当前类的指针&lt;/strong>：&lt;code>this&lt;/code> 的类型是成员函数所在类的指针类型。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>在静态成员函数中不可用&lt;/strong>：由于静态成员不属于任何对象实例，因此在静态成员函数中 &lt;code>this&lt;/code> 指针不可用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>用于区分成员变量和局部变量&lt;/strong>：当局部变量名与成员变量名相同时，&lt;code>this&lt;/code> 可以用来区分它们。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="12用法">1.2.用法&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>访问成员变量&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">setValue&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 使用 this 指针访问成员变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>调用其他成员函数&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">doSomething&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">execute&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">this&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">doSomething&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 使用 this 指针调用另一个成员函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>在构造函数中使用&lt;/strong>：&lt;/p></description></item><item><title>C++ basic union</title><link>https://wesigj.github.io/p/c-basic-union/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-union/</guid><description>&lt;h1 id="c面试基础系列-union">C++面试基础系列-union&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-union/#c面试基础系列-union">C++面试基础系列-union&lt;/a>
&lt;ul>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-union/#1union含义">1.union含义&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-union/#2union的关键点1">2.union的关键点1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-union/#3union的关键点2">3.union的关键点2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-union/#4union与struct的区别">4.union与struct的区别&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wesigj.github.io/p/c-basic-union/#关于作者">关于作者&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="1union含义">1.union含义&lt;/h2>
&lt;p>在C++中，union是一种特殊的数据类型，它允许在相同的内存位置存储不同的数据类型。union与struct类似，但它的所有成员都共享相同的内存地址。这意味着在任意时刻只能访问union中的一个成员，如果访问了一个新的成员，那么之前存储的值将被覆盖。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">union&lt;/span> &lt;span class="nc">UnionName&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">type1&lt;/span> &lt;span class="n">member1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">type2&lt;/span> &lt;span class="n">member2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">typeN&lt;/span> &lt;span class="n">memberN&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这里的type1到typeN是数据类型，member1到memberN是成员变量。&lt;/p>
&lt;p>使用union的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">union&lt;/span> &lt;span class="nc">Data&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Data&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 存储一个整数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Integer: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 存储一个字符，这将覆盖data.i的值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Character: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// data.i的值已经被覆盖，所以输出将不是10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Integer after storing character: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="2union的关键点1">2.union的关键点1&lt;/h2>
&lt;ul>
&lt;li>union的所有成员始于相同的内存地址。&lt;/li>
&lt;li>union的大小等于其最大成员的大小。在上面的例子中，Data的大小将等于一个double的大小，因为double通常比int和char占用更多的字节。&lt;/li>
&lt;li>union可用于内存对齐和打包，以及访问字节级数据。&lt;/li>
&lt;li>union不允许有引用类型的成员，也不能有继承或虚函数。&lt;/li>
&lt;li>union可以用于位域操作，尽管这通常不是推荐的做法。&lt;/li>
&lt;/ul>
&lt;h2 id="3union的关键点2">3.union的关键点2&lt;/h2>
&lt;p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：&lt;/p></description></item><item><title>C++ basic using</title><link>https://wesigj.github.io/p/c-basic-using/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-using/</guid><description>&lt;h1 id="c面试基础系列-using">C++面试基础系列-using&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;h2 id="1using关键字">1.using关键字&lt;/h2>
&lt;p>在 C++ 中，&lt;code>using&lt;/code> 关键字有几种不同的用法，主要用于别名声明、类型导入和命名空间的成员导入。以下是 &lt;code>using&lt;/code> 的几种常见用法：&lt;/p>
&lt;h3 id="11-别名声明type-alias">1.1. 别名声明（Type Alias）&lt;/h3>
&lt;p>使用 &lt;code>using&lt;/code> 为类型创建一个别名，简化复杂类型的书写。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">using&lt;/span> &lt;span class="n">int_ptr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">shared_ptr&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">int_ptr&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">make_shared&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 使用别名创建智能指针
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="12-模板别名">1.2. 模板别名&lt;/h3>
&lt;p>为模板类型创建一个别名，简化模板类型的书写。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">using&lt;/span> &lt;span class="n">IntVector&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">IntVector&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 使用别名创建向量
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="13-类别名">1.3. 类别名&lt;/h3>
&lt;p>为类或其指针、引用类型创建别名。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">using&lt;/span> &lt;span class="n">MyHandle&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">MyClass&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 创建类指针的别名
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">MyHandle&lt;/span> &lt;span class="n">h&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">MyClass&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="14-命名空间导入">1.4. 命名空间导入&lt;/h3>
&lt;p>使用 &lt;code>using&lt;/code> 从命名空间中导入特定的名称，避免重复前缀。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">namespace&lt;/span> &lt;span class="n">NS&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">using&lt;/span> &lt;span class="n">NS&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 导入函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 直接调用
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="15-命名空间别名">1.5. 命名空间别名&lt;/h3>
&lt;p>为命名空间创建别名，简化长命名空间的引用。&lt;/p></description></item><item><title>C++ basic volatile</title><link>https://wesigj.github.io/p/c-basic-volatile/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-volatile/</guid><description>&lt;h1 id="c面试基础系列-volatile">C++面试基础系列-volatile&lt;/h1>
&lt;h2 id="1volatile核心规则">1.volatile核心规则&lt;/h2>
&lt;ul>
&lt;li>volatile修饰变量或指针功能
&lt;ul>
&lt;li>告诉编译器，被volatile修饰的变量或指针（寄存器或硬件寄存器），不要进行优化&lt;/li>
&lt;li>变量或指针在中断服务子程序，用户函数中同时调用，不要进行优化&lt;/li>
&lt;li>多线程，多任务同时调用变量或指针，使用volatile修饰，表示每次操作该变量或指针，都要从内存中取最新的值进行操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>简单来说
&lt;ul>
&lt;li>编译器，不要优化&lt;/li>
&lt;li>从内存取值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2c与c中volatile区别">2.C与C++中volatile区别&lt;/h2>
&lt;ul>
&lt;li>在C和C++中，volatile关键字都用于告诉编译器一个变量可能会在程序的控制之外被改变，通常是由于硬件的作用。尽管C和C++都支持volatile，但它们在某些方面存在一些差异：&lt;/li>
&lt;/ul>
&lt;h3 id="21c语言中的volatile">2.1.C语言中的volatile&lt;/h3>
&lt;ul>
&lt;li>在C语言中，volatile主要用于多线程环境或中断服务例程（ISR）中，指示编译器该变量可能会在任何时候被改变，因此每次使用时都应该从内存中重新读取，而不是从寄存器中。&lt;/li>
&lt;li>C标准并没有详细说明volatile的所有行为，尤其是在多线程同步方面。&lt;/li>
&lt;/ul>
&lt;h3 id="22c中的volatile">2.2.C++中的volatile&lt;/h3>
&lt;ul>
&lt;li>C++中的volatile用法与C类似，但C++标准对volatile的行为有更明确的定义，特别是在多线程环境中。&lt;/li>
&lt;li>在C++11及以后的版本中，标准定义了内存模型，volatile变量的访问将遵循这些规则，以确保在多线程环境中对它们的访问是原子的（如果需要）。&lt;/li>
&lt;/ul>
&lt;h3 id="23原子性和顺序">2.3.原子性和顺序&lt;/h3>
&lt;ul>
&lt;li>在C++11中，volatile关键字不保证操作的原子性，即使在多线程环境中也是如此。如果需要原子性，C++提供了std::atomic模板和相关的原子操作函数。&lt;/li>
&lt;li>C++中的volatile也不保证编译器不会重排相关操作的顺序，这与C类似。&lt;/li>
&lt;/ul>
&lt;h3 id="24易失性">2.4.易失性&lt;/h3>
&lt;ul>
&lt;li>在C和C++中，volatile都可以用来指示编译器一个变量是易失性的，即它可能会因为外部硬件事件而改变。&lt;/li>
&lt;/ul>
&lt;h3 id="25优化">2.5.优化&lt;/h3>
&lt;ul>
&lt;li>由于volatile告诉编译器变量可能在任何时候改变，编译器将不会对这个变量进行优化。&lt;/li>
&lt;/ul>
&lt;h3 id="26使用场景">2.6.使用场景&lt;/h3>
&lt;ul>
&lt;li>在嵌入式编程中，volatile经常用于访问内存映射的硬件寄存器，因为这些寄存器可能会被外部硬件改变。&lt;/li>
&lt;/ul>
&lt;h3 id="27c特有的特性">2.7.C++特有的特性&lt;/h3>
&lt;ul>
&lt;li>C++中volatile的使用可能会受到C++特有的特性影响，如类和对象模型。例如，C++中的volatile成员变量需要特别注意，因为它们的行为可能不如预期。&lt;/li>
&lt;/ul>
&lt;h3 id="28c20引入的变化如果有">2.8.C++20引入的变化（如果有）&lt;/h3>
&lt;ul>
&lt;li>C++20标准可能会对volatile有进一步的说明或改进，但截至知识截止日期，这些变化尚未明确。&lt;/li>
&lt;/ul>
&lt;p>总结来说，C和C++中的volatile在基本用途上相似，但C++标准提供了更明确的定义，尤其是在多线程环境中。在C++中，如果需要原子性或线程安全的同步，应该使用std::atomic或其他同步机制，而不是仅仅依赖volatile。&lt;/p>
&lt;h2 id="3volatile常见面试问题">3.volatile常见面试问题&lt;/h2>
&lt;p>在面试中，&lt;code>volatile&lt;/code> 关键字是一个常见的话题，以下是一些可能会问到的问题以及相关的答案：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>&lt;code>volatile&lt;/code> 关键字是什么？&lt;/strong>
&lt;code>volatile&lt;/code> 是一种类型修饰符，用于告诉编译器该变量可能会在程序的控制之外被改变，例如由中断服务程序、多线程或硬件修改。使用 &lt;code>volatile&lt;/code> 可以防止编译器对这些变量进行优化，确保每次访问都直接从内存中读取或写入，从而保证数据的一致性。&lt;/li>
&lt;li>&lt;strong>&lt;code>volatile&lt;/code> 变量的可见性如何保证？&lt;/strong>
&lt;code>volatile&lt;/code> 变量保证了对所有线程的可见性。当一个线程修改了一个 &lt;code>volatile&lt;/code> 变量时，其他线程能够立即看到这个修改，这是因为 &lt;code>volatile&lt;/code> 变量的写操作会立即刷新到主内存中，而读操作会从主内存中读取最新值。&lt;/li>
&lt;li>&lt;strong>&lt;code>volatile&lt;/code> 能否保证原子性？&lt;/strong>
&lt;code>volatile&lt;/code> 关键字不能保证操作的原子性。它只能确保单次的读/写操作具有原子性，但对于复合操作，如自增（&lt;code>i++&lt;/code>），&lt;code>volatile&lt;/code> 无法保证整个操作的原子性。因此，对于需要原子性保证的操作，应该使用其他同步机制，如 &lt;code>synchronized&lt;/code> 或 &lt;code>AtomicInteger&lt;/code>。&lt;/li>
&lt;li>&lt;strong>&lt;code>volatile&lt;/code> 变量在多线程中的使用场景有哪些？&lt;/strong>
&lt;code>volatile&lt;/code> 变量适用于多线程环境下的某些特定场景，例如：
&lt;ul>
&lt;li>作为状态标志，用于控制线程间的协调，如退出循环的条件。&lt;/li>
&lt;li>在没有其他同步机制的情况下，用于保护简单的状态变量，以确保变量的可见性和有序性。&lt;/li>
&lt;li>与锁结合使用，实现读写锁模式，提高性能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&lt;code>volatile&lt;/code> 与 &lt;code>const&lt;/code> 的区别是什么？&lt;/strong>
&lt;code>const&lt;/code> 关键字用于定义常量，即值不能被修改的变量。而 &lt;code>volatile&lt;/code> 用于定义可能会在程序的控制之外被改变的变量。&lt;code>const&lt;/code> 保证的是值的不变性，而 &lt;code>volatile&lt;/code> 保证的是变量的可见性和禁止指令重排序。&lt;/li>
&lt;li>&lt;strong>&lt;code>volatile&lt;/code> 指针是什么？&lt;/strong>
&lt;code>volatile&lt;/code> 指针是指指向的变量可能会在程序的控制之外被改变的指针。它可以是指向 &lt;code>volatile&lt;/code> 变量的指针，也可以是指针本身的值是 &lt;code>volatile&lt;/code> 的。在使用 &lt;code>volatile&lt;/code> 指针时，编译器不会对通过该指针进行的操作进行优化。&lt;/li>
&lt;li>&lt;strong>在嵌入式系统中，&lt;code>volatile&lt;/code> 的作用是什么？&lt;/strong>
在嵌入式系统中，&lt;code>volatile&lt;/code> 通常用于声明与硬件寄存器相关的变量，以确保编译器不会对与硬件交互的代码进行优化。这是因为硬件寄存器的值可能会由硬件本身的操作所改变，需要每次访问时都从内存中读取最新值。&lt;/li>
&lt;li>&lt;strong>&lt;code>volatile&lt;/code> 能否替代 &lt;code>synchronized&lt;/code>？&lt;/strong>
&lt;code>volatile&lt;/code> 在某些情况下可以作为 &lt;code>synchronized&lt;/code> 的轻量级替代，特别是在读操作远多于写操作的场景下。但是，由于 &lt;code>volatile&lt;/code> 不能保证复合操作的原子性，它不能完全替代 &lt;code>synchronized&lt;/code>。在需要原子性保证的情况下，仍然需要使用 &lt;code>synchronized&lt;/code> 或其他同步机制。&lt;/li>
&lt;/ol>
&lt;p>理解 &lt;code>volatile&lt;/code> 的作用和限制对于编写正确的多线程程序至关重要。在面试中，展示对 &lt;code>volatile&lt;/code> 的深入理解可以体现候选人的专业知识和经验。&lt;/p></description></item><item><title>C++ basic 函数指针与指针函数</title><link>https://wesigj.github.io/p/c-basic-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/</guid><description>&lt;h1 id="c面试基础系列-函数指针与指针函数">C++面试基础系列-函数指针与指针函数&lt;/h1>
&lt;p>[toc]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;h2 id="1function_pointer函数指针">1.function_pointer函数指针&lt;/h2>
&lt;ul>
&lt;li>function_pointer函数指针也是一个指针，
&lt;ul>
&lt;li>只不过函数指针可以指向函数，可以通过该指针调用函数&lt;/li>
&lt;li>联想到重载，多态，模板，只不过函数指针需要重新调整指针指向的函数类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="2pointer_function指针函数">2.pointer_function指针函数&lt;/h2>
&lt;ul>
&lt;li>指针函数实际上只是函数返回值返回一个指针&lt;/li>
&lt;/ul>
&lt;h2 id="3面试中最喜欢的是函数指针和指针函数的区别">3.面试中，最喜欢的是函数指针和指针函数的区别&lt;/h2>
&lt;p>函数指针和指针函数是两个不同的概念，主要区别如下：&lt;/p>
&lt;h3 id="31定义">3.1.定义&lt;/h3>
&lt;ol>
&lt;li>指针函数：
&lt;ul>
&lt;li>本质是一个函数，其返回值是一个指针。&lt;/li>
&lt;li>例如：&lt;code>int* fun() { /* 函数体 */ }&lt;/code>，这里的函数 &lt;code>fun&lt;/code>就是一个指针函数，它返回一个指向整数的指针。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>函数指针：
&lt;ul>
&lt;li>是指向函数的指针变量。&lt;/li>
&lt;li>例如：&lt;code>int (*pf)();&lt;/code>，这里 &lt;code>pf&lt;/code>是一个函数指针，它指向一个返回值为整数的函数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="32用法">3.2.用法&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>指针函数的用法：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>先调用指针函数，得到一个指针结果，然后通过这个指针访问其所指向的内存空间中的数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例如：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>看出下面代码的错误了吗？&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">fun&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ptr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">fun&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="c1">//error
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>ERROR:a是一个局部变量，调用指向a的指针，会出现内存泄漏，应避免这种用法。&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>函数指针的用法：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>可以将函数指针作为参数传递给其他函数，实现回调函数的功能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">callback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">arg&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arg&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Result: %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">square&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">callback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">square&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="33存储方式">3.3.存储方式&lt;/h3>
&lt;ol>
&lt;li>指针函数：在内存中与普通函数一样，有特定的代码段存储函数体，执行时将在该代码段中运行。返回的指针则存储在相应的内存地址中。&lt;/li>
&lt;li>函数指针：本身作为一个变量存储在内存中，它的值是所指向函数的入口地址。&lt;/li>
&lt;/ol>
&lt;h2 id="4函数指针用法">4.函数指针用法&lt;/h2>
&lt;p>函数指针是C++中一种重要的特性，它允许将函数作为值来处理。以下是函数指针的一些常见用法：&lt;/p></description></item><item><title>C++ basic 指针和引用</title><link>https://wesigj.github.io/p/c-basic-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/</guid><description>&lt;h1 id="c面试基础系列-指针和引用">C++面试基础系列-指针和引用&lt;/h1>
&lt;p>[toc]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;h2 id="1指针和引用含义">1.指针和引用含义&lt;/h2>
&lt;p>在C++中，&amp;ldquo;pointer reference&amp;quot;这个术语可能引起一些混淆，因为&amp;quot;reference&amp;rdquo;（引用）和&amp;quot;pointer&amp;quot;（指针）是两种不同的概念，但它们可以一起使用。以下是对这两种概念的解释和它们如何一起使用的示例：&lt;/p>
&lt;h3 id="11指针pointer">1.1.指针（Pointer）&lt;/h3>
&lt;p>指针是一个变量，它存储了另一个变量的内存地址。指针允许你间接访问内存地址上存储的值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">pointer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// &amp;#39;pointer&amp;#39;是指向&amp;#39;value&amp;#39;的指针
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="12引用reference">1.2.引用（Reference）&lt;/h3>
&lt;p>引用是一个别名，为一个已存在的变量提供了另一个名字。一旦引用被初始化，它就不能重新绑定到另一个变量。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">reference&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// &amp;#39;reference&amp;#39;是&amp;#39;value&amp;#39;的引用
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="13指针和引用一起使用">1.3.指针和引用一起使用&lt;/h3>
&lt;p>你可以有一个指针到引用，这通常在函数参数中看到，以便传递一个对对象的引用而不是对象本身，同时还能保持指针的语义。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">increment&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">ref&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ref&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">increment&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 通过指针传递引用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>increment&lt;/code> 函数接受一个引用作为参数。在 &lt;code>process&lt;/code> 函数中，我们有一个指向 &lt;code>value&lt;/code> 的指针 &lt;code>ptr&lt;/code>。我们通过 &lt;code>*ptr&lt;/code>（解引用指针以获取它所指向的值）来调用 &lt;code>increment&lt;/code>，这样 &lt;code>increment&lt;/code> 就可以修改 &lt;code>value&lt;/code> 的原始值。&lt;/p>
&lt;h3 id="14指针引用pointer-to-reference">1.4.指针引用（Pointer to Reference）&lt;/h3>
&lt;p>虽然不常见，但你可以有一个指向引用的指针。这通常在复杂的数据结构或模板元编程中看到。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">ref&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span>&lt;span class="o">*&amp;amp;&lt;/span> &lt;span class="n">refRef&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ref&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// &amp;#39;refRef&amp;#39;是指向引用的引用，也指向&amp;#39;value&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>refRef&lt;/code> 是一个引用到引用的指针。它首先声明为 &lt;code>ref&lt;/code> 的引用，然后可以被当作一个指向 &lt;code>value&lt;/code> 的指针使用。&lt;/p></description></item><item><title>C++ basic 虚函数virtual</title><link>https://wesigj.github.io/p/c-basic-%E8%99%9A%E5%87%BD%E6%95%B0virtual/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-%E8%99%9A%E5%87%BD%E6%95%B0virtual/</guid><description>&lt;h1 id="c面试基础系列-c虚函数virtual">C++面试基础系列-C++虚函数virtual&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;h2 id="1virtual">1.virtual&lt;/h2>
&lt;p>在 C++ 中，&lt;code>virtual&lt;/code> 关键字用于实现多态性，它允许你定义虚函数。虚函数是一种成员函数，它可以在派生类中被重写（override），并且调用哪个函数版本是由对象的实际类型决定的，而不是由指针或引用的静态类型决定的。&lt;/p>
&lt;p>以下是 &lt;code>virtual&lt;/code> 关键字的一些关键点和示例：&lt;/p>
&lt;h3 id="11虚函数">1.1.虚函数&lt;/h3>
&lt;ul>
&lt;li>使用 &lt;code>virtual&lt;/code> 关键字定义的函数可以在派生类中被重写。&lt;/li>
&lt;li>调用虚函数时，将根据对象的实际类型调用相应的函数实现。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Base&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">show&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Base show&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="n">Base&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{}&lt;/span> &lt;span class="c1">// 虚析构函数确保派生类的析构函数被调用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Derived&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Base&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">show&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">override&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 使用 override 关键字明确重写意图
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Derived show&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="12抽象类">1.2.抽象类&lt;/h3>
&lt;ul>
&lt;li>如果类包含至少一个纯虚函数，它就成为了一个抽象类（abstract class），不能被实例化。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">AbstractBase&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">pureVirtualFunction&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 纯虚函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 其他成员函数...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="13虚析构函数">1.3.虚析构函数&lt;/h3>
&lt;ul>
&lt;li>定义虚析构函数以确保在删除通过基类指针删除派生类对象时，正确的析构函数被调用。&lt;/li>
&lt;/ul>
&lt;h3 id="14虚继承">1.4.虚继承&lt;/h3>
&lt;ul>
&lt;li>使用 &lt;code>virtual&lt;/code> 关键字进行虚继承可以解决菱形继承问题，避免重复继承同一基类。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Base1&lt;/span> &lt;span class="p">{};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Base2&lt;/span> &lt;span class="p">{};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Derived&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">virtual&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Base1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">virtual&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Base2&lt;/span> &lt;span class="p">{};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="15多态的使用">1.5.多态的使用&lt;/h3>
&lt;ul>
&lt;li>通过基类指针或引用调用虚函数，可以实现多态行为。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Base&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">basePtr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Derived&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">basePtr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">show&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 调用 Derived 类的 show 函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">delete&lt;/span> &lt;span class="n">basePtr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="16final-关键字">1.6.&lt;code>final&lt;/code> 关键字&lt;/h3>
&lt;ul>
&lt;li>使用 &lt;code>final&lt;/code> 关键字可以阻止进一步的重写。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">FinalClass&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Base&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">show&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">final&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;FinalClass show&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个例子中，&lt;code>FinalClass&lt;/code> 中的 &lt;code>show&lt;/code> 函数不能在任何派生类中被重写。&lt;/p></description></item><item><title>C++ basic 虚函数vptr_vtable</title><link>https://wesigj.github.io/p/c-basic-%E8%99%9A%E5%87%BD%E6%95%B0vptr_vtable/</link><pubDate>Sat, 07 Sep 2024 15:07:39 +0800</pubDate><guid>https://wesigj.github.io/p/c-basic-%E8%99%9A%E5%87%BD%E6%95%B0vptr_vtable/</guid><description>&lt;h1 id="c面试基础系列-c虚函数vptr_vtable">C++面试基础系列-C++虚函数vptr_vtable&lt;/h1>
&lt;p>[TOC]&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;h2 id="1简单介绍">1.简单介绍&lt;/h2>
&lt;p>在 C++ 中，虚函数的实现细节涉及到虚表指针（&lt;code>vptr&lt;/code>）和虚表（&lt;code>vtable&lt;/code>）。这些是编译器用来实现运行时多态性的机制。以下是关于 &lt;code>vptr&lt;/code> 和 &lt;code>vtable&lt;/code> 的一些关键点：&lt;/p>
&lt;h3 id="11vptr虚表指针">1.1.vptr（虚表指针）&lt;/h3>
&lt;ul>
&lt;li>&lt;code>vptr&lt;/code> 是一个指针，存储在对象的内存布局中，指向该对象的虚表。&lt;/li>
&lt;li>每个包含虚函数的类都有自己的虚表。&lt;/li>
&lt;li>&lt;code>vptr&lt;/code> 的位置和大小可能因编译器而异，但通常位于对象的内存布局的开始处。&lt;/li>
&lt;li>&lt;code>vptr&lt;/code> 的存在是透明的，程序员不需要（也不应该）直接操作它。&lt;/li>
&lt;/ul>
&lt;h3 id="12vtable虚表">1.2.vtable（虚表）&lt;/h3>
&lt;ul>
&lt;li>&lt;code>vtable&lt;/code> 是一个表格，包含了类中所有虚函数的地址。&lt;/li>
&lt;li>每个类都有自己的 &lt;code>vtable&lt;/code>，它包含了该类所有虚函数的指针。&lt;/li>
&lt;li>当你调用一个虚函数时，程序会查找对象的 &lt;code>vptr&lt;/code> 指向的 &lt;code>vtable&lt;/code>，然后在表中查找正确的函数地址来执行。&lt;/li>
&lt;/ul>
&lt;h3 id="13工作原理">1.3.工作原理&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>构造对象&lt;/strong>：当创建一个对象时，编译器会在对象的内存中安排 &lt;code>vptr&lt;/code> 和类的成员变量。&lt;/li>
&lt;li>&lt;strong>调用虚函数&lt;/strong>：当通过对象调用虚函数时，程序会先访问对象的 &lt;code>vptr&lt;/code>，然后查找 &lt;code>vtable&lt;/code> 中对应的函数地址。&lt;/li>
&lt;li>&lt;strong>多态性&lt;/strong>：如果对象是派生类实例，但通过基类指针或引用调用，&lt;code>vtable&lt;/code> 会确保调用正确的函数实现，即使基类指针或引用的静态类型不知道实际对象的动态类型。&lt;/li>
&lt;/ol>
&lt;h3 id="14示例">1.4.示例&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Base&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Base::func&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="o">~&lt;/span>&lt;span class="n">Base&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Derived&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">Base&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">override&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;Derived::func&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Base&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">basePtr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Derived&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">basePtr&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 调用 Derived::func，展示了多态性
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">delete&lt;/span> &lt;span class="n">basePtr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个示例中，&lt;code>Base&lt;/code> 类和 &lt;code>Derived&lt;/code> 类都有自己的 &lt;code>vtable&lt;/code>。&lt;code>Derived&lt;/code> 类的 &lt;code>vtable&lt;/code> 覆盖了 &lt;code>Base&lt;/code> 类的 &lt;code>vtable&lt;/code> 中的 &lt;code>func&lt;/code> 条目。当通过 &lt;code>Base&lt;/code> 类型的指针调用 &lt;code>func&lt;/code> 时，实际调用的是 &lt;code>Derived&lt;/code> 类的 &lt;code>func&lt;/code> 函数。&lt;/p></description></item></channel></rss>