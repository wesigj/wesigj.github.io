[{"content":"Welcome to Hugo theme Stack. This is my first post.\n","date":"2024-09-07T00:00:00Z","image":"https://wesigj.github.io/p/hello-world/cover_hu6307248181568134095.jpg","permalink":"https://wesigj.github.io/p/hello-world/","title":"Hello World"},{"content":" 1.const含义 const表示常类型，其值不可更改。\n2.const作用 修饰常量 1 const int a = 66; 类型检查 const具有类型，并支持所有类型 const修饰，名为常量，具备不可更改属性 防更改，保护作用，增加程序健壮性 节省空间，内存 从汇编上看，const实质是使用内存地址访问，#define是立即数 const常量存储在内存中，只有一个内存地址，#define是预编译时，拷贝到代码中，不占用内存空间（RAM），占用ROM。 3.const作用域 const 常量具有块作用域（如果定义在函数或代码块内部）或文件作用域（如果定义在所有函数外部），遵循C语言的普通作用域规则。 #define 定义的宏在预处理阶段展开，没有作用域的概念，除非使用 #undef 取消定义。 4.修饰常量 1 2 const int a =66; a = 0; //ERROR can not change const constant 5.const与指针 1 2 3 4 const int *p; //指向const常类型的普通指针 int const *p; //同上 int * const p;//指向int类型的常指针 const int *const p;//指向const常类型的常指针 有趣的解析方法\n1 2 3 4 const char * p; //p is a pointer to const char char const * p; //同上 char * const p; //p is a const pointer to char const char * const p; //p is a const pointer to const char 5.1.指向常量的指针 指向常量的指针，其中常量不可修改 1 2 const int *p; # *p=10; //error 不能修改常量 1 2 3 const int a=10; const int *p = \u0026amp;a; // int *p = \u0026amp;a; //error 常量必须用常指针指向 允许把非const对象的地址赋给指向const对象的指针 1 2 int a=10; const int *p = \u0026amp;a; 1 2 3 const int *p; int a=10; p= \u0026amp;a; 5.2.常指针 const指针定义时，必须初始化，const指针不可变，但指向的值可变。\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;iostream\u0026gt; int main(){ int a =66; int b =88; int * const p = \u0026amp;a; // p = \u0026amp;b; //error std::cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;std::endl; a=100; std::cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;std::endl; } const指针不能指向常量\n1 2 3 4 5 6 7 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ const int a=0; //\u0026#34;const int *\u0026#34; 类型的值不能用于初始化 \u0026#34;int *const\u0026#34; 类型的实体 // int * const p=\u0026amp;a; // error! can not const int* -\u0026gt; int*const } 5.3.指向常量的常指针 1 2 const int a = 10; const int * const p = \u0026amp;a; 6.const与函数 const修饰函数返回值 const int fun(); 函数返回const常量，但是函数返回后通常会拷贝。\nconst int *fun(); 函数返回指向常量的指针，指针指向的内容不能更改。\nint *const fun(); 指针不能更改。\nconst修饰函数参数 函数参数或函数参数指针在函数内不能更改 1 2 3 void fun1(const int a);//参数不可变 void fun2(int *const a);//指针不能变 void fun(char *dest, const char *src);//防止常类型src被更改 主要功能： 保护参数和指针不被更改。 保护常类型不被更改。\nCPP中引用，增加效率，防止更改 1 void fun(const T \u0026amp;a);//T为模板，任意类型 cpp，增加了引用(reference)：\nC语言本身没有引用（reference）的概念，引用是C++等其他编程语言中的一个特性。在C语言中，参数传递通常通过值传递（pass by value）或指针传递（pass by pointer）实现。 如果T为基础类型，理论来说，基础数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。\n面试问题：\n如果函数需要传入一个指针，是否需要为该指针加上const，把const加在指针不同的位置有什么区别? 如果写的函数需要传入的参数是一个复杂类型的实例，传入值参数或者引用参数有什么区别，什么时候需要为传入的引用参数加上const? 7.const与类 在类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改 数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。 例如： 1 2 3 4 5 6 7 8 9 10 class MyClass { public: void normalFunction() { // 可以修改成员变量 } void constantFunction() const { // 不能修改任何成员变量，除非它们被声明为 mutable } }; 在这个示例中，normalFunction 是一个非常成员函数，可以修改对象的状态；而 constantFunction 是一个常成员函数，承诺不修改对象的状态，并且可以被用于操作常量对象。\n使用const关键字进行修饰的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字进行说明的成员函数不能用来操作常对象。 const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数. 简单来说\n常对象才能调用常函数和常量，不可调用非常函数或变量。 常函数不能调用，修改任何成员函数，成员变量，除非它们被声明为 mutable 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; class MyClass { private: int value; public: // 构造函数 MyClass(int val) : value(val) {} // 非const成员函数，可以修改成员变量 void modifyValue(int newValue) { value = newValue; std::cout \u0026lt;\u0026lt; \u0026#34;Value modified to: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } // const成员函数，不能修改成员变量，但可以读取 void displayValue() const { std::cout \u0026lt;\u0026lt; \u0026#34;Current value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } }; int main() { const MyClass constObject(10); // 创建一个const对象 // 下面的调用是允许的，因为displayValue()是一个const成员函数 constObject.displayValue(); // 下面的调用将导致编译错误，因为modifyValue()不是一个const成员函数 // constObject.modifyValue(20); // 错误：不能在const对象上调用non-const成员函数 // 创建一个非const对象 MyClass nonConstObject(20); // 可以调用非const成员函数来修改非const对象的状态 nonConstObject.modifyValue(30); // 正确调用 // 也可以调用const成员函数来读取非const对象的状态 nonConstObject.displayValue(); // 正确调用 return 0; } 从中可以看出，const对象只能调用const函数和const常量，\n于类中的const成员变量必须通过初始化列表进行初始化，如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 class Apple{ private: int people[100]; public: Apple(int i); const int apple_number; }; Apple::Apple(int i):apple_number(i) { } 8.const与static 8.1.将常量定义与static结合 1 static const int apple_number 8.2.在类外面初始化 1 const int Apple::apple_number=10; 使用c++11进行编译，可以在定义出初始化：\n1 2 3 static const int apple_number=10; // 或者 const int apple_number=10; 这两种都在c++11中支持！\n编译的时候加上-std=c++11即可！\n在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。\n在类中声明：\n1 static int ap; 在类实现文件中使用：\n1 int Apple::ap=666 对于此项，c++11不能进行声明并初始化，也就是上述使用方法。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-const/","title":"C++ basic const"}]