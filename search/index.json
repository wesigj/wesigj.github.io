[{"content":"C++ Practical-2 day13 输出格式 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.输出格式 在 C++ 中，输出格式通常由 iostream 库中的流操作符（\u0026lt;\u0026lt;）控制。你可以使用这些操作符来格式化输出到标准输出（std::cout）或其他输出流。以下是一些常见的输出格式示例：\n1.1.基础输出 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; int main() { int num = 10; double pi = 3.14159; std::string str = \u0026#34;Hello, World!\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Numbers: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Pi: \u0026#34; \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;String: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; return 0; } 1.2.宽度和精度 你可以设置流的宽度和精度来控制输出格式。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; int main() { double price = 19.99; std::cout \u0026lt;\u0026lt; \u0026#34;Default output: \u0026#34; \u0026lt;\u0026lt; price \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Formatted output: \u0026#34; \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2) \u0026lt;\u0026lt; price \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Right-justified: \u0026#34; \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; \u0026#34;Right\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 1.3.十六进制和科学计数法 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; int main() { int hexValue = 255; double scientificValue = 1234.56; std::cout \u0026lt;\u0026lt; \u0026#34;Hexadecimal: \u0026#34; \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; hexValue \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Scientific notation: \u0026#34; \u0026lt;\u0026lt; std::scientific \u0026lt;\u0026lt; scientificValue \u0026lt;\u0026lt; std::endl; return 0; } 1.4.布尔值 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; int main() { bool isTrue = true; bool isFalse = false; std::cout \u0026lt;\u0026lt; \u0026#34;Boolean true: \u0026#34; \u0026lt;\u0026lt; isTrue \u0026lt;\u0026lt; std::endl; // 输出 1 std::cout \u0026lt;\u0026lt; \u0026#34;Boolean false: \u0026#34; \u0026lt;\u0026lt; isFalse \u0026lt;\u0026lt; std::endl; // 输出 0 return 0; } 1.5.宽字符和字符串 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { wchar_t wideChar = L\u0026#39;A\u0026#39;; std::wstring wstr = L\u0026#34;Wide String\u0026#34;; std::wcout \u0026lt;\u0026lt; \u0026#34;Wide character: \u0026#34; \u0026lt;\u0026lt; wideChar \u0026lt;\u0026lt; std::endl; std::wcout \u0026lt;\u0026lt; \u0026#34;Wide string: \u0026#34; \u0026lt;\u0026lt; wstr \u0026lt;\u0026lt; std::endl; return 0; } 1.6.格式化输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; int main() { int year = 2024; double temperature = 23.6; std::string location = \u0026#34;Shanghai\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;It is \u0026#34; \u0026lt;\u0026lt; temperature \u0026lt;\u0026lt; \u0026#34; degrees in \u0026#34; \u0026lt;\u0026lt; location \u0026lt;\u0026lt; \u0026#34; this year \u0026#34; \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; std::endl; // 使用 setw 和 setfill 进行格式化 std::cout \u0026lt;\u0026lt; std::setw(5) \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; year \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2) \u0026lt;\u0026lt; temperature \u0026lt;\u0026lt; std::endl; return 0; } 1.6.错误处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;stdexcept\u0026gt; int main() { std::ofstream outFile(\u0026#34;example.txt\u0026#34;); if (!outFile) { throw std::runtime_error(\u0026#34;Unable to open file for writing.\u0026#34;); } outFile \u0026lt;\u0026lt; \u0026#34;Hello, File!\u0026#34; \u0026lt;\u0026lt; std::endl; if (outFile.fail()) { throw std::runtime_error(\u0026#34;Failed to write to file.\u0026#34;); } outFile.close(); return 0; } 在这些示例中，我们使用了 std::cout、std::wcout、std::fixed、std::setprecision、std::setw、std::setfill 和 std::hex 等来控制输出格式。通过这些操作符和控制符，你可以创建清晰、一致的输出格式。\n2.在输出中包含货币符号，比如美元符号，我应该如何设置 C++ 的输出格式？ 在 C++ 中，如果你想在输出中包含货币符号，比如美元符号，你可以使用 std::locale 和 std::cout 的格式化功能。std::locale 允许你设置地区特定的格式化，包括货币符号。\n以下是一个示例，展示了如何设置输出格式以包含美元符号：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;locale\u0026gt; int main() { // 设置地区为美国，这通常会使用美元符号 std::locale::global(std::locale(\u0026#34;en_US.UTF-8\u0026#34;)); double amount = 1234.56; // 使用 std::cout 输出货币格式 std::cout \u0026lt;\u0026lt; std::showbase \u0026lt;\u0026lt; \u0026#34;Amount: $\u0026#34; \u0026lt;\u0026lt; amount \u0026lt;\u0026lt; std::endl; // 如果你想要更精确地控制货币的显示格式，可以使用 std::moneypunct std::cout \u0026lt;\u0026lt; \u0026#34;Amount with currency symbol: \u0026#34; \u0026lt;\u0026lt; std::moneypunct\u0026lt;std::string::value_type,false\u0026gt;::char_type(\u0026#39;¤\u0026#39;) \u0026lt;\u0026lt; amount \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，我们首先使用 std::locale::global 设置了程序的全局区域设置为美国（en_US.UTF-8），这通常会使用美元符号。然后，我们使用 std::showbase 来指示输出货币符号。\n注意，std::moneypunct 是一个facet，它定义了货币的格式化方式。在这个例子中，我们直接使用了美元符号，但你可以通过 std::moneypunct 来获取当前区域设置的货币符号。\n请确保你的系统支持 en_US.UTF-8 区域设置，否则你可能需要调整为适合你系统的区域设置。\n如果你想要更精细的控制，你可以进一步探索 std::moneypunct 和 std::numpunct 来自定义数字和货币的格式化。\n此外，如果你的系统支持 C++20 或更高版本，你可以使用 std::format 来更灵活地格式化输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;format\u0026gt; #include \u0026lt;locale\u0026gt; int main() { std::locale::global(std::locale(\u0026#34;en_US.UTF-8\u0026#34;)); double amount = 1234.56; // 使用 std::format 输出货币格式 // 头文件添加 #include \u0026lt;format\u0026gt; // 编译选项添加：-std=C++20 std::cout \u0026lt;\u0026lt; std::format(\u0026#34;{:$L}\u0026#34;, amount) \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，{:$L} 是一个格式说明符，$ 表示货币符号，L 表示当前区域设置的货币单位。\n请记住，区域设置的支持取决于你的平台和编译器，你可能需要在你的系统上进行适当的配置才能使用这些功能。\n3.在 C++ 中，除了使用 std::locale 和 std::cout，还有其他方法可以设置货币符号吗？ 在 C++ 中，除了使用 std::locale 和 std::cout 来设置货币符号，还有其他一些方法可以在输出中包含货币符号：\n字符串拼接： 直接将货币符号作为字符串拼接到数字前。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { double amount = 1234.56; std::string currencySymbol = \u0026#34;$\u0026#34;; std::cout \u0026lt;\u0026lt; currencySymbol \u0026lt;\u0026lt; amount \u0026lt;\u0026lt; std::endl; return 0; } 使用 std::format（C++20）： 如果你使用的是支持 C++20 的编译器，std::format 提供了一种灵活的方式来格式化字符串。\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;format\u0026gt; int main() { double amount = 1234.56; std::cout \u0026lt;\u0026lt; std::format(\u0026#34;${:.2f}\u0026#34;, amount) \u0026lt;\u0026lt; std::endl; return 0; } 使用 iomanip 库： iomanip 库提供了一些操作符，如 setprecision 和 fixed，来控制浮点数的输出格式，但不直接支持货币符号。你可以结合字符串拼接使用。\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; int main() { double amount = 1234.56; std::cout \u0026lt;\u0026lt; \u0026#34;$\u0026#34; \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2) \u0026lt;\u0026lt; amount \u0026lt;\u0026lt; std::endl; return 0; } 使用 sprintf 或 snprintf（C 风格的函数）： 这些函数允许你在 C++ 程序中使用 C 语言风格的格式化。\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; int main() { double amount = 1234.56; char buffer[50]; sprintf(buffer, \u0026#34;$%.2f\u0026#34;, amount); std::cout \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; std::endl; return 0; } 使用 std::ostringstream： std::ostringstream 是一个字符串流，可以用来构建复杂的字符串。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;iomanip\u0026gt; int main() { double amount = 1234.56; std::ostringstream ss; ss \u0026lt;\u0026lt; \u0026#34;$\u0026#34; \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2) \u0026lt;\u0026lt; amount; std::cout \u0026lt;\u0026lt; ss.str() \u0026lt;\u0026lt; std::endl; return 0; } 使用第三方库： 一些第三方库，如 Boost.Format，提供了更多的格式化选项。\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;boost/format.hpp\u0026gt; int main() { double amount = 1234.56; std::cout \u0026lt;\u0026lt; (boost::format(\u0026#34;$%.2f\u0026#34;) % amount).str() \u0026lt;\u0026lt; std::endl; return 0; } 自定义函数： 你可以编写自己的函数来格式化货币字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; std::string formatCurrency(double amount) { return std::to_string(amount) + \u0026#34;$\u0026#34;; } int main() { double amount = 1234.56; std::cout \u0026lt;\u0026lt; formatCurrency(amount) \u0026lt;\u0026lt; std::endl; return 0; } 这些方法提供了不同的方式来在 C++ 中设置货币符号。你可以选择最适合你需求的方法。\n4.C++ 中的 std::format 是如何工作的，它有哪些优势？ 在 C++20 中，std::format 是一种新的字符串格式化功能，它提供了一种类型安全且易于阅读的方式来格式化字符串。它类似于 Python 中的 str.format() 方法，并且相比于传统的 printf 函数，std::format 在编译时就能检查格式字符串的正确性，从而提高了代码的安全性和可读性。\n4.1.如何工作 std::format 通过一个格式化字符串和一个参数列表来工作。格式化字符串包含了用于替换的占位符，这些占位符被花括号 {} 包围。在花括号内部，你可以指定参数的索引（从 0 开始）以及格式规范，例如：\n{}：默认格式 {:.2f}：浮点数，保留两位小数 {:#x}：十六进制整数，包含 0x 前缀 {:\u0026lt;10}：左对齐，宽度为 10 {:\u0026gt;10}：右对齐，宽度为 10 {:^10}：居中对齐，宽度为 10 4.2.优势 类型安全：在编译时检查格式字符串和参数类型，减少运行时错误的风险。 直观的语法：格式化语法直观易懂，类似于字符串插值。 灵活的格式化选项：支持宽度、精度、填充字符、对齐方式等格式化选项。 内置类型支持：直接支持多种内置类型，无需手动指定格式说明符。 可扩展性：可以通过特化 std::formatter 来支持自定义类型的格式化。 4.3.示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;format\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { int num = 42; double pi = 3.141592653589793; std::string str = \u0026#34;Hello, World!\u0026#34;; // 使用 std::format 进行格式化 std::string message = std::format(\u0026#34;The number is {}, and pi is {:.2f}.\u0026#34;, num, pi); std::cout \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; // 动态生成格式字符串 int width = 10; char fill = \u0026#39;*\u0026#39;; std::string dynamic_format = std::format(\u0026#34;{:\u0026gt;{}}\u0026#34;, str, width, fill); std::cout \u0026lt;\u0026lt; dynamic_format \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，我们首先使用 std::format 来格式化一个包含整数和浮点数的字符串。然后，我们展示了如何动态生成格式字符串，包括指定宽度和填充字符。\nstd::format 是 C++20 引入的一项新特性，它提供了一种现代且强大的字符串格式化工具，可以简化代码并提高其可读性和安全性。\n5.C++ 中的 std::format 与 Python 的 str.format() 方法在性能上有什么差异？ std::format 是 C++20 引入的一个新特性，它提供了一种类型安全且易于阅读的方式来格式化字符串。它与 Python 的 str.format() 方法相似，但有一些关键的差异。\n5.1.性能差异 在性能方面，std::format 通常比 Python 的 str.format() 更快，因为它是在 C++20 标准中设计时就考虑了性能的。std::format 利用了 C++ 的类型系统和编译时特性，可以生成高效的代码。相比之下，Python 的 str.format() 方法在运行时解析和处理格式字符串，这可能会引入一些额外的性能开销。\n5.2.优势 std::format 的一些主要优势包括：\n类型安全：在编译时检查格式字符串和参数类型，减少运行时错误的风险。 直观的语法：格式化语法直观易懂，类似于字符串插值。 灵活的格式化选项：支持宽度、精度、填充字符、对齐方式等格式化选项。 内置类型支持：直接支持多种内置类型，无需手动指定格式说明符。 可扩展性：可以通过特化 std::formatter 来支持自定义类型的格式化。 5.3.示例 以下是使用 std::format 的一个简单示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;format\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { int num = 42; double pi = 3.141592653589793; std::string str = \u0026#34;Hello, World!\u0026#34;; // 使用 std::format 进行格式化 std::string message = std::format(\u0026#34;The number is {}, and pi is {:.2f}.\u0026#34;, num, pi); std::cout \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; // 动态生成格式字符串 int width = 10; char fill = \u0026#39;*\u0026#39;; std::string dynamic_format = std::format(\u0026#34;{:\u0026gt;{}}\\n\u0026#34;, str, width, fill); std::cout \u0026lt;\u0026lt; dynamic_format \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，我们首先使用 std::format 来格式化一个包含整数和浮点数的字符串。然后，我们展示了如何动态生成格式字符串，包括指定宽度和填充字符。\n5.4.性能注意事项 尽管 std::format 提供了现代的格式化功能，但在性能敏感的应用中，你可能需要考虑以下几点：\n避免频繁的格式化操作：频繁创建和销毁格式化字符串可能会导致性能损失。 使用预分配的内存：对于频繁使用的字符串，预先分配足够的内存可以减少内存分配的开销。 选择正确的格式化方法：在某些情况下，使用 C 风格的 printf 可能更高效，尤其是在处理简单格式化时。 总的来说，std::format 是 C++20 中一个强大且灵活的字符串格式化工具，它在许多方面都优于传统的格式化方法。然而，在性能敏感的场景中，仍然需要仔细考虑格式化操作的影响。\n6.C++ 中的 std::format 支持哪些类型的格式化选项？ 在 C++20 中，std::format 支持多种类型的格式化选项，包括但不限于以下几种：\n整数：\n十进制：{:d} 或 {} 十六进制：{:x}（小写）或 {:X}（大写） 八进制：{:o} 二进制：{:b} 带前缀的十六进制：{:#x} 或 {:#X} 带前缀的八进制：{:#o} 带前缀的二进制：{:#b} 浮点数：\n定点表示法：{:f} 科学计数法：{:e}（小写）或 {:E}（大写） 通用格式：{:g}（小写）或 {:G}（大写） 百分比：{:%} 字符串：\n字符串：{:s} 宽度和填充：{:\u0026lt;10}（左对齐），{:\u0026gt;10}（右对齐），{:^10}（居中对齐） 填充字符：{:*^10}（使用 * 作为填充字符） 字符：\n字符：{:c} 指针：\n指针：{:p}（打印指针地址） 布尔值：\n布尔值：{:b} chrono 类型：\n时间点和持续时间：{:%Y-%m-%d %H:%M:%S}（日期和时间） 自定义类型：\n通过特化 std::formatter 可以支持自定义类型的格式化。 6.1.格式化选项的组合 除了基本的类型格式化选项，std::format 还支持组合使用多种格式化选项，例如：\n宽度：{:10}（设置宽度为10） 精度：{:.2f}（浮点数保留两位小数） 填充字符：{:_^10}（使用 _ 作为填充字符，居中对齐） 对齐： 左对齐：{:\u0026lt;10} 右对齐：{:\u0026gt;10} 居中对齐：{:^10} 6.2.示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;format\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;chrono\u0026gt; int main() { int number = 42; double pi = 3.141592653589793; std::string text = \u0026#34;Hello, World!\u0026#34;; bool flag = true; std::chrono::seconds duration(5); std::string formatted_text = std::format(\u0026#34;{}, {:.2f}, {}, {:b}, {:p}, {:%S}\u0026#34;, number, pi, text, flag, \u0026amp;number, duration); std::cout \u0026lt;\u0026lt; formatted_text \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，我们使用了不同类型的格式化选项来格式化整数、浮点数、字符串、布尔值、指针和 chrono 类型。\nstd::format 的灵活性和强大的格式化选项使其成为 C++20 中一个非常有用的工具。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:06:01+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day13-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/","title":"C++ Practical-2 day13 输出格式"},{"content":"C++ Practical-2 day12 读写文件综合题 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.读写文件综合题 在 C++ 中，读写文件是一个常见的任务。我们可以使用标准的文件流（std::ifstream 用于读取，std::ofstream 用于写入）来处理文件操作。以下是一个综合示例，展示了如何在 C++ 中创建一个文件，写入一些内容，然后读取并显示这些内容。\n1.1.写入文件 首先，我们将创建一个函数来写入文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; void writeToFile(const std::string\u0026amp; filename, const std::string\u0026amp; content) { std::ofstream outFile(filename); // 创建一个 ofstream 对象并打开文件 if (!outFile) { std::cerr \u0026lt;\u0026lt; \u0026#34;Unable to create file \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; std::endl; return; } outFile \u0026lt;\u0026lt; content; // 写入内容到文件 outFile.close(); // 关闭文件 } 1.2.读取文件 接下来，我们将创建一个函数来读取文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void readFromFile(const std::string\u0026amp; filename) { std::ifstream inFile(filename); // 创建一个 ifstream 对象并打开文件 if (!inFile) { std::cerr \u0026lt;\u0026lt; \u0026#34;Unable to open file \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; std::endl; return; } std::string line; while (std::getline(inFile, line)) { // 逐行读取文件内容 std::cout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; std::endl; } inFile.close(); // 关闭文件 } 1.3.主函数 最后，我们在 main 函数中使用这些函数：\n1 2 3 4 5 6 7 8 9 10 11 12 int main() { std::string filename = \u0026#34;example.txt\u0026#34;; std::string content = \u0026#34;Hello, World!\\nThis is a test file.\\n\u0026#34;; // 写入文件 writeToFile(filename, content); // 读取文件 readFromFile(filename); return 0; } 1.4.完整代码 将以上代码片段组合在一起，我们得到一个完整的程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; void writeToFile(const std::string\u0026amp; filename, const std::string\u0026amp; content) { std::ofstream outFile(filename); if (!outFile) { std::cerr \u0026lt;\u0026lt; \u0026#34;Unable to create file \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; std::endl; return; } outFile \u0026lt;\u0026lt; content; outFile.close(); } void readFromFile(const std::string\u0026amp; filename) { std::ifstream inFile(filename); if (!inFile) { std::cerr \u0026lt;\u0026lt; \u0026#34;Unable to open file \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; std::endl; return; } std::string line; while (std::getline(inFile, line)) { std::cout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; std::endl; } inFile.close(); } int main() { std::string filename = \u0026#34;example.txt\u0026#34;; std::string content = \u0026#34;Hello, World!\\nThis is a test file.\\n\u0026#34;; writeToFile(filename, content); readFromFile(filename); return 0; } 这个程序首先创建一个名为 example.txt 的文件，并向其中写入一些文本内容。然后，程序读取该文件的内容，并将其输出到控制台。这是一个简单的文件读写示例，展示了 C++ 中基本的文件操作。\n2.如何使用 C++ 进行更复杂的文件读写，比如追加内容或者以二进制模式读写？ 在 C++ 中，进行更复杂的文件读写操作可以通过指定文件打开模式来实现。以下是一些常见的文件操作模式：\n2.1.追加模式 在追加模式下打开文件，所有写入操作都会从文件末尾开始追加内容。在 std::ofstream 中，可以使用 std::ios::app 模式来追加内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; void appendToFile(const std::string \u0026amp;filename, const std::string \u0026amp;content) { std::ofstream outFile(filename, std::ios::app); // 以追加模式打开文件 if (!outFile) { std::cerr \u0026lt;\u0026lt; \u0026#34;Unable to open file \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; std::endl; return; } outFile \u0026lt;\u0026lt; content; // 追加内容到文件 outFile.close(); // 关闭文件 } 2.2.二进制读写模式 在二进制模式下读写文件，可以使用 std::ios::binary 模式。这在处理非文本文件（如图片、音频、视频等）时非常有用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;fstream\u0026gt; #include \u0026lt;vector\u0026gt; void writeBinaryFile(const std::string\u0026amp; filename, const std::vector\u0026lt;char\u0026gt;\u0026amp; data) { std::ofstream outFile(filename, std::ios::binary); // 以二进制模式打开文件 if (!outFile) { std::cerr \u0026lt;\u0026lt; \u0026#34;Unable to create binary file \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; std::endl; return; } outFile.write(data.data(), data.size()); // 写入二进制数据 outFile.close(); // 关闭文件 } void readBinaryFile(const std::string\u0026amp; filename, std::vector\u0026lt;char\u0026gt;\u0026amp; buffer) { std::ifstream inFile(filename, std::ios::binary); // 以二进制模式打开文件 if (!inFile) { std::cerr \u0026lt;\u0026lt; \u0026#34;Unable to open binary file \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; std::endl; return; } inFile.seekg(0, std::ios::end); // 移动到文件末尾 size_t fileSize = inFile.tellg(); // 获取文件大小 inFile.seekg(0, std::ios::beg); // 回到文件开头 buffer.resize(fileSize); // 调整缓冲区大小 inFile.read(buffer.data(), fileSize); // 读取文件内容到缓冲区 inFile.close(); // 关闭文件 } 2.3.主函数 在 main 函数中，我们可以调用这些函数来执行追加和二进制读写操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int main() { std::string filename = \u0026#34;example.txt\u0026#34;; std::string textContent = \u0026#34;This is additional text.\\n\u0026#34;; // 追加文本内容 appendToFile(filename, textContent); // 二进制写入 std::vector\u0026lt;char\u0026gt; binaryData = { 0x00, 0x01, 0x02, 0x03, 0x04 }; writeBinaryFile(\u0026#34;binaryData.bin\u0026#34;, binaryData); // 二进制读取 std::vector\u0026lt;char\u0026gt; readData; readBinaryFile(\u0026#34;binaryData.bin\u0026#34;, readData); // 显示读取的二进制数据 for (char c : readData) { std::cout \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; (int)c \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 2.4.注意事项 在写入二进制文件时，确保数据是正确的二进制格式。 在读取二进制文件时，确保缓冲区足够大，以存储整个文件的内容。 使用二进制模式时，文件的读写不会受到换行符的影响，这与文本模式不同。 这些示例展示了如何在 C++ 中执行更复杂的文件操作，包括追加内容和以二进制模式读写文件。\n3.在C++中，除了使用文件流，还有哪些方法可以进行文件操作？ 在 C++ 中，除了使用文件流（如 std::ifstream 和 std::ofstream），还有一些其他方法可以进行文件操作：\nC 风格的文件操作： 使用 C 语言的文件操作函数，如 fopen, fclose, fread, fwrite, fprintf, fscanf 等。\n1 2 3 4 5 FILE* file = fopen(\u0026#34;example.txt\u0026#34;, \u0026#34;w\u0026#34;); // 打开文件用于写操作 if (file != nullptr) { fprintf(file, \u0026#34;Hello, World!\\n\u0026#34;); fclose(file); // 关闭文件 } C++17 文件系统库 (std::filesystem)： C++17 引入了 std::filesystem 库，提供了更现代的文件系统操作接口。\n1 2 3 4 5 6 7 #include \u0026lt;filesystem\u0026gt; namespace fs = std::filesystem; fs::path filePath = \u0026#34;example.txt\u0026#34;; fs::create_directory(\u0026#34;example_dir\u0026#34;); // 创建目录 fs::copy(\u0026#34;source.txt\u0026#34;, \u0026#34;destination.txt\u0026#34;); // 复制文件 fs::remove(\u0026#34;example.txt\u0026#34;); // 删除文件 C++标准库中的其他流： 使用 std::stringstream 或 std::istringstream 和 std::ostringstream 进行字符串和文件内容之间的转换。\n1 2 3 std::stringstream ss; ss \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; std::string fileContent = ss.str(); // 将流内容转换为字符串 低级文件 I/O 操作： 使用操作系统提供的系统调用来直接操作文件，如 UNIX/Linux 系统中的 open, read, write, close 等系统调用。\n1 2 3 4 5 6 7 8 9 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int fd = open(\u0026#34;example.txt\u0026#34;, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR); if (fd != -1) { const char* text = \u0026#34;Hello, World!\u0026#34;; write(fd, text, strlen(text)); close(fd); } 内存映射文件： 使用操作系统提供的内存映射文件功能，如 Windows 的 CreateFileMapping 和 MapViewOfFile，或 UNIX/Linux 的 mmap 系统调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int fd = open(\u0026#34;example.txt\u0026#34;, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR); write(fd, \u0026#34;Hello, World!\u0026#34;, 13); ftruncate(fd, 13); // 调整文件大小 // 映射文件到内存 void* addr = mmap(nullptr, 13, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (addr != MAP_FAILED) { // 使用映射的内存 munmap(addr, 13); // 解除映射 } close(fd); 第三方库： 使用第三方库，如 Boost.Filesystem，提供了跨平台的文件系统操作功能。\n1 2 3 4 5 #include \u0026lt;boost/filesystem.hpp\u0026gt; boost::filesystem::path filePath = \u0026#34;example.txt\u0026#34;; boost::filesystem::create_directory(\u0026#34;example_dir\u0026#34;); boost::filesystem::copy_file(\u0026#34;source.txt\u0026#34;, \u0026#34;destination.txt\u0026#34;); boost::filesystem::remove(\u0026#34;example.txt\u0026#34;); 标准库中的其他工具： 使用 std::tmpfile 创建临时文件，这些文件在程序结束时自动删除。\n1 2 3 4 5 6 7 FILE* tempFile = std::tmpfile(); if (tempFile != nullptr) { fprintf(tempFile, \u0026#34;Temporary data\u0026#34;); rewind(tempFile); // 回到文件开头 // 读取或处理文件... fclose(tempFile); // 关闭文件，文件内容会被删除 } 这些方法提供了不同级别的文件操作控制，从底层系统调用到高级抽象，可以根据具体需求和平台特性选择合适的方法。\n4.在C++中，如何检查文件读写操作是否成功，以及在失败时如何处理错误？ 在 C++ 中，检查文件读写操作是否成功通常涉及到检查文件流的状态。std::fstream、std::ifstream 和 std::ofstream 都提供了成员函数 fail() 和 bad() 来检查流的状态。\n4.1.检查文件操作是否成功 使用 fail() 函数： fail() 函数在流遇到任何形式的输入/输出失败时返回 true。\n1 2 3 4 5 6 7 8 9 10 std::ofstream outFile(\u0026#34;example.txt\u0026#34;); if (outFile.fail()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to open file for writing.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { outFile \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; if (outFile.fail()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to write to file.\u0026#34; \u0026lt;\u0026lt; std::endl; } } outFile.close(); 使用 bad() 函数： bad() 函数在流遇到不可恢复的错误时返回 true，如读写错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 std::ifstream inFile(\u0026#34;example.txt\u0026#34;); if (inFile.bad()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to open file for reading.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::string line; while (std::getline(inFile, line)) { if (inFile.bad()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to read from file.\u0026#34; \u0026lt;\u0026lt; std::endl; break; } std::cout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; std::endl; } } inFile.close(); 检查特定操作的状态： 每次读写操作后，可以立即检查操作是否成功。\n1 2 3 4 5 6 std::ofstream outFile(\u0026#34;example.txt\u0026#34;, std::ios::app); outFile \u0026lt;\u0026lt; \u0026#34;Appending text.\u0026#34; \u0026lt;\u0026lt; std::endl; if (!outFile) { // 等同于检查 fail() 或 bad() std::cerr \u0026lt;\u0026lt; \u0026#34;Write operation failed.\u0026#34; \u0026lt;\u0026lt; std::endl; } outFile.close(); 4.2.错误处理 关闭文件： 如果检测到错误，应该关闭文件以释放资源。\n1 2 3 4 if (outFile.fail()) { outFile.close(); // 进一步的错误处理... } 抛出异常： 可以在检测到错误时抛出异常，让上层代码处理。\n1 2 3 if (outFile.fail()) { throw std::runtime_error(\u0026#34;Failed to write to file.\u0026#34;); } 返回错误代码： 在函数中返回错误代码，让调用者根据错误代码进行处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 bool writeFile(const std::string\u0026amp; filename, const std::string\u0026amp; content) { std::ofstream outFile(filename); if (outFile.fail()) { return false; } outFile \u0026lt;\u0026lt; content; if (outFile.fail()) { outFile.close(); return false; } outFile.close(); return true; } 使用错误码： 定义错误码枚举或类，用于表示不同的错误情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 enum class FileError { None, OpenFailed, WriteFailed, CloseFailed }; FileError writeFile(const std::string\u0026amp; filename, const std::string\u0026amp; content) { std::ofstream outFile(filename); if (outFile.fail()) { return FileError::OpenFailed; } outFile \u0026lt;\u0026lt; content; if (outFile.fail()) { outFile.close(); return FileError::WriteFailed; } if (!outFile.close()) { return FileError::CloseFailed; } return FileError::None; } 记录错误信息： 使用日志记录错误信息，便于调试和跟踪问题。\n1 2 3 4 if (outFile.fail()) { logError(\u0026#34;File writing failed.\u0026#34;); // 进一步的错误处理... } 资源泄漏处理： 确保在发生错误时释放已分配的资源，避免资源泄漏。\n用户提示： 在 GUI 应用程序或需要用户交互的场景中，向用户显示错误信息。\n重试机制： 在某些情况下，如果操作失败，可以实施重试机制。\n通过这些方法，你可以在 C++ 中有效地检查文件操作是否成功，并在失败时进行适当的错误处理。\n5.如果文件读写操作失败，我应该如何优雅地处理异常，而不是直接崩溃程序？ 在 C++ 中，优雅地处理文件读写操作失败的异常，而不是让程序直接崩溃，通常涉及到以下几个步骤：\n5.1. 检查流状态 在进行文件操作之前和之后，检查文件流的状态。这可以通过检查流对象的 fail()、bad() 或 eof() 成员函数来实现。\n5.2. 使用异常处理 使用 try 和 catch 块来捕获和处理可能抛出的异常。\n5.3. 提供错误反馈 向用户提供清晰的错误信息，而不是让程序默默失败。\n5.4. 资源清理 确保在发生异常时释放所有已分配的资源。\n5.5. 记录日志 记录错误日志，以便于后续分析和调试。\n5.6.示例代码 以下是一个示例，展示了如何在文件操作中使用异常处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;fstream\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; void writeToFile(const std::string\u0026amp; filename, const std::string\u0026amp; content) { std::ofstream outFile(filename); if (!outFile) { throw std::runtime_error(\u0026#34;Unable to open file for writing: \u0026#34; + filename); } outFile \u0026lt;\u0026lt; content; if (outFile.fail()) { outFile.close(); throw std::runtime_error(\u0026#34;Failed to write to file: \u0026#34; + filename); } outFile.close(); } void readFromFile(const std::string\u0026amp; filename) { std::ifstream inFile(filename); if (!inFile) { throw std::runtime_error(\u0026#34;Unable to open file for reading: \u0026#34; + filename); } std::string line; while (std::getline(inFile, line)) { if (inFile.fail()) { inFile.close(); throw std::runtime_error(\u0026#34;Failed to read from file: \u0026#34; + filename); } std::cout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; std::endl; } inFile.close(); } int main() { std::string filename = \u0026#34;example.txt\u0026#34;; std::string content = \u0026#34;Hello, World!\\n\u0026#34;; try { writeToFile(filename, content); readFromFile(filename); } catch (const std::exception\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; // 这里可以进行额外的错误处理，如用户提示、日志记录等 } return 0; } 5.7.注意事项 不要吞没异常：不要捕获异常而不处理，至少提供错误反馈或记录日志。 资源管理：使用 RAII（资源获取即初始化）原则管理资源，确保资源在异常发生时也能被正确释放。 用户友好：提供用户友好的错误信息，避免显示复杂的技术细节。 日志记录：记录详细的错误日志，以便于问题追踪和调试。 异常安全：确保程序在抛出和捕获异常时不会泄露资源或留下不可用的状态。 通过这些方法，你可以确保文件读写操作失败时，程序能够优雅地处理异常，而不是直接崩溃。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:06:00+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day12-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E7%BB%BC%E5%90%88%E9%A2%98/","title":"C++ Practical-2 day12 读写文件综合题"},{"content":"C++ Practical-2 day11 继承与封装 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.继承与封装 在 C++ 中，继承和封装是面向对象编程的两个基本特征。\n1.1.封装 封装是将数据（成员变量）和操作这些数据的方法（成员函数）捆绑在一起的一种编程机制。在 C++ 中，封装通过类来实现，类可以包含私有（private）、保护（protected）和公共（public）成员。\n私有成员：可以被类内部的成员函数访问，不能被外部函数访问。 保护成员：可以被类及其子类访问。 公共成员：可以被任何函数访问。 封装的目的是隐藏对象的实现细节，只暴露出必要的接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Box { private: double length; // 私有成员 double width; double height; public: Box(double l, double w, double h) : length(l), width(w), height(h) {} // 构造函数 double getVolume() const { // 公共成员函数 return length * width * height; } // ... 其他成员函数 ... }; 1.2.继承 继承是一种创建新类（称为子类或派生类）的方法，这些新类基于一个或多个现有类（称为基类或父类）。继承支持代码重用，子类继承了基类的所有属性和方法。\n公有继承：子类继承基类的所有公有成员和保护成员，基类的公有成员和保护成员在子类中保持原有的访问级别。 保护继承：基类的公有成员和保护成员在子类中都成为保护成员。 私有继承：基类的公有成员和保护成员在子类中都成为私有成员。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Shape { public: virtual void draw() const { /* ... */ } // 公有虚函数 // ... 其他公有成员 ... protected: // ... 保护成员 ... }; class Circle : public Shape { // 公有继承 double radius; public: Circle(double r) : radius(r) { /* ... */ } void draw() const override { /* ... */ } // 覆盖基类的虚函数 // ... 其他成员函数 ... }; class Rectangle : public Shape { // 公有继承 double width; double height; public: Rectangle(double w, double h) : width(w), height(h) { /* ... */ } void draw() const override { /* ... */ } // 覆盖基类的虚函数 // ... 其他成员函数 ... }; 在上面的例子中，Shape 是一个基类，它定义了一个虚函数 draw()。Circle 和 Rectangle 是从 Shape 派生的子类，它们覆盖了 draw() 函数。\n1.3.组合使用封装和继承 在实际的应用程序中，封装和继承经常一起使用。通过封装，基类可以隐藏其内部实现细节，只暴露出必要的接口。然后，子类可以通过继承这些接口来扩展或修改基类的行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; class Animal { private: std::string name; protected: std::string sound; public: Animal(const std::string \u0026amp;n) : name(n) { } virtual void makeSound() const { /* ... */ } virtual ~Animal() { } // 虚析构函数以确保派生类的正确清理 }; class Dog : public Animal { private: int legs; public: Dog(const std::string \u0026amp;n, int l) : Animal(n), legs(l) { } void makeSound() const override { /* 汪汪汪 */ } // ... 其他成员函数 ... }; // ... int main() { Dog myDog(\u0026#34;Bobby\u0026#34;, 4); myDog.makeSound(); // 调用 Dog 类的 makeSound 函数 } 在这个例子中，Animal 类封装了动物的名称和声音，并且提供了一个虚函数 makeSound()。Dog 类继承自 Animal 并添加了额外的成员变量 legs。Dog 类覆盖了 makeSound() 函数以提供特定的实现。\n通过使用封装和继承，我们可以创建出模块化且易于维护的代码，同时还可以利用多态性来实现灵活的接口。\n2.使用继承和组合的复杂类的例子？ 以下是一个使用继承和组合的复杂类的例子。在这个例子中，我们将创建一个汽车（Car）的类层次结构，并使用组合来添加额外的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 基类：Vehicle class Vehicle { protected: std::string brand; std::string model; int year; public: Vehicle(const std::string \u0026amp;brand, const std::string \u0026amp;model, int year) : brand(brand), model(model), year(year) { } virtual void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;Brand: \u0026#34; \u0026lt;\u0026lt; brand \u0026lt;\u0026lt; \u0026#34;, Model: \u0026#34; \u0026lt;\u0026lt; model \u0026lt;\u0026lt; \u0026#34;, Year: \u0026#34; \u0026lt;\u0026lt; year \u0026lt;\u0026lt; std::endl; } virtual ~Vehicle() { } }; // 派生类：Car class Car : public Vehicle { protected: int doors; double fuelCapacity; public: Car(const std::string \u0026amp;brand, const std::string \u0026amp;model, int year, int doors, double fuelCapacity) : Vehicle(brand, model, year), doors(doors), fuelCapacity(fuelCapacity) { } // 添加 override 关键字 void display() const override { // 注意这里还添加了 const 关键字 Vehicle::display(); std::cout \u0026lt;\u0026lt; \u0026#34;Doors: \u0026#34; \u0026lt;\u0026lt; doors \u0026lt;\u0026lt; \u0026#34;, Fuel Capacity: \u0026#34; \u0026lt;\u0026lt; fuelCapacity \u0026lt;\u0026lt; \u0026#34; liters\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 组合：Engine class Engine { private: std::string type; double horsepower; public: Engine(const std::string \u0026amp;type, double horsepower) : type(type), horsepower(horsepower) { } void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;Engine Type: \u0026#34; \u0026lt;\u0026lt; type \u0026lt;\u0026lt; \u0026#34;, Horsepower: \u0026#34; \u0026lt;\u0026lt; horsepower \u0026lt;\u0026lt; std::endl; } }; // 派生类：SportsCar class SportsCar : public Car { private: Engine engine; bool hasSpoiler; public: SportsCar(const std::string \u0026amp;brand, const std::string \u0026amp;model, int year, int doors, double fuelCapacity, const std::string \u0026amp;engineType, double horsepower, bool hasSpoiler) : Car(brand, model, year, doors, fuelCapacity), engine(engineType, horsepower), hasSpoiler(hasSpoiler) { } void display() const override { Car::display(); engine.display(); std::cout \u0026lt;\u0026lt; \u0026#34;Sports Features: \u0026#34;; if (hasSpoiler) { std::cout \u0026lt;\u0026lt; \u0026#34;Spoiler\u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } }; int main() { // 创建一个 SportsCar 对象 SportsCar sportsCar(\u0026#34;Ford\u0026#34;, \u0026#34;Mustang\u0026#34;, 2021, 2, 50.0, \u0026#34;V8\u0026#34;, 450, true); // 显示汽车信息 sportsCar.display(); return 0; } 在这个例子中，我们有一个基类 Vehicle，它定义了汽车品牌、型号和年份。Car 类继承自 Vehicle 并添加了车门数量和燃油容量。\n我们还定义了一个 Engine 类，它使用组合的方式被 SportsCar 类所包含。Engine 类有引擎类型和马力。SportsCar 类继承自 Car 并使用 Engine 类的实例作为其成员。\nSportsCar 类还添加了一个布尔成员 hasSpoiler 来表示是否具有扰流板。\n在 main 函数中，我们创建了一个 SportsCar 对象并调用了 display 方法来显示汽车的详细信息。\n这个例子展示了如何在 C++ 中使用继承来创建一个类层次结构，并使用组合来添加额外的功能。通过这种方式，我们可以构建出复杂且功能丰富的类。\n3.在C++中，如何实现多态性？ 在 C++ 中，多态性是指允许不同类的对象对同一消息做出响应的能力，即同一个函数或方法在不同的对象中可以有不同的实现。C++ 支持两种主要的多态性：编译时多态性和运行时多态性。\n3.1.编译-time Polymorphism (静态多态性) 编译时多态性主要通过函数重载（Overloading）和模板（Templates）实现。\n函数重载： 同一个作用域内的多个函数可以有相同的名称，但是参数类型、数量或顺序必须不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; void print(int i) { std::cout \u0026lt;\u0026lt; \u0026#34;Printing int: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } void print(double f) { std::cout \u0026lt;\u0026lt; \u0026#34;Printing float: \u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; std::endl; } int main() { print(5); // 调用 print(int) print(5.0); // 调用 print(double) return 0; } 模板： 模板允许你定义泛型函数或类，这些函数或类可以处理不同类型的数据。\n1 2 3 4 5 6 7 8 9 10 11 template \u0026lt;typename T\u0026gt; void print(T value) { std::cout \u0026lt;\u0026lt; \u0026#34;Print: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } int main() { print(5); // 调用 print\u0026lt;int\u0026gt;(5) print(5.0); // 调用 print\u0026lt;double\u0026gt;(5.0) print(\u0026#34;Hello\u0026#34;); // 调用 print\u0026lt;std::string\u0026gt;(\u0026#34;Hello\u0026#34;) return 0; } 3.2.Run-time Polymorphism (动态多态性) 运行时多态性主要通过虚函数（Virtual Functions）实现。\n虚函数： 在基类中声明虚函数，并在派生类中重写这些虚函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; class Animal { public: virtual void speak() const { std::cout \u0026lt;\u0026lt; \u0026#34;Animal makes a sound\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Animal() {} // 虚析构函数确保派生类对象的正确清理 }; class Dog : public Animal { public: void speak() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Dog barks\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Cat : public Animal { public: void speak() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Cat meows\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Animal* myAnimal = new Dog(); myAnimal-\u0026gt;speak(); // 输出 \u0026#34;Dog barks\u0026#34; Animal* anotherAnimal = new Cat(); anotherAnimal-\u0026gt;speak(); // 输出 \u0026#34;Cat meows\u0026#34; delete myAnimal; delete anotherAnimal; return 0; } 在这个例子中，Animal 是一个基类，它有一个虚函数 speak()。Dog 和 Cat 是派生自 Animal 的类，它们重写了 speak() 函数。通过基类指针调用 speak() 函数时，会根据对象的实际类型调用相应的函数，这就是动态多态性。\n抽象类： 包含至少一个纯虚函数的类称为抽象类。纯虚函数没有实现，派生类必须提供这些函数的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Shape { public: virtual void draw() const = 0; // 纯虚函数 virtual ~Shape() {} }; class Circle : public Shape { public: void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a circle\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Rectangle : public Shape { public: void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a rectangle\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Shape* shape1 = new Circle(); shape1-\u0026gt;draw(); // 输出 \u0026#34;Drawing a circle\u0026#34; Shape* shape2 = new Rectangle(); shape2-\u0026gt;draw(); // 输出 \u0026#34;Drawing a rectangle\u0026#34; delete shape1; delete shape2; return 0; } 在这个例子中，Shape 是一个抽象类，它有一个纯虚函数 draw()。Circle 和 Rectangle 是派生自 Shape 的类，它们提供了 draw() 函数的实现。\n通过这些机制，C++ 允许程序员编写更灵活和可扩展的代码。\n4.如何使用 C++ 的抽象类和纯虚函数来设计一个通用的图形库？ 在 C++ 中，使用抽象类和纯虚函数来设计一个通用的图形库是一种常见的做法。这种方法允许你定义一个通用的接口，而具体的实现则由派生类提供。以下是一个简单的例子，展示了如何设计一个基础的图形库：\n4.1.定义抽象基类 Shape 首先，我们定义一个名为 Shape 的抽象基类，它包含一个纯虚函数 draw()，以及一个虚函数 area() 用于计算面积，它在基类中也有一个默认实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Shape { public: // 纯虚函数，用于绘制图形 virtual void draw() const = 0; // 虚函数，用于计算图形的面积 virtual double area() const { return 0.0; // 默认实现，对于不关心面积的图形可以返回0 } // 虚析构函数，确保派生类的析构函数被正确调用 virtual ~Shape() {} }; 4.2.定义具体的图形类 接下来，我们定义一些具体的图形类，如 Circle、Rectangle 和 Triangle，它们都继承自 Shape 类，并实现 draw() 函数和 area() 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Circle : public Shape { private: double radius; public: Circle(double r) : radius(r) {} void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a circle with radius: \u0026#34; \u0026lt;\u0026lt; radius \u0026lt;\u0026lt; std::endl; } double area() const override { return 3.14159 * radius * radius; } }; class Rectangle : public Shape { private: double width; double height; public: Rectangle(double w, double h) : width(w), height(h) {} void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a rectangle with width: \u0026#34; \u0026lt;\u0026lt; width \u0026lt;\u0026lt; \u0026#34; and height: \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; std::endl; } double area() const override { return width * height; } }; class Triangle : public Shape { private: double base; double height; public: Triangle(double b, double h) : base(b), height(h) {} void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a triangle with base: \u0026#34; \u0026lt;\u0026lt; base \u0026lt;\u0026lt; \u0026#34; and height: \u0026#34; \u0026lt;\u0026lt; height \u0026lt;\u0026lt; std::endl; } double area() const override { return 0.5 * base * height; } }; 4.3.使用图形库 最后，我们可以使用这些图形类来创建一个图形库的客户端代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main() { // 创建一个 Shape 类型的指针数组 const int numShapes = 3; Shape* shapes[numShapes]; shapes[0] = new Circle(5.0); shapes[1] = new Rectangle(4.0, 5.0); shapes[2] = new Triangle(3.0, 4.0); // 绘制所有图形 for (int i = 0; i \u0026lt; numShapes; ++i) { shapes[i]-\u0026gt;draw(); std::cout \u0026lt;\u0026lt; \u0026#34;Area: \u0026#34; \u0026lt;\u0026lt; shapes[i]-\u0026gt;area() \u0026lt;\u0026lt; std::endl; } // 清理资源 for (int i = 0; i \u0026lt; numShapes; ++i) { delete shapes[i]; } return 0; } 在这个例子中，我们创建了一个 Shape 类型的指针数组，然后创建了 Circle、Rectangle 和 Triangle 对象，并将它们存储在数组中。我们遍历数组，调用每个图形的 draw() 方法来绘制它们，并计算它们的面积。\n这个设计允许我们轻松地添加更多类型的图形，只需确保每个新图形类都继承自 Shape 并实现了 draw() 和 area() 方法。这就是多态性的力量，它允许我们将图形对象统一处理，而不需要知道它们的具体类型。\n5.在C++中，如何正确地使用虚函数和纯虚函数？ 在 C++ 中，虚函数和纯虚函数是实现多态性的关键工具。以下是如何正确使用它们的方法：\n5.1.虚函数（Virtual Functions） 声明：在基类中声明一个函数为虚函数，使用 virtual 关键字。\n1 2 3 4 5 6 class Base { public: virtual void function() { // 基类的实现 } }; 实现：在基类中提供虚函数的实现（可选），或者在派生类中提供。\n1 2 3 4 5 6 class Derived : public Base { public: void function() override { // 派生类的实现 } }; 覆盖：在派生类中覆盖基类的虚函数，使用 override 关键字（C++11 及以上）。\n1 2 3 4 5 6 class Derived : public Base { public: void function() override { // 派生类的实现 } }; 调用：通过基类指针或引用调用虚函数，将根据对象的实际类型动态绑定到相应的函数。\n1 2 3 Base* b = new Derived(); b-\u0026gt;function(); // 调用 Derived::function() delete b; 5.2.纯虚函数（Pure Virtual Functions） 声明：在基类中声明一个纯虚函数，使用 = 0。\n1 2 3 4 class Base { public: virtual void pureFunction() = 0; }; 含义：包含纯虚函数的类称为抽象类，不能实例化。\n实现：派生类必须提供纯虚函数的实现。\n1 2 3 4 5 6 class Derived : public Base { public: void pureFunction() override { // 实现纯虚函数 } }; 抽象类：通常用于定义接口和提供默认实现。\n1 2 3 4 5 6 7 class Base { public: virtual void interfaceFunction() = 0; virtual void defaultFunction() { // 默认实现 } }; 5.3.最佳实践 使用 override：总是使用 override 关键字来覆盖虚函数，这有助于编译器检查错误。\n虚析构函数：在基类中使用虚析构函数，以确保删除基类指针时能调用正确的析构函数。\n1 2 3 4 class Base { public: virtual ~Base() {} }; 避免虚函数的默认参数：不要为虚函数提供默认参数，因为这可能导致派生类覆盖虚函数时参数不匹配。\n小心虚函数的循环依赖：避免在类之间创建虚函数的循环调用，这可能导致不确定的行为。\n合理使用纯虚函数：纯虚函数应该用于定义接口，而不是提供实际的逻辑。\n考虑线程安全：如果虚函数在多线程环境中被调用，确保它们的实现是线程安全的。\n通过正确使用虚函数和纯虚函数，你可以在 C++ 中实现强大的多态性，这使得代码更加灵活和可扩展。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:05:59+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day11-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%B0%81%E8%A3%85/","title":"C++ Practical-2 day11 继承与封装"},{"content":"C++ Practical-2 day10 异常捕获 异常处理 try exception [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 和Practical-1 day9一样的 1.exception 异常处理 在C++中，异常处理是一种错误处理机制，它允许程序在遇到无法正常处理的情况时，将控制权转移给异常处理器。C++使用try、catch、throw和finally（在C++11中用RAII风格替代）关键字来实现异常处理。\n1.1.异常处理的关键字 try：用于指定一个代码块，在该代码块中可能会抛出异常。 catch：用于捕获并处理特定类型的异常。 throw：用于抛出一个异常。 finally：在C++11之前，没有finally关键字，但可以使用try块后的代码来执行清理操作。C++11引入了std::exception_ptr和std::rethrow_exception来处理异常传播。 1.2.示例：基本的异常处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; // 函数声明 void mightGoWrong() { throw std::runtime_error(\u0026#34;Something went wrong!\u0026#34;); } int main() { try { mightGoWrong(); } catch (const std::runtime_error\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Caught exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } return 0; } 在这个例子中，mightGoWrong函数抛出了一个std::runtime_error异常。在main函数中，我们使用try块来调用这个函数，并使用catch块来捕获和处理异常。\n1.3.示例：多个catch块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; void mightGoWrong(int i) { if (i == 0) throw std::runtime_error(\u0026#34;Argument is zero\u0026#34;); else if (i \u0026lt; 0) throw std::invalid_argument(\u0026#34;Argument is negative\u0026#34;); else throw std::logic_error(\u0026#34;Argument is too large\u0026#34;); } int main() { try { mightGoWrong(-1); } catch (const std::runtime_error\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Runtime error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (const std::invalid_argument\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Invalid argument: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (const std::logic_error\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Logic error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (const std::exception\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Unknown exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } return 0; } 在这个例子中，mightGoWrong函数根据参数的不同抛出不同类型的异常。main函数中的try块调用这个函数，并有多个catch块来捕获不同类型的异常。\n1.4.注意事项 异常应该是异常类的实例：通常，异常应该是std::exception类或其派生类的实例。\n异常不应该被忽略：如果一个try块中的异常没有被捕获，程序将终止。\n异常的类型：可以抛出任何类型的异常，但通常是抛出标准异常类型或自定义的异常类型。\n异常的堆栈跟踪：在抛出异常时，程序会记录异常的堆栈跟踪信息，这对于调试非常有用。\n资源管理：在抛出异常之前，确保释放所有分配的资源，或者使用RAII机制来自动管理资源。\n异常传播：在函数中捕获异常并重新抛出，可以使用std::rethrow_exception来保持原始的异常堆栈信息。\n异常对象的复制：异常对象在抛出时会被复制，因此应该提供拷贝构造函数。\n通过使用异常处理，你可以编写更健壮、更易于维护的代码，并且可以更好地处理程序运行中可能出现的错误情况。\n2.C++中有哪些自定义异常类，它们通常用于什么场景? 在C++中，自定义异常类通常是通过继承自std::exception类来实现的。自定义异常允许你为特定错误情况提供更多的上下文信息。以下是创建和使用自定义异常类的一些常见步骤：\n继承std::exception：创建一个新类，继承自std::exception，并重写what()方法，该方法返回一个描述异常的字符串。\n提供构造函数：为你的异常类提供构造函数，允许设置错误消息和其他相关信息。\n抛出异常：在代码中使用throw关键字抛出你的自定义异常对象。\n捕获异常：使用try-catch块捕获并处理异常。\n2.1.示例：自定义异常类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;exception\u0026gt; #include \u0026lt;string\u0026gt; // 自定义异常类 class MyException : public std::exception { private: std::string message; public: MyException(const std::string\u0026amp; msg) : message(msg) {} // 重写 what() 方法 const char* what() const noexcept override { return message.c_str(); } }; // 一个可能抛出异常的函数 void mightGoWrong(int value) { if (value \u0026lt; 0) { throw MyException(\u0026#34;Negative value is not allowed\u0026#34;); } } int main() { try { mightGoWrong(-1); } catch (const MyException\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Caught exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (const std::exception\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Caught standard exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } return 0; } 在这个示例中，MyException类继承自std::exception，并重写了what()方法来返回错误消息。mightGoWrong函数在接收到负值时抛出MyException。main函数中的try-catch块捕获并处理了这个异常。\n2.2.使用场景 文件处理：当文件无法打开或读取时，可以抛出一个包含错误信息的自定义异常。 网络通信：在网络请求失败时，可以抛出一个包含错误代码和消息的异常。 数据验证：如果输入数据不符合预期，可以抛出一个异常来指示具体的错误。 业务逻辑：在业务规则被违反时，可以使用自定义异常来通知调用者。 自定义异常类使得错误处理更加灵活和表达性更强，有助于调试和维护大型应用程序。\n3.在C++中，除了自定义异常类，还有哪些错误处理机制？ 在C++中，除了使用自定义异常类进行错误处理，还有以下几种常见的错误处理机制：\n错误码：\n许多函数通过返回特定的错误码来指示操作是否成功，例如errno全局变量常用于指示上一次系统调用的错误。 断言（Assert）：\nassert宏用于在调试期间检查程序状态，如果条件为假，则终止程序执行并输出错误信息。它通常用于检查程序的前提条件。 返回值：\n函数可以通过返回值来指示操作是否成功，例如返回布尔值或自定义的枚举类型。 输出参数：\n函数可以将错误信息或状态代码通过输出参数传递给调用者。 异常抛出（Throw）：\n除了自定义异常类，也可以抛出基本数据类型或其他类型的异常对象。 错误处理库：\n使用如Boost.Error或Poco库等第三方库提供的错误处理功能。 标准库异常：\n使用C++标准库提供的异常类，如std::runtime_error、std::logic_error等。 资源获取即初始化（RAII）：\n使用RAII机制管理资源，确保在发生异常时资源能够被正确释放。 错误恢复：\n在某些情况下，程序可以通过执行某些恢复操作来从错误状态中恢复。 日志记录：\n在检测到错误时记录详细的错误信息，以便于后续分析。 条件编译：\n使用预处理器指令（如#ifdef、#ifndef）来处理不同平台或配置下的错误处理。 静态分析工具：\n使用静态分析工具（如Clang Static Analyzer、Cppcheck）来检测潜在的错误。 单元测试：\n通过编写和运行单元测试来确保代码的正确性。 代码审查：\n通过代码审查来发现和修复潜在的错误。 用户界面反馈：\n在图形用户界面（GUI）程序中，通过用户界面提供错误信息。 操作系统错误报告：\n在Windows上使用GetLastError和FormatMessage等函数获取系统错误信息。 信号处理：\n使用信号处理机制（如signal和sigaction）来处理程序运行时的异常情况。 每种错误处理机制都有其适用的场景，选择合适的机制取决于具体的应用需求、性能考虑和编程风格。在实际开发中，通常会结合使用多种错误处理机制来提高程序的健壮性和可维护性。\n4.在C++中实现一个多线程程序，异常处理应该如何设计以避免线程安全问题？ 在C++中实现多线程程序时，异常处理需要特别小心，因为异常可能会跨越线程边界，这可能导致线程安全问题。以下是一些设计多线程程序异常处理时的准则：\n限制异常抛出的范围：\n尽量在线程函数中避免抛出异常。如果必须抛出，确保它在同一个线程中被捕获和处理。 使用异常捕获：\n在每个线程的执行函数中使用try-catch块来捕获和处理异常。 避免在析构函数中抛出异常：\n析构函数中抛出异常是危险的，因为如果一个线程在执行析构函数时抛出异常，而这个异常没有被捕获，那么程序可能会直接退出。如果需要在析构函数中执行清理工作，考虑使用RAII（资源获取即初始化）技术。 使用线程安全的异常处理机制：\n如果需要在多个线程之间传递异常，可以使用线程安全的异常处理机制，如std::current_exception和std::exception_ptr。 使用锁来保护共享资源：\n在访问共享资源之前获取锁，并在可能抛出异常的操作之前释放锁，以避免死锁。 小心使用动态内存分配：\n在抛出异常之前，确保已经释放了所有动态分配的内存，或者使用智能指针来自动管理内存。 使用线程局部存储：\n使用thread_local关键字来定义线程局部存储，以避免在多个线程之间共享可能导致异常的对象。 考虑异常传播：\n如果你在一个线程中捕获了异常，并且需要将这个异常传递给其他线程，可以使用std::exception_ptr。 使用日志记录异常信息：\n在捕获异常时，使用日志记录异常信息，这样即使异常被处理，也可以在日志中追踪到异常发生的原因。 测试多线程程序：\n多线程程序的异常处理需要通过充分的测试来验证，确保在各种情况下都能正确处理异常。 使用标准库中的线程工具：\n使用C++11及更高版本中的标准库线程工具，如std::thread、std::mutex等，它们提供了一些线程安全的机制。 避免使用不安全的函数：\n避免在多线程环境中使用可能导致未定义行为的函数，如longjmp。 记住，多线程编程中的异常处理比单线程编程更加复杂，需要仔细设计以确保程序的稳定性和可靠性。\n4.1.示例 当然，以下是一个简单的C++多线程程序示例，展示了如何在线程中处理异常：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;exception\u0026gt; #include \u0026lt;string\u0026gt; // 线程函数，可能会抛出异常 void threadFunction(int id) { try { // 模拟一些可能会抛出异常的操作 if (id == 1) { throw std::runtime_error(\u0026#34;Exception from thread with id 1\u0026#34;); } std::cout \u0026lt;\u0026lt; \u0026#34;Thread with id \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; is running...\u0026#34; \u0026lt;\u0026lt; std::endl; } catch (const std::exception\u0026amp; e) { // 在线程内部捕获和处理异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Exception caught in thread with id \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (...) { // 捕获所有类型的异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Unknown exception caught in thread with id \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; std::endl; } } int main() { try { // 创建两个线程 std::thread t1(threadFunction, 1); std::thread t2(threadFunction, 2); // 等待线程完成 t1.join(); t2.join(); } catch (const std::exception\u0026amp; e) { // 主线程中捕获异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Exception in main thread: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (...) { // 捕获所有类型的异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Unknown exception in main thread\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 在这个示例中，threadFunction 是一个可能会抛出异常的线程函数。我们使用 try-catch 块来捕获和处理这些异常。如果线程函数抛出了异常，它会在该线程内部被捕获并处理，不会传播到主线程。\n主函数 main 中也使用了 try-catch 块来捕获可能从线程函数传播到主线程的异常，尽管在这个例子中我们没有让异常传播到主线程。\n请注意，这个示例假设异常不会从线程传播到主线程。在实际应用中，如果需要将异常从线程传播到主线程，可以使用 std::exception_ptr。\n这里是一个使用 std::exception_ptr 来传播异常的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;exception\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; // 线程函数，可能会抛出异常 std::exception_ptr threadFunction(int id) { std::exception_ptr ptr = nullptr; try { // 模拟一些可能会抛出异常的操作 if (id == 1) { throw std::runtime_error(\u0026#34;Exception from thread with id 1\u0026#34;); } std::cout \u0026lt;\u0026lt; \u0026#34;Thread with id \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; is running...\u0026#34; \u0026lt;\u0026lt; std::endl; } catch (...) { // 捕获所有异常并存储在exception_ptr中 ptr = std::current_exception(); } return ptr; } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; std::vector\u0026lt;std::exception_ptr\u0026gt; exceptions; try { // 创建两个线程 for (int i = 1; i \u0026lt;= 2; ++i) { threads.emplace_back(threadFunction, i); exceptions.push_back(threadFunction(i)); // 执行线程函数并存储异常 } // 等待线程完成并重新抛出异常 for (auto\u0026amp; t : threads) { t.join(); } for (auto\u0026amp; e : exceptions) { if (e) { std::rethrow_exception(e); } } } catch (const std::exception\u0026amp; e) { // 主线程中捕获异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Exception in main thread: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (...) { // 捕获所有类型的异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Unknown exception in main thread\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 在这个示例中，threadFunction 返回一个 std::exception_ptr，它存储了线程中捕获的异常。在主线程中，我们等待所有线程完成，然后检查每个线程的 std::exception_ptr，如果有异常，就使用 std::rethrow_exception 重新抛出它。这样，异常就可以从线程传播到主线程了。\n5.在C++中，如何使用RAII原则来管理资源？ RAII（Resource Acquisition Is Initialization）是C++中一种管理资源获取和释放的编程技术。RAII的核心思想是将资源的生命周期绑定到对象的生命周期。当对象创建时，它获取必要的资源，当对象销毁时，它释放这些资源。这通常通过构造函数来获取资源，通过析构函数来释放资源来实现。\n5.1.RAII的基本原则 资源获取：在类的构造函数中分配或获取资源。 资源释放：在类的析构函数中释放资源。 对象生命周期：确保对象的生命周期与资源的生命周期一致。 异常安全：确保在构造过程中发生异常时，已经获取的资源能够被正确释放。 5.2.RAII的常见应用 动态内存管理：使用new和delete操作符。 文件和网络资源：使用文件句柄和网络连接。 互斥锁：使用互斥锁来保护临界区。 5.3.示例：使用RAII管理动态内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; class AutoPtr { private: int* ptr; public: AutoPtr() : ptr(nullptr) {} explicit AutoPtr(int* p) : ptr(p) {} ~AutoPtr() { delete[] ptr; } // 禁止复制和赋值 AutoPtr(const AutoPtr\u0026amp;) = delete; AutoPtr\u0026amp; operator=(const AutoPtr\u0026amp;) = delete; // 支持移动语义 AutoPtr(AutoPtr\u0026amp;\u0026amp; other) : ptr(other.ptr) { other.ptr = nullptr; } AutoPtr\u0026amp; operator=(AutoPtr\u0026amp;\u0026amp; other) { if (this != \u0026amp;other) { delete[] ptr; ptr = other.ptr; other.ptr = nullptr; } return *this; } int* get() const { return ptr; } }; int main() { AutoPtr ap(new int[10]); // 分配数组 // 不需要手动释放，析构函数会自动处理 return 0; } 在这个例子中，AutoPtr类使用RAII模式管理一个整数数组的生命周期。当AutoPtr对象创建时，它分配内存；当对象销毁时，它释放内存。\n5.4.示例：使用RAII管理文件资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; class File { private: std::fstream file; public: File(const std::string\u0026amp; filename, std::ios_base::openmode mode) { file.open(filename, mode); if (!file.is_open()) { throw std::runtime_error(\u0026#34;Failed to open file\u0026#34;); } } ~File() { if (file.is_open()) { file.close(); } } // 禁止复制和赋值 File(const File\u0026amp;) = delete; File\u0026amp; operator=(const File\u0026amp;) = delete; // 支持移动语义 File(File\u0026amp;\u0026amp; other) : file(std::move(other.file)) {} File\u0026amp; operator=(File\u0026amp;\u0026amp; other) { file = std::move(other.file); return *this; } }; int main() { try { File f(\u0026#34;example.txt\u0026#34;, std::ios::in); // 使用文件 } catch (const std::runtime_error\u0026amp; e) { std::cerr \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } // 文件在f的析构函数中自动关闭 return 0; } 在这个例子中，File类使用RAII模式管理文件资源。当File对象创建时，它打开文件；当对象销毁时，它关闭文件。\n5.5.注意事项 禁止复制：通常，管理资源的对象应该禁止复制，以避免资源泄漏。 支持移动语义：支持移动构造函数和移动赋值运算符，以便在不同对象之间传递资源。 异常安全：确保在构造函数中获取资源时，如果发生异常，已经获取的资源能够被正确释放。 资源泄露：避免在析构函数中抛出异常，因为这可能导致资源泄露。 RAII是一种强大的资源管理技术，它可以简化代码，提高资源管理的安全性和可靠性。\n6.在C++中，除了RAII，还有哪些资源管理技术？ 在C++中，除了RAII（Resource Acquisition Is Initialization）原则，还有其他一些资源管理技术，这些技术有助于确保资源的正确管理和释放。以下是一些常见的资源管理技术：\n智能指针：\nstd::unique_ptr：独占式拥有其所指向的对象，不允许复制，但可以移动。 std::shared_ptr：共享式拥有其所指向的对象，具有引用计数机制。 std::weak_ptr：用于解决std::shared_ptr可能导致的循环引用问题。 函数对象（Functors）：\n封装状态和行为的对象，可以像函数一样被调用。 模板类：\n通过模板编程，可以编写通用的资源管理代码，如std::unique_ptr。 继承和多态：\n通过继承和多态，可以在基类中定义资源管理的接口，由派生类实现具体的资源管理逻辑。 异常处理：\n使用try、catch和throw关键字来捕获和处理异常，确保在异常发生时资源能够被正确释放。 条件编译：\n使用宏定义和条件编译来管理不同平台或配置下的资源。 手动管理：\n直接使用new和delete，malloc和free来管理内存资源。 垃圾回收：\n虽然C++标准库中没有内置的垃圾回收机制，但可以使用第三方库或特定的内存管理策略来实现类似垃圾回收的功能。 内存池（Memory Pool）：\n预先分配一块大的内存区域，用于频繁地分配和释放固定大小的对象，以减少内存碎片和提高性能。 对象池（Object Pool）：\n预先创建一组对象，以便快速重用，避免频繁的构造和析构。 线程局部存储（Thread-Local Storage）：\n使用线程局部变量来存储每个线程独有的资源。 原子操作：\n使用std::atomic来管理对共享资源的并发访问。 互斥锁（Mutexes）：\n使用互斥锁来保护临界区，确保同一时间只有一个线程可以访问共享资源。 文件描述符封装：\n封装文件描述符等操作系统资源，确保在对象销毁时关闭文件。 事件驱动编程：\n在事件循环中管理资源，确保资源在使用完成后能够被释放。 依赖注入：\n通过将资源作为参数传递给函数或对象，而不是在对象内部创建资源。 这些技术可以单独使用，也可以组合使用，以满足不同场景下的资源管理需求。正确选择和管理资源对于编写高效、可靠和可维护的C++程序至关重要。\n7.在栈中使用异常处理 在C++中，使用栈（stack）时进行异常处理需要特别注意，因为异常可能会跨越多个栈帧，这可能会导致资源泄漏或其他问题。以下是一些在栈中使用异常处理时的准则：\n使用RAII（资源获取即初始化）：\nRAII是一种确保资源在对象生命周期内被正确管理的机制。当对象超出作用域时，其析构函数将自动被调用，从而释放资源。 避免在析构函数中抛出异常：\n如果一个对象的析构函数抛出异常，而这个异常没有被捕获，那么程序可能会直接退出。因此，应该在析构函数中避免抛出异常。 使用智能指针管理动态内存：\n使用std::unique_ptr或std::shared_ptr来自动管理动态分配的内存。 使用std::stack的异常安全：\nstd::stack是一个容器适配器，它提供了基本的异常安全保证。但是，如果你在std::stack中存储了自定义对象，并且这些对象的复制或移动操作可能会抛出异常，那么你需要确保这些操作是异常安全的。 使用try-catch块：\n在可能抛出异常的代码周围使用try-catch块来捕获和处理异常。 使用std::exception_ptr：\n如果你需要在多个线程之间传递异常，可以使用std::exception_ptr。 使用noexcept：\n在不会抛出异常的函数后面使用noexcept关键字，以告诉编译器这个函数不会抛出异常。 使用std::uncaught_exceptions：\nstd::uncaught_exceptions是C++17中引入的，它返回当前线程中未捕获的异常数量。这可以用来检测是否有异常正在传播。 下面是一个示例，展示了如何在栈中使用异常处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;stdexcept\u0026gt; class Resource { public: Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource acquired\\n\u0026#34;; } ~Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource released\\n\u0026#34;; } }; void safeFunction(std::stack\u0026lt;std::unique_ptr\u0026lt;Resource\u0026gt;\u0026gt;\u0026amp; s) { try { // 模拟可能会抛出异常的操作 throw std::runtime_error(\u0026#34;Exception in safeFunction\u0026#34;); } catch (...) { // 捕获所有异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Exception caught in safeFunction\\n\u0026#34;; // 确保栈中的资源被正确释放 s = std::stack\u0026lt;std::unique_ptr\u0026lt;Resource\u0026gt;\u0026gt;(); // 清空栈 throw; // 重新抛出异常 } } int main() { std::stack\u0026lt;std::unique_ptr\u0026lt;Resource\u0026gt;\u0026gt; s; try { // 将资源推入栈中 s.push(std::make_unique\u0026lt;Resource\u0026gt;()); safeFunction(s); } catch (const std::exception\u0026amp; e) { // 主线程中捕获异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Exception in main thread: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (...) { // 捕获所有类型的异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Unknown exception in main thread\u0026#34; \u0026lt;\u0026lt; std::endl; } // 栈中的资源将自动被释放 return 0; } 在这个示例中，我们使用std::unique_ptr来管理Resource对象的生命周期。当Resource对象超出作用域时，其析构函数将自动被调用，从而释放资源。在safeFunction中，我们捕获所有异常，并在捕获异常后清空栈，以确保栈中的资源被正确释放。然后，我们重新抛出异常，以便在主线程中进行处理。\n请注意，这个示例假设异常不会从safeFunction传播到主线程。在实际应用中，如果需要将异常从safeFunction传播到主线程，可以使用std::exception_ptr。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:05:58+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day10-%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-try-exception/","title":"C++ Practical-2 day10 异常捕获 异常处理 try exception"},{"content":"C++ Practical-2 day9 字典插入与查找 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.字典插入与查找 在 C++ 中，字典通常可以通过 std::map 或 std::unordered_map 来实现。这两个容器都提供了插入和查找元素的功能。以下是如何使用这两个容器进行插入和查找操作的示例：\n1.1.使用 std::map std::map 是一个基于红黑树实现的有序关联容器，它允许根据键（key）来存储和查找值（value）。\n插入元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;map\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::map\u0026lt;int, std::string\u0026gt; dictionary; // 插入元素 dictionary.insert(std::make_pair(1, \u0026#34;one\u0026#34;)); dictionary.insert(std::make_pair(2, \u0026#34;two\u0026#34;)); dictionary.insert(std::make_pair(3, \u0026#34;three\u0026#34;)); // 另一种插入方式 dictionary[4] = \u0026#34;four\u0026#34;; // 插入已存在键的值，会更新该键的值 dictionary[2] = \u0026#34;two updated\u0026#34;; } 查找元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;map\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::map\u0026lt;int, std::string\u0026gt; dictionary = { {1, \u0026#34;one\u0026#34;}, {2, \u0026#34;two\u0026#34;}, {3, \u0026#34;three\u0026#34;} }; // 查找元素 int key = 2; if (dictionary.find(key) != dictionary.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found: \u0026#34; \u0026lt;\u0026lt; dictionary[key] \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found\u0026#34; \u0026lt;\u0026lt; std::endl; } } 1.2.使用 std::unordered_map std::unordered_map 是一个基于哈希表实现的无序关联容器，它同样允许根据键来存储和查找值，但查找速度通常比 std::map 更快。\n插入元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::unordered_map\u0026lt;int, std::string\u0026gt; dictionary; // 插入元素 dictionary.insert(std::make_pair(1, \u0026#34;one\u0026#34;)); dictionary.insert(std::make_pair(2, \u0026#34;two\u0026#34;)); dictionary.insert(std::make_pair(3, \u0026#34;three\u0026#34;)); // 另一种插入方式 dictionary[4] = \u0026#34;four\u0026#34;; // 插入已存在键的值，会更新该键的值 dictionary[2] = \u0026#34;two updated\u0026#34;; } 查找元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::unordered_map\u0026lt;int, std::string\u0026gt; dictionary = { {1, \u0026#34;one\u0026#34;}, {2, \u0026#34;two\u0026#34;}, {3, \u0026#34;three\u0026#34;} }; // 查找元素 int key = 2; if (dictionary.find(key) != dictionary.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found: \u0026#34; \u0026lt;\u0026lt; dictionary[key] \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Not found\u0026#34; \u0026lt;\u0026lt; std::endl; } } 在这两个例子中，insert 函数用于插入新元素，而 operator[] 用于插入或更新元素。查找操作是通过 find 成员函数进行的，如果找到了元素，它会返回一个指向元素的迭代器；如果没有找到，它会返回一个指向容器末尾的迭代器（end()）。\n选择 std::map 还是 std::unordered_map 取决于你的具体需求。如果需要保持元素的排序，或者频繁进行范围查询，那么 std::map 可能是更好的选择。如果需要快速的插入和查找，并且不关心元素的顺序，那么 std::unordered_map 可能更合适。\n2.在 C++ 中，除了 std::map 和 std::unordered_map，还有哪些容器可以用于实现字典功能？ 在 C++ 中，除了 std::map 和 std::unordered_map，还有一些其他容器和方法可以实现类似字典的功能：\nstd::unordered_multimap： 和 std::unordered_map 类似，但它允许多个值与同一个键关联。\nstd::map 和 std::multimap： std::map 是有序的，而 std::multimap 允许多个值与一个键关联。\nstd::flat_map： 这是 C++20 中引入的容器，它提供了与 std::map 相似的接口，但是它底层使用数组而不是红黑树，这可以减少内存的占用并提高性能。\nstd::flat_multimap： 也是 C++20 中引入的，与 std::flat_map 类似，但它允许多个值与一个键关联。\nstd::array 或 std::vector： 如果你的键是连续的整数，你可以使用 std::array 或 std::vector 来实现字典。例如，你可以使用一个索引数组来存储值，并通过计算键的哈希值来访问数组。\nstd::list 或 std::forward_list： 这些线性容器可以用来实现字典，特别是当你需要经常在中间插入或删除元素时。\nstd::set 或 std::unordered_set： 如果你只需要存储键，而不需要存储值，可以使用这些集合容器。\nstd::valarray： 如果你需要存储数组的值，并且经常需要对它们进行数学运算，std::valarray 可以是一个选择。\n自定义哈希表： 你可以自己实现一个哈希表，这会给你更多的控制权，但也需要更多的工作。\nstd::unordered_multiset： 类似于 std::unordered_multimap，但它只存储键，不存储值。\nstd::bst： 如果你需要一个有序的字典，你可以自己实现一个二叉搜索树（Binary Search Tree）。\nstd::priority_queue： 如果你需要一个有序的字典，其中每次删除都是最大或最小元素，你可以使用优先队列。\nstd::queue 或 std::stack： 这些容器可以用于实现字典，特别是当你需要保持元素的插入顺序时。\n选择哪种容器取决于你的具体需求，比如是否需要排序、是否允许多个值与同一个键关联、性能要求等。在某些情况下，你可能需要组合使用不同的容器或者自定义数据结构来满足特定的需求。\n3.如何优化std:map的查找性能，以应对大量数据的快速查找？ 要优化 std::map 的查找性能以应对大量数据的快速查找，可以考虑以下几个方面：\n确保键类型的比较效率高：std::map 基于红黑树实现，查找操作的效率依赖于键类型的比较操作。如果键类型是自定义的，确保比较操作（如 operator\u0026lt;）高效且不会引入额外开销。\n避免使用 operator[] 进行查找：使用 operator[] 访问不存在的键会插入一个默认构造的元素。如果只是查找，应该使用 find 方法，它在找不到元素时会返回 end 迭代器，而不是插入新元素。\n使用更合适的容器：如果查找性能仍然不满足要求，可以考虑使用 std::unordered_map，它基于哈希表实现，平均时间复杂度为 O(1)，但缺点是不支持有序迭代。\n预计算和缓存：对于某些查找操作，如果键的计算成本很高，可以考虑预计算并缓存结果，以避免重复计算。\n优化数据结构设计：有时候，对数据结构的设计进行优化可以减少查找次数，例如通过增加辅助索引或使用更适合查询模式的数据结构。\n并行查找：在多核处理器上，对于独立的查找任务，可以考虑使用并行处理来提高性能。\n避免频繁的插入和删除：std::map 的插入和删除操作可能需要重新平衡树，这在大量数据时会影响性能。如果可能，尽量批量处理这些操作。\n使用自定义比较器：通过提供一个自定义比较器，可以改变 std::map 的排序方式，有时这可以提高查找效率。\n减少内存分配：对于值类型是对象的情况，考虑使用指针或引用来减少内存分配和复制的开销。\n使用标准库算法：对于静态数据，可以使用标准库排序算法（如 std::sort）预先排序，然后使用二分查找算法（如 std::binary_search 或 std::lower_bound）进行查找。\n通过这些方法，可以显著提高 std::map 在大量数据下的查找性能。不过，优化时应该根据具体情况进行性能测试，以确保所做的优化是有效的。\n4.std:unordered_map在什么情况下比std:map更有优势，反之亦然？ std::unordered_map 和 std::map 在 C++ 中都是用来实现字典功能的容器，但它们在性能方面有各自的优势，适用于不同的场景。\n4.1.std::unordered_map 的优势 查找速度快：平均时间复杂度接近 O(1)，因此在查找操作频繁的场景下更有优势。 插入速度快：插入操作通常也是 O(1)，但可能会因为哈希冲突而变慢。 内存占用：通常比 std::map 占用更多内存，因为需要存储哈希桶和可能的链表或红黑树节点。 4.2.std::map 的优势 有序性：元素会按照键的顺序自动排序，如果需要有序遍历，std::map 更合适。 稳定性：查找和插入的时间复杂度稳定在 O(log n)，不会因为哈希冲突而性能下降。 内存占用：相比 std::unordered_map，通常占用更少的内存，因为不需要额外的哈希表结构。 4.3.使用场景 选择 std::unordered_map：\n当元素的顺序不重要，而查找速度是关键时。 当插入和查找操作非常频繁，且对性能要求较高时。 当对内存使用不是非常敏感时。 选择 std::map：\n当需要有序遍历元素时。 当对查找性能的稳定性有要求时。 当内存使用是需要考虑的因素时。 4.4.性能测试 在实际的性能测试中 ，std::unordered_map 在插入和查找操作上通常会比 std::map 表现得更好，尤其是在数据量较大时。但是，这也取决于具体的使用情况和数据分布。\n总结来说，如果应用程序对查找速度有较高要求且不关心元素的排序，std::unordered_map 是更好的选择。如果需要有序的元素或者对性能稳定性有要求，那么 std::map 可能更适合。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:05:57+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day9-%E5%AD%97%E5%85%B8%E6%8F%92%E5%85%A5%E4%B8%8E%E6%9F%A5%E6%89%BE/","title":"C++ Practical-2 day9 字典插入与查找"},{"content":"C++ Practical-2 day8 动态数组 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.在C++中，除了使用new和delete，还有其他方式可以创建动态数组吗？ 在C++中，除了使用new和delete操作符来创建和销毁动态数组，还有以下几种常见的方法来创建和管理动态数组：\n使用std::vector： std::vector是C++标准库中的一个动态数组容器，它封装了内存管理的细节，提供了动态扩容、元素访问、插入和删除等操作。\n1 2 3 4 5 6 #include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; vec; vec.push_back(1); vec.push_back(2); // ... 使用std::array（固定大小）： std::array是一个固定大小的数组容器，它存储在栈上，但提供了类似于std::vector的接口。\n1 2 3 #include \u0026lt;array\u0026gt; std::array\u0026lt;int, 4\u0026gt; arr = {1, 2, 3, 4}; 使用std::unique_ptr和自定义删除器： 可以使用智能指针std::unique_ptr与自定义删除器来管理动态数组。\n1 2 3 #include \u0026lt;memory\u0026gt; std::unique_ptr\u0026lt;int[], void(*)(int*)\u0026gt; uptr(new int[10], [](int* p){ delete[] p; }); 使用std::shared_ptr和自定义删除器： 类似于std::unique_ptr，但std::shared_ptr允许多个指针共享同一个动态数组。\n1 2 3 #include \u0026lt;memory\u0026gt; std::shared_ptr\u0026lt;int\u0026gt; sptr(new int[10], [](int* p){ delete[] p; }); 使用malloc和free： C语言的malloc和free函数也可以用来分配和释放动态内存。\n1 2 3 4 5 int* arr = (int*)malloc(10 * sizeof(int)); if (arr != nullptr) { // 使用数组... } free(arr); 使用std::allocator： std::allocator是C++标准库中的一个内存分配器，它可以与容器一起使用。\n1 2 3 4 5 6 #include \u0026lt;memory\u0026gt; std::allocator\u0026lt;int\u0026gt; alloc; int* arr = alloc.allocate(10); // ... alloc.deallocate(arr, 10); 使用std::make_unique： std::make_unique是一个辅助函数，用于创建std::unique_ptr。\n1 2 3 #include \u0026lt;memory\u0026gt; auto uptr = std::make_unique\u0026lt;int[]\u0026gt;(10); 使用std::make_shared： std::make_shared是一个辅助函数，用于创建std::shared_ptr。\n1 2 3 #include \u0026lt;memory\u0026gt; auto sptr = std::make_shared\u0026lt;int[]\u0026gt;(10); 使用std::vector的data成员函数： 如果你需要一个指向std::vector底层数组的指针，可以使用data成员函数。\n1 2 3 4 #include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; vec(10); int* arr = vec.data(); 使用C++17的std::allocator_traits： std::allocator_traits提供了一种方式来查询和使用分配器的属性和操作。\n1 2 3 4 5 6 #include \u0026lt;memory\u0026gt; template \u0026lt;typename Allocator\u0026gt; void deallocate(Allocator\u0026amp; alloc, int* ptr, size_t size) { std::allocator_traits\u0026lt;Allocator\u0026gt;::deallocate(alloc, ptr, size); } 在现代C++编程中，推荐使用标准库提供的容器和智能指针，因为它们提供了更好的类型安全性、异常安全性和资源管理。\n2.动态数组类 在C++中，动态数组通常指的是使用new和delete操作符动态分配和释放内存的数组。与静态数组（在栈上分配的数组）不同，动态数组的生命周期由程序员控制，可以在运行时确定大小。\n以下是如何在C++中实现一个简单的动态数组类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // for std::copy #include \u0026lt;cstddef\u0026gt; // for std::size_t template \u0026lt;typename T\u0026gt; class DynamicArray { private: T* data; // 指向动态分配数组的指针 std::size_t size; // 数组中元素的数量 public: // 构造函数 explicit DynamicArray(std::size_t size) : data(new T[size]), size(size) {} // 析构函数 ~DynamicArray() { delete[] data; } // 拷贝构造函数 DynamicArray(const DynamicArray\u0026amp; other) : data(new T[other.size]), size(other.size) { std::copy(other.data, other.data + other.size, data); } // 移动构造函数 DynamicArray(DynamicArray\u0026amp;\u0026amp; other) noexcept : data(other.data), size(other.size) { other.data = nullptr; other.size = 0; } // 拷贝赋值运算符 DynamicArray\u0026amp; operator=(const DynamicArray\u0026amp; other) { if (this != \u0026amp;other) { delete[] data; data = new T[other.size]; size = other.size; std::copy(other.data, other.data + other.size, data); } return *this; } // 移动赋值运算符 DynamicArray\u0026amp; operator=(DynamicArray\u0026amp;\u0026amp; other) noexcept { if (this != \u0026amp;other) { delete[] data; data = other.data; size = other.size; other.data = nullptr; other.size = 0; } return *this; } // 获取数组的大小 std::size_t getSize() const { return size; } // 获取指定索引的元素 T\u0026amp; operator[](std::size_t index) { return data[index]; } // 获取指定索引的元素（const版本） const T\u0026amp; operator[](std::size_t index) const { return data[index]; } }; int main() { DynamicArray\u0026lt;int\u0026gt; arr(5); // 创建一个大小为5的动态数组 for (std::size_t i = 0; i \u0026lt; arr.getSize(); ++i) { arr[i] = i * i; } for (std::size_t i = 0; i \u0026lt; arr.getSize(); ++i) { std::cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，我们定义了一个DynamicArray类模板，它封装了动态数组的分配、使用和释放。类中包含了：\n一个类型为T*的私有成员data，它指向动态分配的内存。 一个size成员，记录数组中元素的数量。 构造函数和析构函数，分别用于分配和释放内存。 拷贝构造函数和拷贝赋值运算符，用于复制数组内容。 移动构造函数和移动赋值运算符，用于支持移动语义。 getSize成员函数，返回数组的大小。 operator[]，重载了下标运算符以访问数组元素。 这个简单的动态数组类模板展示了如何管理动态内存。在实际应用中，你可能还需要添加更多的功能，比如动态扩容、插入和删除元素等操作。\n3.如何实现动态数组的动态扩容功能？ 实现动态数组的动态扩容功能通常涉及以下几个步骤：\n初始分配：创建数组时分配初始容量。 检测容量：在添加元素前检查是否有足够的空间。 扩容：如果空间不足，分配更大的内存空间。 复制元素：将旧数组的元素复制到新数组。 释放旧数组：删除旧数组以避免内存泄漏。 以下是如何在C++中实现一个具有动态扩容功能的动态数组类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // for std::copy #include \u0026lt;cstddef\u0026gt; // for std::size_t template \u0026lt;typename T\u0026gt; class DynamicArray { private: T* data; // 指向动态分配数组的指针 std::size_t size; // 当前数组中元素的数量 std::size_t capacity; // 数组分配的总容量 void resize(std::size_t newCapacity) { T* newData = new T[newCapacity]; std::copy(data, data + size, newData); delete[] data; data = newData; capacity = newCapacity; } public: // 构造函数 explicit DynamicArray(std::size_t initialCapacity = 10) : data(new T[initialCapacity]), size(0), capacity(initialCapacity) {} // 析构函数 ~DynamicArray() { delete[] data; } // 禁止拷贝构造函数 DynamicArray(const DynamicArray\u0026amp;) = delete; // 禁止拷贝赋值运算符 DynamicArray\u0026amp; operator=(const DynamicArray\u0026amp;) = delete; // 移动构造函数 DynamicArray(DynamicArray\u0026amp;\u0026amp; other) noexcept : data(other.data), size(other.size), capacity(other.capacity) { other.data = nullptr; other.size = 0; other.capacity = 0; } // 移动赋值运算符 DynamicArray\u0026amp; operator=(DynamicArray\u0026amp;\u0026amp; other) noexcept { if (this != \u0026amp;other) { delete[] data; data = other.data; size = other.size; capacity = other.capacity; other.data = nullptr; other.size = 0; other.capacity = 0; } return *this; } // 添加元素 void pushBack(const T\u0026amp; value) { if (size == capacity) { std::size_t newCapacity = capacity == 0 ? 1 : (capacity * 2); resize(newCapacity); } data[size++] = value; } // 获取数组的大小 std::size_t getSize() const { return size; } // 获取指定索引的元素 T\u0026amp; operator[](std::size_t index) { return data[index]; } // 获取指定索引的元素（const版本） const T\u0026amp; operator[](std::size_t index) const { return data[index]; } }; int main() { DynamicArray\u0026lt;int\u0026gt; arr; for (int i = 0; i \u0026lt; 15; ++i) { arr.pushBack(i); } for (std::size_t i = 0; i \u0026lt; arr.getSize(); ++i) { std::cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 3.1.解释 初始分配：\n构造函数中分配初始容量（默认为10）。 检测容量：\n在pushBack方法中，检查当前数组的大小是否等于容量。如果是，则需要扩容。 扩容：\nresize方法分配新的容量（默认为当前容量的两倍），并将旧数组的元素复制到新数组。 复制元素：\n使用std::copy将旧数组的元素复制到新数组。 释放旧数组：\n删除旧数组以避免内存泄漏。 3.2.注意事项 初始容量：可以根据需要调整初始容量和扩容策略。 异常安全：在实际应用中，需要考虑异常安全，确保在分配新内存或复制元素时不会发生内存泄漏。 内存管理：确保正确管理内存，避免内存泄漏和野指针。 通过这种方式，你可以实现一个具有动态扩容功能的动态数组类，使其在需要时自动扩展容量。\n4.动态数组在内存管理方面有哪些潜在的风险，我应该如何避免？ 动态数组在内存管理方面主要存在以下潜在风险：\n内存泄漏：如果分配了内存但没有正确释放，会导致内存泄漏。例如，忘记使用 delete[] 释放动态数组 。\n双重释放：多次释放同一块内存会导致未定义行为，可能引发程序崩溃。\n悬挂指针：释放内存后没有将指针置为 nullptr，使其仍然指向已被释放的内存区域，后续对这片区域的访问是非法的。\n越界访问：在动态分配的内存区域内进行不合法的读写操作，例如索引超出数组边界。\n内存分配失败：new 分配内存失败时会抛出 std::bad_alloc 异常，而 malloc 会返回 NULL 指针。如果不正确处理，可能会导致程序异常终止。\n内存碎片：频繁的内存分配和释放可能导致内存碎片，降低内存使用效率。\n为了避免这些风险，可以采取以下措施：\n使用智能指针：如 std::unique_ptr 和 std::shared_ptr，它们可以自动管理内存的释放，避免内存泄漏和悬挂指针 。\n确保异常安全：在动态内存分配时使用异常处理机制，确保即使在异常发生时也能正确释放内存。\n使用 RAII 技术：确保资源在对象生命周期结束时自动释放，这是一种常用的避免资源泄漏的方法。\n避免越界访问：在访问数组元素时，始终检查索引是否在有效范围内。\n检查内存分配结果：每次使用 new 或 malloc 后，检查返回值是否为空，确保内存分配成功。\n内存池：对于频繁的内存分配和释放，可以使用内存池来减少内存碎片和提高内存分配效率。\n使用标准库容器：如 std::vector，它内部管理内存，并提供了自动扩容和缩容的功能，减少了内存管理的复杂性。\n通过这些方法，可以有效地管理动态数组的内存，避免常见的内存管理问题，提高程序的稳定性和性能。\n5.如何使用\u0026rsquo;std:vector\u0026rsquo;进行高效的动态数组管理？ std::vector 是 C++ 标准库中的一个动态数组容器，它封装了动态内存管理的细节，提供了动态扩容、元素访问、插入和删除等操作。以下是如何使用 std::vector 进行高效的动态数组管理的一些关键点：\n自动内存管理： std::vector 自动管理内存的分配和释放，无需手动使用 new 和 delete。\n动态扩容： 当添加元素超出当前容量时，std::vector 会自动分配更大的内存空间，并移动现有元素到新内存。\n提供异常安全性： 如果内存分配失败，std::vector 会抛出异常，而不会泄漏内存。\n随机访问： std::vector 提供了随机访问迭代器，允许快速访问任何元素。\n范围检查： 使用 at() 成员函数可以提供边界检查，当访问超出范围的元素时会抛出 std::out_of_range 异常。\n迭代器： 提供迭代器支持，可以用于循环遍历 std::vector。\n容量和大小： size() 返回当前元素数量，capacity() 返回当前分配的内存可以容纳的元素数量。\n插入和删除操作： 提供 push_back(), pop_back(), insert(), erase() 等成员函数进行元素的插入和删除。\n内存优化： shrink_to_fit() 可以请求减小内存使用量，reserve() 可以预先分配足够的内存。\n数据访问： 使用 operator[] 或 at() 访问元素，front() 和 back() 获取首尾元素。\n构造和复制： 提供拷贝构造函数和拷贝赋值运算符，支持移动语义，使用 std::move 进行高效复制。\n空值检查： 使用 empty() 检查 std::vector 是否为空。\n析构： 当 std::vector 被销毁时，会自动释放其管理的内存。\n以下是一些使用 std::vector 的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { // 创建一个空的 vector std::vector\u0026lt;int\u0026gt; vec; // 添加元素 vec.push_back(1); vec.push_back(2); vec.push_back(3); // 访问元素 for (size_t i = 0; i \u0026lt; vec.size(); ++i) { std::cout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; // 插入元素 vec.insert(vec.begin() + 1, 5); // 删除元素 vec.erase(vec.begin() + 1); // 使用迭代器遍历 for (auto it = vec.begin(); it != vec.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; // 范围检查 try { std::cout \u0026lt;\u0026lt; vec.at(10) \u0026lt;\u0026lt; std::endl; } catch (const std::out_of_range\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Exception caught: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } // 内存优化 vec.shrink_to_fit(); return 0; } 使用 std::vector 可以大大简化动态数组的管理，减少内存泄漏和悬挂指针的风险，并提高代码的可读性和维护性。\n6.在C++中，\u0026lsquo;std:unique_ptr\u0026rsquo;和\u0026rsquo;std:shared_ptr\u0026rsquo;在动态数组管理上有什么不同？ 在 C++ 中，std::unique_ptr 和 std::shared_ptr 都是智能指针，用于自动管理动态分配的内存，但它们在管理动态数组时有一些关键的区别：\nstd::unique_ptr 与动态数组：\nstd::unique_ptr 是独占所有权的智能指针，意味着同一时间只能有一个 std::unique_ptr 指向特定资源。 它不能被复制，但可以被移动，这允许在不同对象之间传递所有权。 std::unique_ptr 可以被用来管理动态数组，但需要使用特殊的数组删除器 std::default_delete，因为数组的删除需要使用 delete[] 而不是 delete。 使用 std::unique_ptr 管理动态数组时，可以使用 std::make_unique（C++14 引入）来创建实例。 示例：\n1 std::unique_ptr\u0026lt;int[]\u0026gt; uptr(new int[10]); std::shared_ptr 与动态数组：\nstd::shared_ptr 是共享所有权的智能指针，允许多个 std::shared_ptr 实例共享同一资源。 它使用引用计数机制来跟踪有多少个 std::shared_ptr 实例共享同一个资源。 当最后一个引用被销毁时，资源会被释放。 std::shared_ptr 也可以管理动态数组，但同样需要使用数组删除器，因为它也需要使用 delete[]。 std::shared_ptr 管理动态数组时，通常需要提供一个自定义删除器。 示例：\n1 std::shared_ptr\u0026lt;int\u0026gt; sptr(new int[10], [](int* p){ delete[] p; }); 6.1.主要区别 所有权：\nstd::unique_ptr 强调独占所有权，适合于那些不需要共享资源的场景。 std::shared_ptr 允许多个指针共享同一个资源，适合于资源需要在多个对象间共享的情况。 删除器：\nstd::unique_ptr 和 std::shared_ptr 在管理动态数组时都需要指定数组删除器，因为默认的删除器是 delete，而数组需要 delete[]。 性能：\nstd::unique_ptr 通常比 std::shared_ptr 更轻量级，因为它不涉及引用计数的开销。 std::shared_ptr 由于需要维护引用计数，所以在性能上可能稍微逊色，尤其是在多线程环境中。 线程安全性：\nstd::shared_ptr 的引用计数操作是原子的，适合于多线程环境。 std::unique_ptr 在多线程环境中使用时，通常不需要考虑线程安全问题，因为它的设计就是用于单线程或所有权明确转移的场景。 使用场景：\n当你不需要共享资源时，推荐使用 std::unique_ptr，因为它更高效。 当资源需要在多个对象间共享，或者所有权不明确时，使用 std::shared_ptr。 在选择使用 std::unique_ptr 还是 std::shared_ptr 时，应该根据实际的资源管理和所有权需求来决定。\n7.C++17标准中有哪些新特性可以优化动态数组的内存管理？ 在 C++17 标准中，有几个新特性可以优化动态数组的内存管理：\nstd::shared_ptr 对动态数组的支持： C++17 之前，std::shared_ptr 不支持动态数组类型。在 C++17 中，std::shared_ptr 可以模板化动态数组，并且可以直接使用数组类型的模板参数。这意味着可以直接创建一个 std::shared_ptr\u0026lt;int[]\u0026gt; 来管理动态数组，并且可以使用 std::shared_ptr 的内置函数，如 operator[] 来访问数组元素。\nstd::unique_ptr 的改进： std::unique_ptr 已经支持动态数组，并且在 C++17 中继续提供对动态数组的优化管理。它确保同一时间只能有一个 std::unique_ptr 指向特定资源，从而避免内存泄漏。\nstd::pmr 内存资源库： C++17 引入了 polymorphic memory resources (PMR)，它是一个多态内存分配器的库，允许开发者自定义内存分配策略，这可以用于优化动态数组的内存管理。\n结构化绑定： C++17 引入了结构化绑定，它允许从数组或元组中提取多个成员到不同变量中，这可以简化数组元素的访问和操作。\nif 常量表达式： if constexpr 允许在编译时根据条件编译代码块，这可以用来优化模板代码中的条件逻辑，包括动态数组的处理。\n编译时的类型推导： C++17 允许在函数模板中使用 auto 进行类型推导，这简化了模板代码的编写，尤其是在处理动态数组时。\nconstexpr lambda 表达式： C++17 允许在编译时构建 lambda 表达式，这可以用来创建复杂的编译时计算，包括数组操作。\nstd::apply： std::apply 函数允许调用一个可调用对象，并将一个元组或数组作为参数传递，这可以简化数组或元组的函数调用。\n通过这些特性，C++17 提供了更灵活和高效的方式来管理动态数组的内存，同时减少了内存泄漏的风险，并提高了代码的可读性和可维护性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:05:56+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day8-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/","title":"C++ Practical-2 day8 动态数组"},{"content":"C++ Practical-2 day7 类模板特化之数组 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.类模板特化之数组 在C++中，类模板特化是为特定类型提供一个定制版本的模板类的过程。这在你需要对特定类型进行优化或者添加特定行为时非常有用。\n假设我们有一个通用的数组类模板，我们想要为int类型提供一个特化版本，以添加一些特定于整数的操作，比如计算数组中所有元素的总和。\n1.1.通用数组类模板 首先，我们定义一个通用的数组类模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 template \u0026lt;typename T\u0026gt; class Array { private: T* data; size_t size; public: // 构造函数 Array(size_t size) : size(size), data(new T[size]) {} // 析构函数 ~Array() { delete[] data; } // 获取元素 T\u0026amp; operator[](size_t index) { return data[index]; } // 获取元素（const版本） const T\u0026amp; operator[](size_t index) const { return data[index]; } // 获取数组大小 size_t getSize() const { return size; } // 其他通用操作... }; 1.2.类模板特化 接下来，我们为int类型特化这个数组类模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 特化版本 template \u0026lt;\u0026gt; class Array\u0026lt;int\u0026gt; { private: int* data; size_t size; public: // 构造函数 Array(size_t size) : size(size), data(new int[size]) {} // 析构函数 ~Array() { delete[] data; } // 获取元素 int\u0026amp; operator[](size_t index) { return data[index]; } // 获取元素（const版本） const int\u0026amp; operator[](size_t index) const { return data[index]; } // 获取数组大小 size_t getSize() const { return size; } // 特化操作：计算数组中所有元素的总和 int sum() const { int total = 0; for (size_t i = 0; i \u0026lt; size; ++i) { total += data[i]; } return total; } }; 在这个特化版本中，我们添加了一个sum成员函数，它遍历数组中的所有整数元素并计算它们的总和。\n1.3.使用特化数组类 下面是如何使用这个特化的数组类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main() { // 使用特化版本 Array\u0026lt;int\u0026gt; intArray(5); for (size_t i = 0; i \u0026lt; intArray.getSize(); ++i) { intArray[i] = static_cast\u0026lt;int\u0026gt;(i); } std::cout \u0026lt;\u0026lt; \u0026#34;Sum of elements: \u0026#34; \u0026lt;\u0026lt; intArray.sum() \u0026lt;\u0026lt; std::endl; // 使用通用版本 Array\u0026lt;double\u0026gt; doubleArray(5); for (size_t i = 0; i \u0026lt; doubleArray.getSize(); ++i) { doubleArray[i] = static_cast\u0026lt;double\u0026gt;(i) * 1.5; } // doubleArray没有sum函数 // std::cout \u0026lt;\u0026lt; \u0026#34;Sum of elements: \u0026#34; \u0026lt;\u0026lt; doubleArray.sum() \u0026lt;\u0026lt; std::endl; // 这将导致编译错误 return 0; } 在这个例子中，intArray使用了特化的Array\u0026lt;int\u0026gt;类，因此它有sum函数。而doubleArray使用的是通用的Array\u0026lt;double\u0026gt;类，它没有sum函数。\n1.4.注意事项 类模板特化应该在模板定义之后进行，以确保编译器能够识别特化版本。 特化版本和通用版本应该有相同的接口，以保持一致性。 特化可以针对不同的类型参数，甚至是模板参数的特定组合进行。 通过类模板特化，你可以为特定类型提供定制的行为，从而提高代码的灵活性和性能。\n2.类模板特化在实际项目中有哪些常见的应用场景？ 类模板特化在实际项目中的应用场景非常广泛，它允许开发者为特定类型或特定情况提供定制化的行为。以下是一些常见的应用场景：\n性能优化：\n针对特定数据类型进行优化，比如为int或double类型提供专门的内存管理策略或算法实现。 类型安全：\n为特定的类型提供类型安全的接口，例如，为std::string和char*提供不同的处理方式。 添加特定操作：\n为特定类型添加额外的操作或成员函数，比如为int数组添加求和、求平均值等操作。 处理特殊类型：\n对于特殊的类型，如void指针或函数指针，提供特殊的处理方式。 简化接口：\n为常用的类型提供简化的接口，比如为std::vector或std::list提供定制的迭代器。 兼容性处理：\n为不同的编译器或平台提供不同的实现，以确保代码的兼容性。 实现策略模式：\n在模板类中使用特化来实现策略模式，根据不同的策略类型提供不同的行为。 处理遗留代码：\n为遗留代码中的特定类型提供特化，以便在不修改原有代码的基础上进行扩展。 实现多态：\n为基类和派生类提供不同的实现，利用特化实现多态性。 实现模板元编程：\n在模板元编程中，特化用于实现复杂的编译时计算和决策。 错误处理：\n为特定类型提供错误处理机制，比如为数值类型和字符串类型提供不同的异常处理策略。 资源管理：\n为资源密集型类型（如文件句柄、网络连接）提供定制的资源管理策略。 算法实现：\n为特定类型提供定制的算法实现，比如为float和double提供不同的数值处理算法。 国际化和本地化：\n为不同的语言和地区提供定制化的字符串处理和格式化。 图形和游戏开发：\n为图形库中的特定类型（如颜色、顶点）提供特化，以优化渲染性能。 数据库访问：\n为不同类型的数据库字段（如整数、字符串、日期）提供定制化的访问和处理方式。 网络通信：\n为不同的数据类型（如TCP连接、UDP数据包）提供定制化的网络通信协议处理。 通过类模板特化，开发者可以充分利用C++的类型系统和模板机制，为不同的应用场景提供灵活和高效的解决方案。\n3.如何为类模板特化添加多态性？ 在C++中，为类模板特化添加多态性主要涉及到使用虚函数和基类指针。多态性允许你通过基类指针或引用来调用派生类的方法，这在模板特化中同样适用。\n3.1.步骤1: 定义基类模板 首先，定义一个包含虚函数的基类模板，这个基类模板将被用于后续的特化。\n1 2 3 4 5 6 template \u0026lt;typename T\u0026gt; class Base { public: virtual void display() const = 0; // 纯虚函数 virtual ~Base() {} // 虚析构函数以确保派生类对象的正确清理 }; 3.2.步骤2: 定义派生类模板 定义一个派生类模板，继承自基类模板，并实现基类中的虚函数。\n1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; class Derived : public Base\u0026lt;T\u0026gt; { public: void display() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Displaying Derived class with type: \u0026#34; \u0026lt;\u0026lt; typeid(T).name() \u0026lt;\u0026lt; std::endl; } }; 3.3.步骤3: 特化基类模板 为特定类型特化基类模板。在这个特化版本中，你可以添加特定于该类型的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 特化基类模板 template \u0026lt;\u0026gt; class Base\u0026lt;int\u0026gt; { public: virtual void display() const = 0; virtual ~Base() {} }; // 特化派生类模板 class IntSpecificClass : public Base\u0026lt;int\u0026gt; { public: void display() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Int specific display\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 3.4.步骤4: 使用多态 创建基类指针，指向派生类对象，并通过基类指针调用虚函数来展示多态性。\n1 2 3 4 5 6 7 8 9 10 11 int main() { Base\u0026lt;int\u0026gt;* b = new IntSpecificClass(); b-\u0026gt;display(); // 输出 \u0026#34;Int specific display\u0026#34; delete b; Base\u0026lt;double\u0026gt;* d = new Derived\u0026lt;double\u0026gt;(); d-\u0026gt;display(); // 输出 \u0026#34;Displaying Derived class with type: double\u0026#34; delete d; return 0; } 3.5.说明 基类模板定义了一个接口，包含一个纯虚函数display，这使得它成为一个抽象类。 派生类模板实现了基类模板的接口。 特化基类模板为特定类型（如int）提供了定制的实现。 特化派生类实现了特化基类的接口。 多态性通过基类指针调用虚函数实现，允许在运行时确定调用哪个函数版本。 3.6.注意事项 虚析构函数：确保在删除基类指针时正确调用派生类的析构函数。 类型安全：特化时需要确保类型匹配正确，避免类型错误。 内存管理：使用动态分配时，确保适当地释放内存。 通过这种方式，你可以在模板类中实现多态性，使得代码更加灵活和可扩展。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:05:55+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day7-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%E4%B9%8B%E6%95%B0%E7%BB%84/","title":"C++ Practical-2 day7 类模板特化之数组"},{"content":"C++ Practical-2 day6 类模板之栈 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.类模板之栈 在C++中，使用类模板来实现一个栈（Stack）是一种常见的做法，因为它可以提供类型安全和灵活性。下面是一个简单的栈类模板的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; // for std::out_of_range template \u0026lt;typename T\u0026gt; class Stack { private: // 使用动态数组来存储栈的元素 T* elements; size_t size; size_t capacity; // 动态数组扩容函数 void resize() { capacity = (capacity == 0) ? 1 : (capacity * 2); T* newElements = new T[capacity]; for (size_t i = 0; i \u0026lt; size; ++i) { newElements[i] = elements[i]; } delete[] elements; elements = newElements; } public: // 构造函数 Stack() : size(0), capacity(0), elements(nullptr) {} // 析构函数 ~Stack() { delete[] elements; } // 拷贝构造函数 Stack(const Stack\u0026amp; other) : size(other.size), capacity(other.capacity) { elements = new T[capacity]; for (size_t i = 0; i \u0026lt; size; ++i) { elements[i] = other.elements[i]; } } // 赋值运算符 Stack\u0026amp; operator=(const Stack\u0026amp; other) { if (this != \u0026amp;other) { delete[] elements; size = other.size; capacity = other.capacity; elements = new T[capacity]; for (size_t i = 0; i \u0026lt; size; ++i) { elements[i] = other.elements[i]; } } return *this; } // 检查栈是否为空 bool isEmpty() const { return size == 0; } // 获取栈的大小 size_t getSize() const { return size; } // 入栈操作 void push(const T\u0026amp; element) { if (size == capacity) { resize(); } elements[size++] = element; } // 出栈操作 void pop() { if (isEmpty()) { throw std::out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::pop(): empty stack\u0026#34;); } elements[--size] = T(); } // 获取栈顶元素 T\u0026amp; top() { if (isEmpty()) { throw std::out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::top(): empty stack\u0026#34;); } return elements[size - 1]; } // 获取栈顶元素（const版本） const T\u0026amp; top() const { if (isEmpty()) { throw std::out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::top(): empty stack\u0026#34;); } return elements[size - 1]; } }; int main() { Stack\u0026lt;int\u0026gt; intStack; intStack.push(1); intStack.push(2); intStack.push(3); std::cout \u0026lt;\u0026lt; \u0026#34;Top element: \u0026#34; \u0026lt;\u0026lt; intStack.top() \u0026lt;\u0026lt; std::endl; // 输出 3 intStack.pop(); std::cout \u0026lt;\u0026lt; \u0026#34;New top element: \u0026#34; \u0026lt;\u0026lt; intStack.top() \u0026lt;\u0026lt; std::endl; // 输出 2 return 0; } 这个栈类模板实现了基本的栈操作，包括入栈（push）、出栈（pop）、获取栈顶元素（top）、检查栈是否为空（isEmpty）以及获取栈的大小（getSize）。它使用动态数组来存储元素，并在需要时自动扩容。\n请注意，这个实现是一个简单的示例，实际应用中可能需要更多的错误检查和优化。\n2.如何为这个栈类模板添加一个迭代器接口？ 为栈类模板添加迭代器接口，首先需要定义一个迭代器类，该类能够遍历栈中的元素。由于栈的特性是后进先出（LIFO），迭代器通常不是栈数据结构的一部分，但为了演示如何实现，我们可以添加一个简单的迭代器。\n下面是一个简单的迭代器实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; // for std::out_of_range template \u0026lt;typename T\u0026gt; class Stack { private: T* elements; size_t size; size_t capacity; void resize() { capacity = (capacity == 0) ? 1 : (capacity * 2); T* newElements = new T[capacity]; for (size_t i = 0; i \u0026lt; size; ++i) { newElements[i] = elements[i]; } delete[] elements; elements = newElements; } public: Stack() : size(0), capacity(0), elements(nullptr) {} ~Stack() { delete[] elements; } Stack(const Stack\u0026amp; other) : size(other.size), capacity(other.capacity) { elements = new T[capacity]; for (size_t i = 0; i \u0026lt; size; ++i) { elements[i] = other.elements[i]; } } Stack\u0026amp; operator=(const Stack\u0026amp; other) { if (this != \u0026amp;other) { delete[] elements; size = other.size; capacity = other.capacity; elements = new T[capacity]; for (size_t i = 0; i \u0026lt; size; ++i) { elements[i] = other.elements[i]; } } return *this; } bool isEmpty() const { return size == 0; } size_t getSize() const { return size; } void push(const T\u0026amp; element) { if (size == capacity) { resize(); } elements[size++] = element; } void pop() { if (isEmpty()) { throw std::out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::pop(): empty stack\u0026#34;); } elements[--size] = T(); } T\u0026amp; top() { if (isEmpty()) { throw std::out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::top(): empty stack\u0026#34;); } return elements[size - 1]; } const T\u0026amp; top() const { if (isEmpty()) { throw std::out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::top(): empty stack\u0026#34;); } return elements[size - 1]; } // 迭代器接口 class Iterator { private: const Stack* stack; size_t index; public: Iterator(const Stack* s, size_t idx) : stack(s), index(idx) {} T\u0026amp; operator*() const { return stack-\u0026gt;elements[index]; } T* operator-\u0026gt;() const { return \u0026amp;stack-\u0026gt;elements[index]; } Iterator\u0026amp; operator++() { if (index \u0026gt; 0) index--; return *this; } Iterator operator++(int) { Iterator temp = *this; ++(*this); return temp; } bool operator==(const Iterator\u0026amp; other) const { return index == other.index \u0026amp;\u0026amp; stack == other.stack; } bool operator!=(const Iterator\u0026amp; other) const { return !(*this == other); } }; Iterator begin() const { return Iterator(this, size - 1); } Iterator end() const { return Iterator(this, -1); } }; int main() { Stack\u0026lt;int\u0026gt; intStack; intStack.push(1); intStack.push(2); intStack.push(3); std::cout \u0026lt;\u0026lt; \u0026#34;Stack elements: \u0026#34;; for (Stack\u0026lt;int\u0026gt;::Iterator it = intStack.begin(); it != intStack.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 在这个实现中，我们定义了一个嵌套的Iterator类，它包含了指向栈对象的指针和当前索引。迭代器提供了operator*、operator-\u0026gt;、operator++和比较运算符operator==和operator!=，以支持基本的迭代器操作。\nbegin()和end()成员函数分别返回指向栈顶元素和栈底元素（即栈外一个位置）的迭代器。\n请注意，这个迭代器实现是反向迭代的，因为它从栈顶开始遍历到栈底。在实际应用中，栈通常不提供迭代器，因为迭代器与栈的LIFO特性不相符。如果你需要迭代器，可能需要考虑使用其他数据结构，如列表或向量。\n3.这个栈类模板在性能上有哪些优化空间？ 栈类模板的性能优化可以从多个方面进行考虑，以下是一些常见的优化策略：\n减少内存重新分配：\n当栈的容量不足以容纳新元素时，需要重新分配内存并复制现有元素到新的内存区域。这个过程是昂贵的。可以通过增加初始容量或使用更大的扩容因子来减少扩容的次数。 使用更高效的内存分配策略：\n可以使用内存池来管理内存分配，这样可以减少系统调用和内存碎片。 避免不必要的复制：\n如果元素类型支持移动语义，使用std::move来避免不必要的复制操作。 优化迭代器：\n如果迭代器使用频繁，可以考虑实现更高效的迭代器，比如使用延迟初始化。 减少动态内存分配：\n如果栈的大小是固定的，可以使用静态数组而不是动态数组来存储元素。 使用自定义内存分配器：\n如果栈是程序中频繁使用的数据结构，可以考虑使用自定义的内存分配器来优化性能。 优化数据结构：\n考虑使用链表而不是动态数组来实现栈，这样可以避免内存重新分配的问题。 减少异常抛出：\n在pop和top函数中，如果栈为空，则抛出异常。如果程序中栈为空是一个常见情况，可以考虑返回一个特殊值或使用错误码来避免抛出异常。 使用无锁并发访问：\n如果栈需要在多线程环境中使用，可以考虑实现无锁的数据结构来提高并发性能。 避免使用虚函数：\n如果栈类需要继承，避免使用虚函数，因为它们会增加额外的开销。 减少成员函数的调用：\n对于频繁调用的成员函数，可以考虑内联函数以减少函数调用的开销。 使用模板特化：\n对于特定的数据类型，可以提供特化的实现来优化性能。 减少内存访问：\n优化数据结构的内存布局，减少缓存未命中的可能性。 使用引用计数：\n如果栈中存储的是智能指针，可以考虑使用引用计数来减少内存使用。 避免使用异常处理：\n如果栈操作中可能会抛出异常，可以考虑使用错误码或返回特殊值来处理错误，以避免异常处理的开销。 请注意，优化应该基于实际的性能瓶颈进行。在进行优化之前，最好使用性能分析工具来确定程序的瓶颈所在。\n4.我想在栈中实现一个优先队列，需要对栈类模板做哪些修改？ 实现一个优先队列通常需要根据元素的优先级来出队，而不是遵循先进先出（FIFO）的原则。这意味着我们需要对栈的元素进行排序或者使用其他方法来保证每次出队时都是优先级最高的元素。\n以下是实现优先队列的一些方法：\n4.1. 使用最小堆 最小堆是一种常用的实现优先队列的数据结构。在最小堆中，父节点的值总是小于或等于其子节点的值。这样，堆顶元素就是优先级最高的元素。\n4.2. 使用有序数组或链表 每次插入元素时，将元素插入到数组或链表中的适当位置，以保持元素的有序性。\n4.3. 使用二叉搜索树 使用二叉搜索树（BST），并对其进行平衡，如AVL树或红黑树，可以快速插入、删除和查找元素。\n4.4. 使用斐波那契堆 斐波那契堆是一种高级的数据结构，它在执行减少键值和合并堆操作时非常高效。\n4.5.修改栈类模板 以下是如何修改你的栈类模板以实现一个简单的最小堆优先队列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;vector\u0026gt; template \u0026lt;typename T\u0026gt; class PriorityQueue { private: std::vector\u0026lt;T\u0026gt; elements; // 交换元素 void swap(T\u0026amp; a, T\u0026amp; b) { T temp = a; a = b; b = temp; } // 上浮调整 void siftUp(int index) { while (index \u0026gt; 0) { int parentIndex = (index - 1) / 2; if (elements[index] \u0026lt; elements[parentIndex]) { swap(elements[index], elements[parentIndex]); index = parentIndex; } else { break; } } } // 下沉调整 void siftDown(int index) { int size = elements.size(); int leftChildIndex, rightChildIndex, smallestIndex; while (true) { leftChildIndex = 2 * index + 1; rightChildIndex = 2 * index + 2; smallestIndex = index; if (leftChildIndex \u0026lt; size \u0026amp;\u0026amp; elements[leftChildIndex] \u0026lt; elements[smallestIndex]) { smallestIndex = leftChildIndex; } if (rightChildIndex \u0026lt; size \u0026amp;\u0026amp; elements[rightChildIndex] \u0026lt; elements[smallestIndex]) { smallestIndex = rightChildIndex; } if (smallestIndex != index) { swap(elements[index], elements[smallestIndex]); index = smallestIndex; } else { break; } } } public: void push(const T\u0026amp; element) { elements.push_back(element); siftUp(elements.size() - 1); } void pop() { if (elements.empty()) { throw std::out_of_range(\u0026#34;PriorityQueue\u0026lt;\u0026gt;::pop(): empty queue\u0026#34;); } elements[0] = elements.back(); elements.pop_back(); siftDown(0); } T top() const { if (elements.empty()) { throw std::out_of_range(\u0026#34;PriorityQueue\u0026lt;\u0026gt;::top(): empty queue\u0026#34;); } return elements[0]; } bool isEmpty() const { return elements.empty(); } size_t getSize() const { return elements.size(); } }; int main() { PriorityQueue\u0026lt;int\u0026gt; pq; pq.push(10); pq.push(30); pq.push(20); std::cout \u0026lt;\u0026lt; \u0026#34;Top element: \u0026#34; \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; std::endl; // 输出 10 pq.pop(); std::cout \u0026lt;\u0026lt; \u0026#34;New top element: \u0026#34; \u0026lt;\u0026lt; pq.top() \u0026lt;\u0026lt; std::endl; // 输出 20 return 0; } 4.6.解释 最小堆的表示：\n使用一个动态数组（std::vector）来存储元素。 上浮调整（siftUp）：\n当新元素插入时，将其放在数组的末尾，然后与父节点比较，如果新元素的优先级更高，则与父节点交换位置，直到找到合适的位置。 下沉调整（siftDown）：\n当元素被删除（通常是堆顶元素）时，将数组的第一个元素替换为最后一个元素，然后与子节点比较，如果当前元素的优先级较低，则与子节点交换位置，直到找到合适的位置。 push操作：\n将新元素插入数组的末尾，然后进行上浮调整。 pop操作：\n将数组的第一个元素替换为最后一个元素，然后删除最后一个元素，并对新的第一个元素进行下沉调整。 top操作：\n返回数组的第一个元素，即优先级最高的元素。 isEmpty和getSize操作：\n分别检查队列是否为空和返回队列的大小。 这个实现提供了一个基本的优先队列功能，可以根据需要进行进一步的优化和扩展。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:05:54+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day6-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B9%8B%E6%A0%88/","title":"C++ Practical-2 day6 类模板之栈"},{"content":"C++ Practical-2 day5 模板之函数模板 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.模板之函数模板 函数模板是C++中一种支持泛型编程的工具，它允许你编写与数据类型无关的函数。通过使用模板，你可以创建一个函数，它可以在编译时自动适应任何给定的数据类型。\n1.1.基本语法 1 2 template \u0026lt;typename T\u0026gt; function declaration; template 是声明模板的关键字。 \u0026lt;typename T\u0026gt; 是一个参数列表，其中 T 是一个占位符，表示任何类型。 function declaration 是函数的声明和定义。 1.2.示例 下面是一个简单的函数模板，它交换两个变量的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; // 函数模板声明 template \u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { T temp = a; a = b; b = temp; } int main() { int x = 10; int y = 20; std::cout \u0026lt;\u0026lt; \u0026#34;Before swap: x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; swap(x, y); std::cout \u0026lt;\u0026lt; \u0026#34;After swap: x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; double a = 5.5; double b = 10.5; std::cout \u0026lt;\u0026lt; \u0026#34;Before swap: a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; swap(a, b); std::cout \u0026lt;\u0026lt; \u0026#34;After swap: a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; return 0; } 1.3.模板参数 typename：用于模板参数的类型。在C++11之前，也可以使用 class 关键字。 T：一个占位符，表示任何类型。 1.4.模板特化 模板特化是为特定类型提供特定实现的方法。这在你需要为某些特定类型提供优化或特殊行为时非常有用。\n1.4.1.完全特化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 普通模板 template \u0026lt;typename T\u0026gt; void print(T value) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } // 特化模板 template \u0026lt;\u0026gt; void print\u0026lt;int\u0026gt;(int value) { std::cout \u0026lt;\u0026lt; \u0026#34;Integer: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } int main() { print(10); // 调用特化版本 print(5.5); // 调用普通模板 return 0; } 1.4.2.偏特化 template partial specialization 偏特化通常用于类模板，但也可以通过模板重载实现函数的偏特化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 普通模板 template \u0026lt;typename T1, typename T2\u0026gt; void print(T1 value1, T2 value2) { std::cout \u0026lt;\u0026lt; value1 \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; value2 \u0026lt;\u0026lt; std::endl; } // 偏特化 template \u0026lt;typename T\u0026gt; void print(int value1, T value2) { std::cout \u0026lt;\u0026lt; \u0026#34;Integer and other type: \u0026#34; \u0026lt;\u0026lt; value1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; value2 \u0026lt;\u0026lt; std::endl; } int main() { print(10, 5.5); // 调用偏特化 print(5.5, 10); // 调用普通模板 return 0; } 1.5.模板的注意事项 编译时多态：模板在编译时进行类型检查和代码生成，这称为编译时多态。 类型推导：编译器可以根据函数调用的参数类型自动推导出模板参数。 代码膨胀：每个模板实例都会生成独立的代码，这可能导致二进制文件变大。 模板元编程：模板不仅可以用于泛型编程，还可以用于模板元编程，这是一种在编译时执行计算的技术。 通过使用函数模板，你可以编写更加通用和灵活的代码。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:05:53+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day5-%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/","title":"C++ Practical-2 day5 模板之函数模板"},{"content":"C++ Practical-2 day4 运算符重载之输入输出运算符重载 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.运算符重载之输入输出运算符重载 在C++中，重载输入输出运算符（operator\u0026lt;\u0026lt; 和 operator\u0026gt;\u0026gt;）可以让你自定义类的对象与标准输入输出流（如 std::cout 和 std::cin）之间的交互方式。这使得你的类的对象可以像内置类型一样直接与输入输出流进行交互。\n1.1.重载输出运算符 \u0026lt;\u0026lt; 1.1.1.语法 1 friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const 类名\u0026amp; obj); 1.1.2.示例 假设你有一个 Point 类，你想通过 std::cout 打印它的坐标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; class Point { private: int x, y; public: Point(int x, int y) : x(x), y(y) {} // 重载输出运算符 friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Point\u0026amp; p) { os \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; return os; } }; int main() { Point p(10, 20); std::cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; return 0; } 1.2.重载输入运算符 \u0026gt;\u0026gt; 1.2.1.语法 1 friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, 类名\u0026amp; obj); 1.2.2.示例 继续使用 Point 类，你可以定义一个输入运算符，允许从 std::cin 读取坐标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; class Point { private: int x, y; public: Point() : x(0), y(0) {} // 重载输入运算符 friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, Point\u0026amp; p) { is \u0026gt;\u0026gt; p.x \u0026gt;\u0026gt; p.y; return is; } // 重载输出运算符 friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Point\u0026amp; p) { os \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; return os; } }; int main() { Point p; std::cout \u0026lt;\u0026lt; \u0026#34;Enter coordinates of the point (x y): \u0026#34;; std::cin \u0026gt;\u0026gt; p; std::cout \u0026lt;\u0026lt; \u0026#34;You entered: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; return 0; } 1.3.注意事项 友元函数：输入输出运算符通常定义为类的友元函数，这样它们就可以访问类的私有成员。 返回类型：输入输出运算符应该返回对流的引用，以便可以链式调用。 异常处理：在处理输入输出时，应该考虑异常处理，例如输入不合法的情况。 效率：直接操作流可以提高效率，因为避免了额外的字符串转换。 通过重载输入输出运算符，你的类将更加易于使用，代码可读性也会提高。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:05:52+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day4-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B9%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","title":"C++ Practical-2 day4 运算符重载之输入输出运算符重载"},{"content":"C++ Practical-2 day3 运算符重载之强制转换 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.运算符重载之强制转换 在C++中，运算符重载允许你定义或修改大多数运算符的行为，以适应你自己的类。对于强制类型转换，C++提供了两种方式：类型转换运算符和转换构造函数。\n1.1.类型转换运算符 类型转换运算符允许你定义一个运算符，使得你的类的对象可以自动转换为特定的类型。这通常是通过重载 operator 关键字实现的。\n1.1.1.语法 1 2 3 operator TypeName() const { // 转换逻辑 } 1.1.2.示例 假设你有一个类 Distance，你想让它可以自动转换为 double 类型，表示距离的数值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Distance { private: double meters; public: Distance(double m) : meters(m) {} // 重载类型转换运算符为double operator double() const { return meters; } }; int main() { Distance d(10.5); double length = d; // 自动调用operator double() return 0; } 1.2.转换构造函数 转换构造函数是一种特殊的构造函数，它允许对象在需要时自动转换为另一种类型。它通常用于类之间的隐式转换。\n1.2.1.语法 1 class_name(Type type); 1.2.2.示例 继续使用上面的 Distance 类，我们可以定义一个转换构造函数，允许从 double 类型隐式转换为 Distance 对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Distance { private: double meters; public: Distance(double m) : meters(m) { } // 方法一：转换构造函数 // Distance(const double \u0026amp;m) : meters(m) { // } // 方法二：重载类型转换运算符为double operator double() const { return meters; } // 方法一，方法二会冲突，注释其中一个即可 }; int main() { Distance d(10.5); double length = d; // 自动调用operator double() Distance d2 = 20.0; // 自动调用转换构造函数 return 0; } 问题解释\n当您尝试使用 Distance d2 = 20.0; 时，编译器发现两个构造函数都可以用来从 double 类型的参数构造 Distance 对象：\nDistance(double m)：直接接受 double 参数。 Distance(const double \u0026amp;m)：接受 double 的引用。 由于这两个构造函数在功能上是相同的，编译器无法决定使用哪一个，因此报错。 解决方案\n您应该只保留一个构造函数，通常，转换构造函数应该接受一个引用参数，以避免不必要的复制，但在这个特定情况下，由于您已经有了一个接受 double 参数的构造函数，转换构造函数是多余的。\n1.3.注意事项 隐式转换：类型转换运算符默认是隐式的，这意味着它们可以在没有显式转换的情况下被调用。如果你不希望这样，可以在运算符前面加上 explicit 关键字，使其变为显式转换。 使用场景：类型转换运算符应该谨慎使用，因为它们可能会导致代码难以理解和维护。通常，只有当你的类确实需要与内置类型无缝交互时，才使用类型转换运算符。 性能：类型转换可能会影响性能，特别是在频繁调用的情况下。 通过这些方法，你可以为你的类定义合适的类型转换行为，使其更加灵活和强大。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:05:51+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day3-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B9%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/","title":"C++ Practical-2 day3 运算符重载之强制转换"},{"content":"C++ Practical-2 day2 运算符重载之时钟类++运算符 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 clock_overloading 1.时间类 重载后缀++运算符来递增时间 在C++中创建一个时钟类并重载函数调用运算符()，可以使得该类的实例可以像函数一样被调用，以执行特定的操作，比如获取当前时间、设置时间等。\n下面是一个简单的示例，展示如何定义一个时钟类，该类重载了函数调用运算符来获取当前时间：\n为了实现通过重载后缀++运算符来递增时间，我们需要在Clock类中添加一个特殊的成员函数。这个成员函数将实现后缀递增操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;iostream\u0026gt; #include \u0026lt;ctime\u0026gt; class Clock { private: time_t currentTime; public: // 构造函数 Clock() { currentTime = time(0); // 初始化为当前时间 } // 重载()运算符，返回当前时间的字符串表示 std::string operator()() const { // 保持const tm *ltm = localtime(\u0026amp;currentTime); // 转换为本地时间 char buffer[80]; strftime(buffer, 80, \u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;, ltm); // 格式化时间 return std::string(buffer); } // 设置时间 void setTime(time_t newTime) { currentTime = newTime; } // 获取时间 time_t getTime() const { return currentTime; } // 计算两个时间点之间的差异（秒） double timeDifference(const Clock \u0026amp;other) const { return difftime(other.currentTime, currentTime); } // 时间递增 void incrementTime(int seconds) { currentTime += seconds; } // 重载前置++运算符 Clock\u0026amp; operator++() { incrementTime(1); // 递增1秒 return *this; } // 重载后置++运算符 Clock operator++(int) { Clock temp = *this; // 保存当前状态 incrementTime(1); // 递增1秒 return temp; // 返回递增前的状态 } }; int main() { Clock myClock; std::cout \u0026lt;\u0026lt; \u0026#34;Current time: \u0026#34; \u0026lt;\u0026lt; myClock() \u0026lt;\u0026lt; std::endl; // 手动设置时间 myClock.setTime(time(0)); // 重新设置为当前时间 std::cout \u0026lt;\u0026lt; \u0026#34;Current time after setting: \u0026#34; \u0026lt;\u0026lt; myClock() \u0026lt;\u0026lt; std::endl; // 创建另一个时钟实例 Clock anotherClock; anotherClock.setTime(time(0) + 3600); // 设置为当前时间1小时后 // 计算两个时间点之间的差异 double diff = myClock.timeDifference(anotherClock); std::cout \u0026lt;\u0026lt; \u0026#34;Time difference: \u0026#34; \u0026lt;\u0026lt; diff \u0026lt;\u0026lt; \u0026#34; seconds\u0026#34; \u0026lt;\u0026lt; std::endl; // 使用后置++运算符递增时间 myClock++; std::cout \u0026lt;\u0026lt; \u0026#34;Current time after incrementing: \u0026#34; \u0026lt;\u0026lt; myClock() \u0026lt;\u0026lt; std::endl; return 0; } 1.1.解释 重载后缀++运算符：\n功能：实现后缀递增操作，即每次调用myClock++时，currentTime递增1秒。 返回值：返回Clock对象的引用，允许链式调用。 main函数：\n创建Clock类的实例myClock。 使用重载的()运算符获取并打印当前时间。 手动设置时间，并再次打印当前时间。 计算两个时间点之间的差异，并打印结果。 使用后缀++运算符递增时间，并打印递增后的时间。 Clock类：\n私有成员变量：currentTime，用于存储时间。 构造函数：初始化currentTime为当前时间。 重载的()运算符：返回当前时间的字符串表示。它使用time()函数获取当前时间，然后使用localtime()将其转换为本地时间，最后使用strftime()格式化时间字符串。 setTime成员函数：允许设置时间。 getTime成员函数：返回当前时间。 通过这种方式，Clock类现在可以通过重载后缀++运算符来递增时间，使得代码更加简洁和直观。\n1.2.注意事项 const修饰符：如果你的重载的()运算符不会修改对象的状态，你应该在函数声明的末尾添加const关键字，以表明这个成员函数不会修改对象的任何成员变量。\n参数：你可以为()运算符提供参数，比如设置时间。\n返回类型：你需要指定函数调用的返回类型。\n通过这种方式，你可以创建一个非常灵活的时钟类，该类的对象可以像函数一样被调用，以执行特定的操作。\n2.如何确保时间递增操作在多线程环境中是线程安全的？ 为了确保时间递增操作在多线程环境中是线程安全的，我们需要确保当多个线程尝试同时修改时间时，这些修改不会相互干扰，导致数据不一致。这通常涉及到使用同步机制，如互斥锁（mutexes），来保护对共享资源的访问。\n以下是一些确保线程安全的方法：\n使用互斥锁（Mutex）： 在C++中，可以使用std::mutex来确保只有一个线程可以同时修改时间。在递增时间的函数中，我们需要在修改时间之前获取锁，并在修改后释放锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;string\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;ctime\u0026gt; class Clock { private: time_t currentTime; mutable std::mutex mtx; // 使用mutable因为mtx在const成员函数中使用 public: Clock() { currentTime = time(0); } // 重载()运算符 std::string operator()() const { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); // 使用lock_guard自动加锁和解锁 tm *ltm = localtime(\u0026amp;currentTime); char buffer[80]; strftime(buffer, 80, \u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;, ltm); return std::string(buffer); } // 线程安全的时间递增 void incrementTime(int seconds) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); currentTime += seconds; } // 重载后缀++运算符 Clock \u0026amp;operator++() { incrementTime(1); return *this; } }; 使用原子操作： 如果时间递增操作可以被设计为原子操作，那么可以使用std::atomic来确保操作的原子性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;atomic\u0026gt; #include \u0026lt;ctime\u0026gt; class Clock { private: std::atomic\u0026lt;time_t\u0026gt; currentTime; public: Clock() { currentTime.store(time(0)); } void incrementTime(int seconds) { currentTime.fetch_add(seconds, std::memory_order_relaxed); } Clock\u0026amp; operator++() { incrementTime(1); return *this; } }; 使用条件变量： 如果需要更复杂的线程间协调，可以使用std::condition_variable来等待和通知时间变化。\n避免共享： 如果可能，避免共享时间对象，每个线程可以使用本地时间副本，然后定期同步。\n使用线程安全的类： 使用标准库中已经保证线程安全的类，如std::chrono中的一些类。\n确保线程安全通常需要仔细设计，并且在多线程程序中进行充分的测试，以确保没有死锁或竞态条件。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:05:50+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day2-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B9%8B%E6%97%B6%E9%92%9F%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"C++ Practical-2 day2 运算符重载之时钟类++运算符"},{"content":"C++ Practical-2 day1 重载函数调用运算符() 中括号 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.重载函数调用运算符() 中括号 在C++中，重载函数调用运算符()允许对象像函数一样被调用。这在设计模式中非常有用，特别是在实现工厂模式或者需要模拟函数指针时。\n1.1.重载函数调用运算符的规则 成员函数：运算符()必须作为成员函数重载。 无参数：运算符()不接受任何参数。 返回值：必须指定返回类型，通常是类本身或者一个函数指针。 1.2.示例1：重载()运算符用于模拟函数指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; class FunctionWrapper { public: // 存储一个可调用对象 std::function\u0026lt;void()\u0026gt; func; // 构造函数 FunctionWrapper(std::function\u0026lt;void()\u0026gt; f) : func(f) {} // 重载函数调用运算符 void operator()() { func(); } }; int main() { // 创建一个lambda表达式 auto lambda = []() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; }; // 创建FunctionWrapper对象 FunctionWrapper wrapper(lambda); // 使用重载的()运算符调用 wrapper(); // 输出: Hello, World! return 0; } 1.3.示例2：重载()运算符用于创建工厂对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; class StringFactory { public: // 重载函数调用运算符 std::string operator()(const std::string\u0026amp; str) const { return str; } }; int main() { StringFactory factory; std::string result = factory(\u0026#34;Hello, Factory!\u0026#34;); std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; // 输出: Hello, Factory! return 0; } 1.4.注意事项 返回类型：根据需要返回适当的类型，如果需要链式调用，则返回对象本身的引用。\nconst成员函数：如果重载的()运算符不应该修改对象的状态，应该将其声明为const。\n异常安全：确保在调用过程中即使发生异常，对象也保持有效状态。\n资源管理：如果运算符()涉及到资源管理，确保资源被正确分配和释放。\n通过重载函数调用运算符()，可以使对象的使用更加灵活和表达式更加简洁。\n2.重载函数调用运算符() 在C++中，重载函数调用运算符()允许一个对象像函数一样被调用。这通常用于创建类似于函数的对象，或者让对象能够执行某些操作。\n以下是重载函数调用运算符的一般形式：\n1 2 3 4 5 6 7 class MyClass { public: // 重载()运算符 returnType operator()(arg1Type arg1, arg2Type arg2, ...) const { // 函数体 } }; 这里的MyClass是一个类，operator()是成员函数，它重载了()运算符。returnType是函数调用的返回类型，arg1Type、arg2Type等是参数的类型。\n2.1.示例 假设我们有一个类Counter，我们希望创建一个对象，该对象可以像函数一样被调用，并且每次调用都会增加计数器的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; class Counter { private: int count; public: // 构造函数 Counter() : count(0) {} // 重载()运算符 int operator()() { return ++count; } }; int main() { Counter myCounter; std::cout \u0026lt;\u0026lt; myCounter() \u0026lt;\u0026lt; std::endl; // 输出 1 std::cout \u0026lt;\u0026lt; myCounter() \u0026lt;\u0026lt; std::endl; // 输出 2 std::cout \u0026lt;\u0026lt; myCounter() \u0026lt;\u0026lt; std::endl; // 输出 3 return 0; } 在这个例子中，每次调用myCounter()都会增加count的值，并返回新的值。\n2.2.注意事项 const修饰符：如果你的重载的()运算符不会修改对象的状态，你应该在函数声明的末尾添加const关键字，以表明这个成员函数不会修改对象的任何成员变量。\n参数：你可以为()运算符提供参数，就像普通函数一样。\n返回类型：你需要指定函数调用的返回类型。\n成员函数：operator()是一个成员函数，因此它可以直接访问对象的成员变量和成员函数。\n通过重载函数调用运算符，你可以创建出非常灵活和强大的类，这些类的对象可以像函数一样被调用。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T01:05:49+08:00","permalink":"https://wesigj.github.io/p/c-practical-2-day1-%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%B8%AD%E6%8B%AC%E5%8F%B7/","title":"C++ Practical-2 day1 重载函数调用运算符`()` 中括号"},{"content":"C++ Practical-1 day10 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.文件流std::ifstream std::ofstream 在C++中处理文件通常涉及到使用标准库中的文件流类，如std::ifstream（输入文件流）和std::ofstream（输出文件流）。以下是如何在C++中打开、读取、写入和关闭文件的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; int main() { // 定义文件名 const std::string filename = \u0026#34;example.txt\u0026#34;; // 创建输出文件流对象，用于写入文件 std::ofstream outFile(filename); // 检查文件是否成功打开 if (!outFile.is_open()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to open \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; \u0026#34; for writing.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // 写入内容到文件 outFile \u0026lt;\u0026lt; \u0026#34;Hello, World!\\n\u0026#34;; outFile \u0026lt;\u0026lt; \u0026#34;This is a simple C++ file operation example.\\n\u0026#34;; // 关闭文件 outFile.close(); // 创建输入文件流对象，用于读取文件 std::ifstream inFile(filename); // 检查文件是否成功打开 if (!inFile.is_open()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to open \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; \u0026#34; for reading.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // 读取文件内容 std::string line; while (std::getline(inFile, line)) { std::cout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; std::endl; } // 关闭文件 inFile.close(); return 0; } 在这个示例中，我们首先创建了一个名为example.txt的文件，并使用std::ofstream向其中写入了一些文本。写入完成后，我们关闭了文件。然后，我们使用std::ifstream打开同一个文件，并读取其内容，将其打印到标准输出。\n1.1.异常处理 在文件操作中，异常处理非常重要，因为文件可能因为各种原因（如权限问题、磁盘空间不足等）无法打开或写入。以下是如何在文件操作中添加异常处理的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;exception\u0026gt; int main() { try { const std::string filename = \u0026#34;example.txt\u0026#34;; // 创建输出文件流对象，用于写入文件 std::ofstream outFile(filename); if (!outFile.is_open()) { throw std::runtime_error(\u0026#34;Failed to open \u0026#34; + filename + \u0026#34; for writing.\u0026#34;); } outFile \u0026lt;\u0026lt; \u0026#34;Hello, World!\\n\u0026#34;; outFile \u0026lt;\u0026lt; \u0026#34;This is a simple C++ file operation example.\\n\u0026#34;; outFile.close(); // 创建输入文件流对象，用于读取文件 std::ifstream inFile(filename); if (!inFile.is_open()) { throw std::runtime_error(\u0026#34;Failed to open \u0026#34; + filename + \u0026#34; for reading.\u0026#34;); } std::string line; while (std::getline(inFile, line)) { std::cout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; std::endl; } inFile.close(); } catch (const std::exception\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Exception occurred: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; return 1; } return 0; } 在这个示例中，我们使用了try-catch块来捕获可能发生的异常。如果在打开文件或写入文件时发生异常，程序将捕获异常并打印错误信息。\n1.2.注意事项 确保关闭文件：在文件操作完成后，确保调用close()方法关闭文件。 异常处理：使用try-catch块来处理可能的异常。 检查文件是否成功打开：在进行文件读写操作之前，检查文件流对象是否成功打开了文件。 这些基本的文件操作和异常处理技巧可以帮助你安全地在C++中处理文件。\n2.文件流追加std::ofstream std::ios::app 在C++中，要进行文件的追加操作，你可以使用std::ofstream类的构造函数，并在其中指定打开文件的模式为追加模式。追加模式可以通过传递std::ios::app标志来设置。\n以下是如何使用std::ofstream以追加模式打开文件并写入内容的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;string\u0026gt; int main() { // 定义文件名 const std::string filename = \u0026#34;example.txt\u0026#34;; // 创建输出文件流对象，以追加模式打开文件 std::ofstream outFile(filename, std::ios::app); // 检查文件是否成功打开 if (!outFile.is_open()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to open \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; \u0026#34; for appending.\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } // 写入内容到文件末尾 outFile \u0026lt;\u0026lt; \u0026#34;This line will be appended to the end of the file.\\n\u0026#34;; // 关闭文件 outFile.close(); return 0; } 在这个示例中，我们创建了一个std::ofstream对象，并在构造函数中传递了std::ios::app标志，这告诉文件流以追加模式打开文件。如果文件已经存在，写入操作将从文件的末尾开始，而不是覆盖现有内容。如果文件不存在，它将被创建。\n2.1.注意事项 文件指针位置：在追加模式下，文件指针初始位置在文件末尾，所以写入操作总是追加到文件的末尾。 文件不存在时的行为：如果指定的文件不存在，以追加模式打开文件流将会创建该文件。 关闭文件：虽然文件流的析构函数会在对象超出作用域时自动关闭文件，但显式调用close()方法是一个好习惯，尤其是在你还需要检查文件是否成功关闭的情况下。 异常处理：考虑在文件操作中添加异常处理，以处理可能发生的错误。 使用追加模式是处理日志文件或其他需要持续添加数据的场景的常用方法。\n3.文件的特定位置插入内容，而不是追加 在C++中，如果你想在文件的特定位置插入内容，而不是追加到文件末尾，你需要执行以下步骤：\n读取文件内容：首先，读取整个文件内容到内存中。 修改内容：在内存中修改内容，插入所需的文本。 写入文件：将修改后的内容写回文件，覆盖原始内容。 以下是一个示例，展示了如何在文件的特定位置插入内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;string\u0026gt; bool insertText(const std::string \u0026amp;filename, const std::string \u0026amp;insertText, int position) { std::ifstream inFile(filename, std::ios::in | std::ios::binary); if (!inFile.is_open()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to open \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; \u0026#34; for reading.\u0026#34; \u0026lt;\u0026lt; std::endl; return false; } // 读取文件内容到字符串 std::stringstream buffer; buffer \u0026lt;\u0026lt; inFile.rdbuf(); std::string fileContent = buffer.str(); inFile.close(); // 检查插入位置是否有效 if (position \u0026lt; 0 || position \u0026gt; static_cast\u0026lt;int\u0026gt;(fileContent.size())) { std::cerr \u0026lt;\u0026lt; \u0026#34;Invalid position for insertion.\u0026#34; \u0026lt;\u0026lt; std::endl; return false; } // 在特定位置插入文本 std::string modifiedContent = fileContent.substr(0, position) + insertText + fileContent.substr(position); // 将修改后的内容写回文件 std::ofstream outFile(filename, std::ios::out | std::ios::trunc | std::ios::binary); if (!outFile.is_open()) { std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to open \u0026#34; \u0026lt;\u0026lt; filename \u0026lt;\u0026lt; \u0026#34; for writing.\u0026#34; \u0026lt;\u0026lt; std::endl; return false; } outFile.write(modifiedContent.c_str(), modifiedContent.size()); outFile.close(); return true; } int main() { const std::string filename = \u0026#34;example.txt\u0026#34;; const std::string insertText_temp = \u0026#34;Inserted Text: \u0026#34;; int position = 10; // 插入位置 if (insertText(filename, insertText_temp, position)) { std::cout \u0026lt;\u0026lt; \u0026#34;Text inserted successfully.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Failed to insert text.\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 在这个示例中，我们定义了一个insertText函数，它接受文件名、要插入的文本和插入位置作为参数。函数首先以读取模式打开文件，并读取文件内容到一个字符串中。然后，它检查插入位置是否有效，并在指定位置插入文本。最后，它以写入模式打开文件，并写入修改后的内容，覆盖原始文件。\n3.1.注意事项 文件大小：如果文件非常大，将整个文件内容读入内存可能会导致内存不足的问题。 二进制模式：在处理非文本文件时，使用std::ios::binary标志以确保正确处理文件内容。 错误处理：确保在文件操作中添加异常处理和错误检查。 性能：对于大文件，这种操作可能会很慢，因为它需要读取和重写整个文件内容。 这种方法适用于需要在文件的特定位置插入内容的场景，但需要注意文件大小和内存使用。\n4.文件中查找特定内容，有没有推荐的算法或工具？ 在C++中，如果你想在文件中查找特定内容，有几种方法可以考虑：\n线性搜索：这是最直接的方法，即从文件的开始逐字节或逐行读取，直到找到所需的内容。这种方法简单但效率不高，特别是对于大文件。\n使用标准库：C++标准库提供了一些工具，如std::string::find，可以用来在字符串中搜索子串。如果你正在处理文本文件，你可以读取文件到一个字符串中，然后使用这种方法。\n使用文件流：通过std::ifstream和std::ofstream类进行文件的读取和写入操作。你可以逐行读取文件内容，并使用std::string::find来查找特定的字符串。\n使用第三方库：例如，使用Boost库中的算法，或者专门的文本搜索库，如igotocode.com上提到的文本搜索算法。\n分块查找：如果文件非常大，可以考虑将文件分成多个块，并在每个块中进行搜索。这种方法可以减少内存消耗，并可能通过并行处理提高效率。\n二分查找：如果你正在处理一个已排序的文件，可以使用二分查找算法来提高搜索效率。\n使用操作系统工具：在某些情况下，使用操作系统提供的命令行工具（如Linux的grep）可能更简单、更快。\n使用专业软件：对于非常大的文件，可能需要使用专业的文本搜索工具，如Everything、Listary或AnyTXT Searcher，这些工具能够建立文件内容的索引并快速搜索。\n选择哪种方法取决于你的具体需求，包括文件大小、是否需要频繁搜索、是否可以接受外部依赖等。对于大多数简单用途，使用C++标准库中的文件流和字符串搜索功能可能就足够了。\n5.使用文件流进行文件追加操作时，如何避免潜在的文件锁定问题？ 在C++中，进行文件追加操作时，通常使用std::ofstream类的构造函数或open成员函数，并结合ios::app模式标志。这种方式下，所有写入操作都会自动定位到文件末尾，从而实现追加，而不会覆盖现有内容。\n为了避免潜在的文件锁定问题，特别是在多线程或多进程环境中，可以采取以下措施：\n使用ios::app模式打开文件：这确保了写入操作不会影响文件的其他部分。\n1 std::ofstream outFile(\u0026#34;filename.txt\u0026#34;, std::ios::app); 确保线程安全：在多线程环境中，确保对文件的写入操作是线程安全的。如果多个线程需要写入同一个文件，可以使用互斥量（std::mutex）来同步访问。\n1 2 3 4 std::mutex fileMutex; // 在写入之前锁定互斥量 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(fileMutex); outFile \u0026lt;\u0026lt; \u0026#34;Some data\u0026#34; \u0026lt;\u0026lt; std::endl; 避免在持有锁时进行长时间操作：如果你需要对文件执行复杂的写入操作，尽量避免在持有锁的状态下进行，这样可以减少锁的争用。\n使用文件锁：在Unix/Linux系统上，可以使用flock或fcntl来实现文件锁，以防止多个进程同时写入同一个文件。这通常在涉及到多进程而非多线程时使用。\n1 2 3 4 5 6 #include \u0026lt;fcntl.h\u0026gt; int fd = open(\u0026#34;filename.txt\u0026#34;, O_RDWR | O_CREAT, 0666); flock(fd, LOCK_EX); // 独占锁 // 执行写入操作 flock(fd, LOCK_UN); // 解锁 close(fd); 使用C++17文件系统库：C++17引入了std::filesystem库，它提供了更高级的文件操作功能，包括文件锁等。\n考虑使用第三方库：如果标准库提供的功能不足以满足需求，可以考虑使用第三方库，如Boost库中的文件锁机制。\n避免频繁的文件操作：频繁地打开和关闭文件会增加锁的开销。如果可能，尝试批量处理文件写入操作。\n使用RAII机制管理资源：确保文件在不再需要时能够被正确关闭。这可以通过对象的析构函数来自动完成。\n通过上述措施，你可以有效地避免文件锁定问题，确保文件追加操作的安全性和效率。\n6.函数get和getline读取数据 在C++中，get和getline是两个用于从输入流中读取数据的函数，它们通常与istream类的对象（如cin、ifstream）一起使用。这两个函数的主要区别在于它们处理空格和换行符的方式。\n6.1.get() get()函数用于从输入流中读取字符，直到遇到换行符或EOF（文件结束标志）。它会自动忽略前面的空白字符（包括空格、制表符和换行符），然后开始读取，直到遇到下一个换行符或EOF。get()函数可以用于读取单个字符或字符数组。\n读取单个字符：\n1 2 int c; cin.get(c); 读取字符数组：\n1 2 3 4 char buffer[100]; cin.get(buffer, 100); // 或者 cin \u0026gt;\u0026gt; buffer; 注意：使用\u0026gt;\u0026gt;运算符和get()函数读取字符数组的效果是一样的。\n6.2.getline() getline()函数用于从输入流中读取一行数据，直到遇到换行符。它会将换行符也读取到字符串中，但通常在将字符串存储到std::string对象或字符数组时，换行符会被自动去除。getline()函数只能用于读取std::string对象或字符数组。\n读取到std::string对象：\n1 2 std::string line; getline(cin, line); 读取到字符数组：\n1 2 char buffer[100]; cin.getline(buffer, 100); 注意：cin.getline()是istream类的成员函数，它与全局函数getline()不同。cin.getline()不会自动去除换行符。\n6.3.区别总结 get()可以读取单个字符或字符数组，而getline()只能读取到std::string对象或字符数组。 get()会忽略前面的空白字符，而getline()不会忽略任何字符，包括前面的空白字符。 getline()会读取换行符之前的整行数据，而get()会读取到第一个换行符为止的数据。 6.4.示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::string line; // 使用getline读取一行 std::cout \u0026lt;\u0026lt; \u0026#34;Enter a line: \u0026#34;; getline(std::cin, line); std::cout \u0026lt;\u0026lt; \u0026#34;You entered: \u0026#34; \u0026lt;\u0026lt; line \u0026lt;\u0026lt; std::endl; // 使用get读取字符数组 char buffer[100]; std::cout \u0026lt;\u0026lt; \u0026#34;Enter a word: \u0026#34;; std::cin.get(buffer, 100); std::cout \u0026lt;\u0026lt; \u0026#34;You entered: \u0026#34; \u0026lt;\u0026lt; buffer \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，getline()用于读取用户输入的一整行数据，而get()用于读取用户输入的单个单词。注意，在调用get()之前，可能需要使用cin.ignore()来忽略前一个输入留在输入流中的换行符。\n7.在C++中，除了get和getline，还有哪些其他方式可以读取用户输入？ 在C++中，除了get和getline，还有多种其他方式可以读取用户输入。以下是一些常用的方法：\n使用cin和流提取运算符\u0026gt;\u0026gt;： 这是最常用的读取输入的方法，可以用于读取基本数据类型和自定义类型（只要它们重载了\u0026gt;\u0026gt;运算符）。\n1 2 3 int num; std::cout \u0026lt;\u0026lt; \u0026#34;Enter a number: \u0026#34;; std::cin \u0026gt;\u0026gt; num; 使用scanf函数： C语言中的scanf函数也可以用来在C++中读取输入。它提供了格式化的输入。\n1 2 printf(\u0026#34;Enter a number: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); 使用istream类的成员函数read： read函数用于读取指定数量的字符到字符数组中。\n1 2 char buffer[100]; std::cin.read(buffer, sizeof(buffer)); 使用istream类的成员函数ignore： ignore函数用于忽略输入流中的指定数量的字符，或者直到遇到特定的分隔符。\n1 std::cin.ignore(std::numeric_limits\u0026lt;std::streamsize\u0026gt;::max(), \u0026#39;\\n\u0026#39;); 使用istream类的成员函数get： get函数用于读取下一个字符（不读取换行符）。\n1 2 char ch; std::cin.get(ch); 使用istream类的成员函数peek： peek函数用于查看下一个字符，但不从流中移除它。\n1 int c = std::cin.peek(); 使用istream类的成员函数unget： unget函数用于将一个字符放回输入流中（通常用于错误恢复）。\n1 std::cin.unget(); 使用std::string类的成员函数assign： 可以从字符串流中读取一行或整个文件到std::string对象中。\n1 2 std::string line; std::getline(std::cin, line); 使用std::stringstream： 可以将输入读取到std::stringstream对象中，然后使用流提取运算符\u0026gt;\u0026gt;或getline读取到所需的变量中。\n1 2 3 4 5 std::string input; std::cin \u0026gt;\u0026gt; input; std::stringstream ss(input); int num; ss \u0026gt;\u0026gt; num; 使用std::vector和循环： 对于复杂的输入，如读取多个值，可以使用循环和std::vector。\n1 2 3 4 5 std::vector\u0026lt;int\u0026gt; numbers; int num; while (std::cin \u0026gt;\u0026gt; num) { numbers.push_back(num); } 使用\u0026lt;conio.h\u0026gt;库中的getch或getche： 在Windows系统中，可以使用getch或getche函数读取单个字符，而不需要按回车键。\n1 2 #include \u0026lt;conio.h\u0026gt; char ch = _getch(); 使用\u0026lt;iostream\u0026gt;和\u0026lt;sstream\u0026gt;库： 可以将输入读取到std::istringstream对象中，然后从中提取数据。\n1 2 3 4 5 std::string input; std::cin \u0026gt;\u0026gt; input; std::istringstream iss(input); int num; iss \u0026gt;\u0026gt; num; 这些方法可以根据不同的应用场景和需求选择使用。\n8.std::cout 在C++中，cout 是标准库中的一个非常基本和常用的对象，它代表标准输出流。它通常用于将数据输出到控制台（屏幕）。cout 是 std 命名空间中的 ostream 类的一个实例，因此它支持插入运算符 (\u0026lt;\u0026lt;)，可以与各种数据类型一起使用来输出数据。\n以下是一些使用 cout 输出数据的基本示例：\n8.1.输出文本和变量 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; int main() { int num = 10; double pi = 3.14159; std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;The value of num is: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;The value of pi is: \u0026#34; \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; return 0; } 8.2.输出不同的数据类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; int main() { bool isTrue = true; char ch = \u0026#39;A\u0026#39;; int age = 30; double salary = 55000.50; std::cout \u0026lt;\u0026lt; \u0026#34;Boolean: \u0026#34; \u0026lt;\u0026lt; isTrue \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Character: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Salary: \u0026#34; \u0026lt;\u0026lt; salary \u0026lt;\u0026lt; std::endl; return 0; } 8.3.使用操纵符（Manipulators） C++提供了一些操纵符来控制输出格式，例如 std::setw 设置字段宽度，std::setprecision 设置浮点数的精度等。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; int main() { double pi = 3.14159; std::cout \u0026lt;\u0026lt; \u0026#34;Default precision: \u0026#34; \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2) \u0026lt;\u0026lt; \u0026#34;Fixed precision: \u0026#34; \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; \u0026#34;Width: \u0026#34; \u0026lt;\u0026lt; std::left \u0026lt;\u0026lt; \u0026#34;Left aligned.\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 8.4.输出字符串和字符 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; int main() { std::string name = \u0026#34;John Doe\u0026#34;; char ch = \u0026#39;A\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Character: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; std::endl; return 0; } 8.5.输出未定义流宽度的类型 对于像 std::endl 这样的流操纵符，或者像 std::flush 这样的函数，不需要指定变量，因为它们作用于流本身。\n1 2 3 4 5 6 7 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; // 输出并换行 std::cout \u0026lt;\u0026lt; \u0026#34;This message will not appear until we call flush.\u0026#34; \u0026lt;\u0026lt; std::flush; // 输出并刷新输出缓冲区 return 0; } 8.6.组合输出 可以将多个插入运算符组合起来，连续输出多个变量或文本。\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; int main() { int a = 5; int b = 10; std::cout \u0026lt;\u0026lt; \u0026#34;a + b = \u0026#34; \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; std::endl; return 0; } cout 是 C++ 中输出数据的默认和最方便的方式。它的行为可以通过各种流操纵符进行微调，以满足不同的输出需求。\n9.std::cout format 格式化输出 在C++中，使用cout输出格式化文本通常涉及到以下几个方面：\n设置字段宽度：使用std::setw来设置下一个输出项的宽度。\n1 std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; \u0026#34;Value\u0026#34; \u0026lt;\u0026lt; std::endl; 设置精度：使用std::setprecision来设置浮点数的输出精度。\n1 std::cout \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2) \u0026lt;\u0026lt; 3.14159 \u0026lt;\u0026lt; std::endl; 调整浮点数表示：使用std::fixed或std::scientific来控制浮点数的输出格式。\n1 2 std::cout \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; 3.14159 \u0026lt;\u0026lt; std::endl; // 固定点表示 std::cout \u0026lt;\u0026lt; std::scientific \u0026lt;\u0026lt; 3.14159 \u0026lt;\u0026lt; std::endl; // 科学计数法表示 设置对齐方式：使用std::left或std::right来设置文本的对齐方式。\n1 2 std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::left \u0026lt;\u0026lt; \u0026#34;Left aligned\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::right \u0026lt;\u0026lt; \u0026#34;Right aligned\u0026#34; \u0026lt;\u0026lt; std::endl; 输出布尔值：布尔值true和false通常被输出为1和0，但可以通过自定义流操纵符来改变这一行为。\n输出十六进制数：使用std::hexfloat来输出浮点数的十六进制表示。\n1 std::cout \u0026lt;\u0026lt; std::hexfloat \u0026lt;\u0026lt; 3.14159 \u0026lt;\u0026lt; std::endl; 填充字符：使用std::setfill来设置用于填充额外空间的字符。\n1 std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; \u0026#34;Text\u0026#34; \u0026lt;\u0026lt; std::endl; 输出端的换行和空格：使用std::endl来输出换行，使用std::flush来刷新输出缓冲区。\n宽字符和宽字符串：使用std::setw和std::setfill的宽字符版本std::setw(10, L'*')来格式化宽字符。\n下面是一个综合示例，展示了如何使用这些格式化技术：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; int main() { double pi = 3.14159; std::string name = \u0026#34;Kimi\u0026#34;; int number = 42; std::cout \u0026lt;\u0026lt; \u0026#34;Formatted Output:\\n\u0026#34;; std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; \u0026#34;Num: \u0026#34; \u0026lt;\u0026lt; number \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::setw(15) \u0026lt;\u0026lt; std::setfill(\u0026#39; \u0026#39;) \u0026lt;\u0026lt; std::left \u0026lt;\u0026lt; \u0026#34;Pi value: \u0026#34; \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(3) \u0026lt;\u0026lt; \u0026#34;Pi value (fixed): \u0026#34; \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::scientific \u0026lt;\u0026lt; \u0026#34;Pi value (scientific): \u0026#34; \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::hexfloat \u0026lt;\u0026lt; \u0026#34;Pi value (hex): \u0026#34; \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，我们设置了字段宽度、填充字符、对齐方式、浮点数精度和表示法。这些工具可以帮助你创建格式化的文本输出，以满足你的需求。\n10.自定义格式化输出 在C++中，可以通过多种方式实现自定义的格式化输出。除了使用标准库中的流操纵符（如std::setw、std::setprecision、std::fixed、std::scientific等）之外，你还可以创建自定义的流操纵符或使用字符串流（std::stringstream）来进行更复杂的格式化。以下是一些方法：\n10.1. 使用标准流操纵符 这是最简单和最直接的方法，如前所述，可以使用std::setw、std::setprecision等来控制输出格式。\n10.2. 创建自定义流操纵符 你可以创建自己的流操纵符来实现特定的格式化需求。这通常涉及到重载operator\u0026lt;\u0026lt;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; // 自定义流操纵符，用于输出带边框的值 struct bordered { const std::string value; bordered(const std::string \u0026amp;value) : value(value) {} friend std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const bordered \u0026amp;obj) { os \u0026lt;\u0026lt; \u0026#34;【\u0026#34; \u0026lt;\u0026lt; obj.value \u0026lt;\u0026lt; \u0026#34;】\u0026#34;; return os; } }; int main() { std::cout \u0026lt;\u0026lt; bordered(\u0026#34;Hello, World!\u0026#34;) \u0026lt;\u0026lt; std::endl; // 使用自定义流操纵符 return 0; } 10.3. 使用std::stringstream std::stringstream提供了一种灵活的方式来构建和格式化复杂的字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; #include \u0026lt;iomanip\u0026gt; int main() { std::stringstream ss; int number = 42; double pi = 3.14159; ss \u0026lt;\u0026lt; \u0026#34;Number: \u0026#34; \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; number \u0026lt;\u0026lt; std::endl; ss \u0026lt;\u0026lt; \u0026#34;Pi: \u0026#34; \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2) \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; ss.str() \u0026lt;\u0026lt; std::endl; return 0; } 10.4. 使用std::format（C++20） 从C++20开始，标准库中引入了std::format函数，它提供了一种类似于Python的字符串格式化方法。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; #include \u0026lt;format\u0026gt; int main() { int number = 42; double pi = 3.14159; std::cout \u0026lt;\u0026lt; std::format(\u0026#34;Number: {:0\u0026gt;10}\\n\u0026#34;, number); std::cout \u0026lt;\u0026lt; std::format(\u0026#34;Pi: {:.2f}\\n\u0026#34;, pi); return 0; } 10.5. 使用iomanip库中的其他函数 \u0026lt;iomanip\u0026gt;库中包含了许多用于格式化输出的函数。\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; int main() { int number = -42; std::cout \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; std::setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; std::showpos \u0026lt;\u0026lt; number \u0026lt;\u0026lt; std::endl; return 0; } 10.6. 组合使用 你可以组合使用多种方法来实现复杂的格式化输出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;sstream\u0026gt; int main() { std::stringstream ss; int number = 42; double pi = 3.14159; ss \u0026lt;\u0026lt; std::left \u0026lt;\u0026lt; std::setw(20) \u0026lt;\u0026lt; \u0026#34;Number: \u0026#34; \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; number \u0026lt;\u0026lt; std::endl; ss \u0026lt;\u0026lt; std::left \u0026lt;\u0026lt; std::setw(20) \u0026lt;\u0026lt; \u0026#34;Pi: \u0026#34; \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2) \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; ss.str() \u0026lt;\u0026lt; std::endl; return 0; } 通过这些方法，你可以实现几乎任何你需要的自定义格式化输出。\n11.自定义流操纵符来实现复杂的格式化输出 在C++中，自定义流操纵符可以通过重载插入运算符 (operator\u0026lt;\u0026lt;) 来实现。这允许你创建新的格式化输出操作，它们可以是模板，以支持不同类型的数据。以下是创建自定义流操纵符的步骤：\n11.1. 定义一个辅助函数 这个函数将作为新的流操纵符，它接受一个输出流和一个要输出的值。\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // 自定义流操纵符，用于输出带边框的字符串 std::ostream\u0026amp; bordered(std::ostream\u0026amp; os, const std::string\u0026amp; str) { os \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34;]\u0026#34;; return os; } 11.2. 使用自定义流操纵符 在你的程序中，可以直接使用这个自定义流操纵符来格式化输出。\n1 2 3 4 5 int main() { std::string text = \u0026#34;Hello, World!\u0026#34;; std::cout \u0026lt;\u0026lt; bordered(text) \u0026lt;\u0026lt; std::endl; return 0; } 11.3. 创建更复杂的格式化 你可以创建更复杂的格式化操作，例如，同时设置宽度、填充字符和对齐方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;string\u0026gt; // 自定义流操纵符，用于输出带边框并居中的字符串 std::ostream \u0026amp;bordered_and_centered(std::ostream \u0026amp;os, const std::string \u0026amp;str) { int length = str.length(); int total_width = 20; // 定义总宽度，确保足够长 int padding = (total_width - length) / 2; // 确保如果总宽度 - 长度是奇数，右侧的星号比左侧多一个 int extra_padding = (total_width - length) % 2; std::string padding_str = std::string(padding, \u0026#39;*\u0026#39;) + (extra_padding ? \u0026#34;*\u0026#34; : \u0026#34;\u0026#34;); os \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; padding_str \u0026lt;\u0026lt; str \u0026lt;\u0026lt; padding_str \u0026lt;\u0026lt; \u0026#34;]\u0026#34;; return os; } int main() { std::string text = \u0026#34;C++\u0026#34;; std::cout \u0026lt;\u0026lt; bordered_and_centered(std::cout, text) \u0026lt;\u0026lt; std::endl; return 0; } 11.4. 使用模板创建通用操纵符 你可以创建模板函数来使操纵符对多种类型通用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; // 前向声明，以便在下面的 operator\u0026lt;\u0026lt; 中使用 Centered template\u0026lt;typename T\u0026gt; class Centered; // 重载 operator\u0026lt;\u0026lt; template\u0026lt;typename T\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Centered\u0026lt;T\u0026gt;\u0026amp; obj) { os \u0026lt;\u0026lt; std::setw(20) \u0026lt;\u0026lt; std::setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; std::internal \u0026lt;\u0026lt; obj.value; return os; } // 自定义流操纵符模板，用于输出居中的值 template\u0026lt;typename T\u0026gt; class Centered { public: T value; Centered(const T\u0026amp; val) : value(val) {} }; // 创建一个辅助函数来简化流操纵符的调用 template\u0026lt;typename T\u0026gt; Centered\u0026lt;T\u0026gt; centered(const T\u0026amp; value) { return Centered\u0026lt;T\u0026gt;(value); } int main() { int number = 42; std::cout \u0026lt;\u0026lt; centered(number) \u0026lt;\u0026lt; std::endl; double pi = 3.14159; std::cout \u0026lt;\u0026lt; centered(pi) \u0026lt;\u0026lt; std::endl; return 0; } 11.5. 结合标准库函数 你可以在自定义流操纵符中结合使用标准库的流操纵符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; // 自定义流操纵符结构，用于输出带边框并右对齐的浮点数 struct BorderedRightAligned { double value; BorderedRightAligned(double val) : value(val) {} }; // 重载 operator\u0026lt;\u0026lt; std::ostream \u0026amp;operator\u0026lt;\u0026lt;(std::ostream \u0026amp;os, const BorderedRightAligned \u0026amp;obj) { os \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2); os \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; std::right \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; obj.value \u0026lt;\u0026lt; \u0026#34;]\u0026#34;; return os; } // 创建一个辅助函数，用于创建 BorderedRightAligned 对象 inline BorderedRightAligned bordered_right_aligned(double value) { return BorderedRightAligned(value); } int main() { double pi = 3.14159; std::cout \u0026lt;\u0026lt; bordered_right_aligned(pi) \u0026lt;\u0026lt; std::endl; // 正确的调用 return 0; } 11.6. 处理复杂数据类型 如果你需要格式化复杂的自定义数据类型，可以在该类型的类内部或外部定义流操纵符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;string\u0026gt; class Point { public: double x, y; Point(double x, double y) : x(x), y(y) {} }; // 为Point类定义流操纵符 std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Point\u0026amp; p) { os \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision(2) \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; return os; } int main() { Point p(3.14159, 2.71828); std::cout \u0026lt;\u0026lt; \u0026#34;Point: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; std::endl; return 0; } 通过这些方法，你可以创建几乎任何你需要的自定义格式化输出。自定义流操纵符提供了一种强大的方式来扩展C++的输出功能，使其能够适应复杂的格式化需求。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T00:59:48+08:00","permalink":"https://wesigj.github.io/p/c-practical-1-day10/","title":"C++ Practical-1 day10"},{"content":"C++ Practical-1 day9 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.exception 异常处理 在C++中，异常处理是一种错误处理机制，它允许程序在遇到无法正常处理的情况时，将控制权转移给异常处理器。C++使用try、catch、throw和finally（在C++11中用RAII风格替代）关键字来实现异常处理。\n1.1.异常处理的关键字 try：用于指定一个代码块，在该代码块中可能会抛出异常。 catch：用于捕获并处理特定类型的异常。 throw：用于抛出一个异常。 finally：在C++11之前，没有finally关键字，但可以使用try块后的代码来执行清理操作。C++11引入了std::exception_ptr和std::rethrow_exception来处理异常传播。 1.2.示例：基本的异常处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; // 函数声明 void mightGoWrong() { throw std::runtime_error(\u0026#34;Something went wrong!\u0026#34;); } int main() { try { mightGoWrong(); } catch (const std::runtime_error\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Caught exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } return 0; } 在这个例子中，mightGoWrong函数抛出了一个std::runtime_error异常。在main函数中，我们使用try块来调用这个函数，并使用catch块来捕获和处理异常。\n1.3.示例：多个catch块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; void mightGoWrong(int i) { if (i == 0) throw std::runtime_error(\u0026#34;Argument is zero\u0026#34;); else if (i \u0026lt; 0) throw std::invalid_argument(\u0026#34;Argument is negative\u0026#34;); else throw std::logic_error(\u0026#34;Argument is too large\u0026#34;); } int main() { try { mightGoWrong(-1); } catch (const std::runtime_error\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Runtime error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (const std::invalid_argument\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Invalid argument: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (const std::logic_error\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Logic error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (const std::exception\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Unknown exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } return 0; } 在这个例子中，mightGoWrong函数根据参数的不同抛出不同类型的异常。main函数中的try块调用这个函数，并有多个catch块来捕获不同类型的异常。\n1.4.注意事项 异常应该是异常类的实例：通常，异常应该是std::exception类或其派生类的实例。\n异常不应该被忽略：如果一个try块中的异常没有被捕获，程序将终止。\n异常的类型：可以抛出任何类型的异常，但通常是抛出标准异常类型或自定义的异常类型。\n异常的堆栈跟踪：在抛出异常时，程序会记录异常的堆栈跟踪信息，这对于调试非常有用。\n资源管理：在抛出异常之前，确保释放所有分配的资源，或者使用RAII机制来自动管理资源。\n异常传播：在函数中捕获异常并重新抛出，可以使用std::rethrow_exception来保持原始的异常堆栈信息。\n异常对象的复制：异常对象在抛出时会被复制，因此应该提供拷贝构造函数。\n通过使用异常处理，你可以编写更健壮、更易于维护的代码，并且可以更好地处理程序运行中可能出现的错误情况。\n2.C++中有哪些自定义异常类，它们通常用于什么场景? 在C++中，自定义异常类通常是通过继承自std::exception类来实现的。自定义异常允许你为特定错误情况提供更多的上下文信息。以下是创建和使用自定义异常类的一些常见步骤：\n继承std::exception：创建一个新类，继承自std::exception，并重写what()方法，该方法返回一个描述异常的字符串。\n提供构造函数：为你的异常类提供构造函数，允许设置错误消息和其他相关信息。\n抛出异常：在代码中使用throw关键字抛出你的自定义异常对象。\n捕获异常：使用try-catch块捕获并处理异常。\n2.1.示例：自定义异常类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;exception\u0026gt; #include \u0026lt;string\u0026gt; // 自定义异常类 class MyException : public std::exception { private: std::string message; public: MyException(const std::string\u0026amp; msg) : message(msg) {} // 重写 what() 方法 const char* what() const noexcept override { return message.c_str(); } }; // 一个可能抛出异常的函数 void mightGoWrong(int value) { if (value \u0026lt; 0) { throw MyException(\u0026#34;Negative value is not allowed\u0026#34;); } } int main() { try { mightGoWrong(-1); } catch (const MyException\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Caught exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (const std::exception\u0026amp; e) { std::cout \u0026lt;\u0026lt; \u0026#34;Caught standard exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } return 0; } 在这个示例中，MyException类继承自std::exception，并重写了what()方法来返回错误消息。mightGoWrong函数在接收到负值时抛出MyException。main函数中的try-catch块捕获并处理了这个异常。\n2.2.使用场景 文件处理：当文件无法打开或读取时，可以抛出一个包含错误信息的自定义异常。 网络通信：在网络请求失败时，可以抛出一个包含错误代码和消息的异常。 数据验证：如果输入数据不符合预期，可以抛出一个异常来指示具体的错误。 业务逻辑：在业务规则被违反时，可以使用自定义异常来通知调用者。 自定义异常类使得错误处理更加灵活和表达性更强，有助于调试和维护大型应用程序。\n3.在C++中，除了自定义异常类，还有哪些错误处理机制？ 在C++中，除了使用自定义异常类进行错误处理，还有以下几种常见的错误处理机制：\n错误码：\n许多函数通过返回特定的错误码来指示操作是否成功，例如errno全局变量常用于指示上一次系统调用的错误。 断言（Assert）：\nassert宏用于在调试期间检查程序状态，如果条件为假，则终止程序执行并输出错误信息。它通常用于检查程序的前提条件。 返回值：\n函数可以通过返回值来指示操作是否成功，例如返回布尔值或自定义的枚举类型。 输出参数：\n函数可以将错误信息或状态代码通过输出参数传递给调用者。 异常抛出（Throw）：\n除了自定义异常类，也可以抛出基本数据类型或其他类型的异常对象。 错误处理库：\n使用如Boost.Error或Poco库等第三方库提供的错误处理功能。 标准库异常：\n使用C++标准库提供的异常类，如std::runtime_error、std::logic_error等。 资源获取即初始化（RAII）：\n使用RAII机制管理资源，确保在发生异常时资源能够被正确释放。 错误恢复：\n在某些情况下，程序可以通过执行某些恢复操作来从错误状态中恢复。 日志记录：\n在检测到错误时记录详细的错误信息，以便于后续分析。 条件编译：\n使用预处理器指令（如#ifdef、#ifndef）来处理不同平台或配置下的错误处理。 静态分析工具：\n使用静态分析工具（如Clang Static Analyzer、Cppcheck）来检测潜在的错误。 单元测试：\n通过编写和运行单元测试来确保代码的正确性。 代码审查：\n通过代码审查来发现和修复潜在的错误。 用户界面反馈：\n在图形用户界面（GUI）程序中，通过用户界面提供错误信息。 操作系统错误报告：\n在Windows上使用GetLastError和FormatMessage等函数获取系统错误信息。 信号处理：\n使用信号处理机制（如signal和sigaction）来处理程序运行时的异常情况。 每种错误处理机制都有其适用的场景，选择合适的机制取决于具体的应用需求、性能考虑和编程风格。在实际开发中，通常会结合使用多种错误处理机制来提高程序的健壮性和可维护性。\n4.在C++中实现一个多线程程序，异常处理应该如何设计以避免线程安全问题？ 在C++中实现多线程程序时，异常处理需要特别小心，因为异常可能会跨越线程边界，这可能导致线程安全问题。以下是一些设计多线程程序异常处理时的准则：\n限制异常抛出的范围：\n尽量在线程函数中避免抛出异常。如果必须抛出，确保它在同一个线程中被捕获和处理。 使用异常捕获：\n在每个线程的执行函数中使用try-catch块来捕获和处理异常。 避免在析构函数中抛出异常：\n析构函数中抛出异常是危险的，因为如果一个线程在执行析构函数时抛出异常，而这个异常没有被捕获，那么程序可能会直接退出。如果需要在析构函数中执行清理工作，考虑使用RAII（资源获取即初始化）技术。 使用线程安全的异常处理机制：\n如果需要在多个线程之间传递异常，可以使用线程安全的异常处理机制，如std::current_exception和std::exception_ptr。 使用锁来保护共享资源：\n在访问共享资源之前获取锁，并在可能抛出异常的操作之前释放锁，以避免死锁。 小心使用动态内存分配：\n在抛出异常之前，确保已经释放了所有动态分配的内存，或者使用智能指针来自动管理内存。 使用线程局部存储：\n使用thread_local关键字来定义线程局部存储，以避免在多个线程之间共享可能导致异常的对象。 考虑异常传播：\n如果你在一个线程中捕获了异常，并且需要将这个异常传递给其他线程，可以使用std::exception_ptr。 使用日志记录异常信息：\n在捕获异常时，使用日志记录异常信息，这样即使异常被处理，也可以在日志中追踪到异常发生的原因。 测试多线程程序：\n多线程程序的异常处理需要通过充分的测试来验证，确保在各种情况下都能正确处理异常。 使用标准库中的线程工具：\n使用C++11及更高版本中的标准库线程工具，如std::thread、std::mutex等，它们提供了一些线程安全的机制。 避免使用不安全的函数：\n避免在多线程环境中使用可能导致未定义行为的函数，如longjmp。 记住，多线程编程中的异常处理比单线程编程更加复杂，需要仔细设计以确保程序的稳定性和可靠性。\n4.1.示例 当然，以下是一个简单的C++多线程程序示例，展示了如何在线程中处理异常：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;exception\u0026gt; #include \u0026lt;string\u0026gt; // 线程函数，可能会抛出异常 void threadFunction(int id) { try { // 模拟一些可能会抛出异常的操作 if (id == 1) { throw std::runtime_error(\u0026#34;Exception from thread with id 1\u0026#34;); } std::cout \u0026lt;\u0026lt; \u0026#34;Thread with id \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; is running...\u0026#34; \u0026lt;\u0026lt; std::endl; } catch (const std::exception\u0026amp; e) { // 在线程内部捕获和处理异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Exception caught in thread with id \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (...) { // 捕获所有类型的异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Unknown exception caught in thread with id \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; std::endl; } } int main() { try { // 创建两个线程 std::thread t1(threadFunction, 1); std::thread t2(threadFunction, 2); // 等待线程完成 t1.join(); t2.join(); } catch (const std::exception\u0026amp; e) { // 主线程中捕获异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Exception in main thread: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (...) { // 捕获所有类型的异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Unknown exception in main thread\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 在这个示例中，threadFunction 是一个可能会抛出异常的线程函数。我们使用 try-catch 块来捕获和处理这些异常。如果线程函数抛出了异常，它会在该线程内部被捕获并处理，不会传播到主线程。\n主函数 main 中也使用了 try-catch 块来捕获可能从线程函数传播到主线程的异常，尽管在这个例子中我们没有让异常传播到主线程。\n请注意，这个示例假设异常不会从线程传播到主线程。在实际应用中，如果需要将异常从线程传播到主线程，可以使用 std::exception_ptr。\n这里是一个使用 std::exception_ptr 来传播异常的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;exception\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; // 线程函数，可能会抛出异常 std::exception_ptr threadFunction(int id) { std::exception_ptr ptr = nullptr; try { // 模拟一些可能会抛出异常的操作 if (id == 1) { throw std::runtime_error(\u0026#34;Exception from thread with id 1\u0026#34;); } std::cout \u0026lt;\u0026lt; \u0026#34;Thread with id \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34; is running...\u0026#34; \u0026lt;\u0026lt; std::endl; } catch (...) { // 捕获所有异常并存储在exception_ptr中 ptr = std::current_exception(); } return ptr; } int main() { std::vector\u0026lt;std::thread\u0026gt; threads; std::vector\u0026lt;std::exception_ptr\u0026gt; exceptions; try { // 创建两个线程 for (int i = 1; i \u0026lt;= 2; ++i) { threads.emplace_back(threadFunction, i); exceptions.push_back(threadFunction(i)); // 执行线程函数并存储异常 } // 等待线程完成并重新抛出异常 for (auto\u0026amp; t : threads) { t.join(); } for (auto\u0026amp; e : exceptions) { if (e) { std::rethrow_exception(e); } } } catch (const std::exception\u0026amp; e) { // 主线程中捕获异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Exception in main thread: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (...) { // 捕获所有类型的异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Unknown exception in main thread\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 在这个示例中，threadFunction 返回一个 std::exception_ptr，它存储了线程中捕获的异常。在主线程中，我们等待所有线程完成，然后检查每个线程的 std::exception_ptr，如果有异常，就使用 std::rethrow_exception 重新抛出它。这样，异常就可以从线程传播到主线程了。\n5.在C++中，如何使用RAII原则来管理资源？ RAII（Resource Acquisition Is Initialization）是C++中一种管理资源获取和释放的编程技术。RAII的核心思想是将资源的生命周期绑定到对象的生命周期。当对象创建时，它获取必要的资源，当对象销毁时，它释放这些资源。这通常通过构造函数来获取资源，通过析构函数来释放资源来实现。\n5.1.RAII的基本原则 资源获取：在类的构造函数中分配或获取资源。 资源释放：在类的析构函数中释放资源。 对象生命周期：确保对象的生命周期与资源的生命周期一致。 异常安全：确保在构造过程中发生异常时，已经获取的资源能够被正确释放。 5.2.RAII的常见应用 动态内存管理：使用new和delete操作符。 文件和网络资源：使用文件句柄和网络连接。 互斥锁：使用互斥锁来保护临界区。 5.3.示例：使用RAII管理动态内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; class AutoPtr { private: int* ptr; public: AutoPtr() : ptr(nullptr) {} explicit AutoPtr(int* p) : ptr(p) {} ~AutoPtr() { delete[] ptr; } // 禁止复制和赋值 AutoPtr(const AutoPtr\u0026amp;) = delete; AutoPtr\u0026amp; operator=(const AutoPtr\u0026amp;) = delete; // 支持移动语义 AutoPtr(AutoPtr\u0026amp;\u0026amp; other) : ptr(other.ptr) { other.ptr = nullptr; } AutoPtr\u0026amp; operator=(AutoPtr\u0026amp;\u0026amp; other) { if (this != \u0026amp;other) { delete[] ptr; ptr = other.ptr; other.ptr = nullptr; } return *this; } int* get() const { return ptr; } }; int main() { AutoPtr ap(new int[10]); // 分配数组 // 不需要手动释放，析构函数会自动处理 return 0; } 在这个例子中，AutoPtr类使用RAII模式管理一个整数数组的生命周期。当AutoPtr对象创建时，它分配内存；当对象销毁时，它释放内存。\n5.4.示例：使用RAII管理文件资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; class File { private: std::fstream file; public: File(const std::string\u0026amp; filename, std::ios_base::openmode mode) { file.open(filename, mode); if (!file.is_open()) { throw std::runtime_error(\u0026#34;Failed to open file\u0026#34;); } } ~File() { if (file.is_open()) { file.close(); } } // 禁止复制和赋值 File(const File\u0026amp;) = delete; File\u0026amp; operator=(const File\u0026amp;) = delete; // 支持移动语义 File(File\u0026amp;\u0026amp; other) : file(std::move(other.file)) {} File\u0026amp; operator=(File\u0026amp;\u0026amp; other) { file = std::move(other.file); return *this; } }; int main() { try { File f(\u0026#34;example.txt\u0026#34;, std::ios::in); // 使用文件 } catch (const std::runtime_error\u0026amp; e) { std::cerr \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } // 文件在f的析构函数中自动关闭 return 0; } 在这个例子中，File类使用RAII模式管理文件资源。当File对象创建时，它打开文件；当对象销毁时，它关闭文件。\n5.5.注意事项 禁止复制：通常，管理资源的对象应该禁止复制，以避免资源泄漏。 支持移动语义：支持移动构造函数和移动赋值运算符，以便在不同对象之间传递资源。 异常安全：确保在构造函数中获取资源时，如果发生异常，已经获取的资源能够被正确释放。 资源泄露：避免在析构函数中抛出异常，因为这可能导致资源泄露。 RAII是一种强大的资源管理技术，它可以简化代码，提高资源管理的安全性和可靠性。\n6.在C++中，除了RAII，还有哪些资源管理技术？ 在C++中，除了RAII（Resource Acquisition Is Initialization）原则，还有其他一些资源管理技术，这些技术有助于确保资源的正确管理和释放。以下是一些常见的资源管理技术：\n智能指针：\nstd::unique_ptr：独占式拥有其所指向的对象，不允许复制，但可以移动。 std::shared_ptr：共享式拥有其所指向的对象，具有引用计数机制。 std::weak_ptr：用于解决std::shared_ptr可能导致的循环引用问题。 函数对象（Functors）：\n封装状态和行为的对象，可以像函数一样被调用。 模板类：\n通过模板编程，可以编写通用的资源管理代码，如std::unique_ptr。 继承和多态：\n通过继承和多态，可以在基类中定义资源管理的接口，由派生类实现具体的资源管理逻辑。 异常处理：\n使用try、catch和throw关键字来捕获和处理异常，确保在异常发生时资源能够被正确释放。 条件编译：\n使用宏定义和条件编译来管理不同平台或配置下的资源。 手动管理：\n直接使用new和delete，malloc和free来管理内存资源。 垃圾回收：\n虽然C++标准库中没有内置的垃圾回收机制，但可以使用第三方库或特定的内存管理策略来实现类似垃圾回收的功能。 内存池（Memory Pool）：\n预先分配一块大的内存区域，用于频繁地分配和释放固定大小的对象，以减少内存碎片和提高性能。 对象池（Object Pool）：\n预先创建一组对象，以便快速重用，避免频繁的构造和析构。 线程局部存储（Thread-Local Storage）：\n使用线程局部变量来存储每个线程独有的资源。 原子操作：\n使用std::atomic来管理对共享资源的并发访问。 互斥锁（Mutexes）：\n使用互斥锁来保护临界区，确保同一时间只有一个线程可以访问共享资源。 文件描述符封装：\n封装文件描述符等操作系统资源，确保在对象销毁时关闭文件。 事件驱动编程：\n在事件循环中管理资源，确保资源在使用完成后能够被释放。 依赖注入：\n通过将资源作为参数传递给函数或对象，而不是在对象内部创建资源。 这些技术可以单独使用，也可以组合使用，以满足不同场景下的资源管理需求。正确选择和管理资源对于编写高效、可靠和可维护的C++程序至关重要。\n7.在栈中使用异常处理 在C++中，使用栈（stack）时进行异常处理需要特别注意，因为异常可能会跨越多个栈帧，这可能会导致资源泄漏或其他问题。以下是一些在栈中使用异常处理时的准则：\n使用RAII（资源获取即初始化）：\nRAII是一种确保资源在对象生命周期内被正确管理的机制。当对象超出作用域时，其析构函数将自动被调用，从而释放资源。 避免在析构函数中抛出异常：\n如果一个对象的析构函数抛出异常，而这个异常没有被捕获，那么程序可能会直接退出。因此，应该在析构函数中避免抛出异常。 使用智能指针管理动态内存：\n使用std::unique_ptr或std::shared_ptr来自动管理动态分配的内存。 使用std::stack的异常安全：\nstd::stack是一个容器适配器，它提供了基本的异常安全保证。但是，如果你在std::stack中存储了自定义对象，并且这些对象的复制或移动操作可能会抛出异常，那么你需要确保这些操作是异常安全的。 使用try-catch块：\n在可能抛出异常的代码周围使用try-catch块来捕获和处理异常。 使用std::exception_ptr：\n如果你需要在多个线程之间传递异常，可以使用std::exception_ptr。 使用noexcept：\n在不会抛出异常的函数后面使用noexcept关键字，以告诉编译器这个函数不会抛出异常。 使用std::uncaught_exceptions：\nstd::uncaught_exceptions是C++17中引入的，它返回当前线程中未捕获的异常数量。这可以用来检测是否有异常正在传播。 下面是一个示例，展示了如何在栈中使用异常处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;stdexcept\u0026gt; class Resource { public: Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource acquired\\n\u0026#34;; } ~Resource() { std::cout \u0026lt;\u0026lt; \u0026#34;Resource released\\n\u0026#34;; } }; void safeFunction(std::stack\u0026lt;std::unique_ptr\u0026lt;Resource\u0026gt;\u0026gt;\u0026amp; s) { try { // 模拟可能会抛出异常的操作 throw std::runtime_error(\u0026#34;Exception in safeFunction\u0026#34;); } catch (...) { // 捕获所有异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Exception caught in safeFunction\\n\u0026#34;; // 确保栈中的资源被正确释放 s = std::stack\u0026lt;std::unique_ptr\u0026lt;Resource\u0026gt;\u0026gt;(); // 清空栈 throw; // 重新抛出异常 } } int main() { std::stack\u0026lt;std::unique_ptr\u0026lt;Resource\u0026gt;\u0026gt; s; try { // 将资源推入栈中 s.push(std::make_unique\u0026lt;Resource\u0026gt;()); safeFunction(s); } catch (const std::exception\u0026amp; e) { // 主线程中捕获异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Exception in main thread: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } catch (...) { // 捕获所有类型的异常 std::cerr \u0026lt;\u0026lt; \u0026#34;Unknown exception in main thread\u0026#34; \u0026lt;\u0026lt; std::endl; } // 栈中的资源将自动被释放 return 0; } 在这个示例中，我们使用std::unique_ptr来管理Resource对象的生命周期。当Resource对象超出作用域时，其析构函数将自动被调用，从而释放资源。在safeFunction中，我们捕获所有异常，并在捕获异常后清空栈，以确保栈中的资源被正确释放。然后，我们重新抛出异常，以便在主线程中进行处理。\n请注意，这个示例假设异常不会从safeFunction传播到主线程。在实际应用中，如果需要将异常从safeFunction传播到主线程，可以使用std::exception_ptr。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T00:59:47+08:00","permalink":"https://wesigj.github.io/p/c-practical-1-day9/","title":"C++ Practical-1 day9"},{"content":"C++ Practical-1 day8 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.STL map 在C++中，std::map 是 STL（Standard Template Library，标准模板库）中的一个关联容器，它根据键（Key）来存储和组织数据。std::map 是基于红黑树实现的，它保证了元素的有序性，并且提供了对元素的高效访问。\n1.1.std::map 的特点 键值对存储：std::map 存储的数据是键值对（key-value）的形式。 自动排序：键会自动根据比较函数进行排序，默认情况下是升序。 唯一键：每个键都是唯一的，不允许有重复的键。 对数时间复杂度：插入、查找和删除操作的时间复杂度为 O(log n)。 1.2.std::map 的基本操作 插入：insert 或 emplace 用于添加新的键值对。 访问：使用 operator[] 或 at 方法访问特定键的值。 查找：使用 find 方法查找键是否存在。 删除：使用 erase 方法删除特定键的元素。 遍历：使用迭代器遍历 map。 1.3.示例：使用 std::map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::map\u0026lt;std::string, int\u0026gt; ageMap; // 插入元素 ageMap[\u0026#34;Alice\u0026#34;] = 30; ageMap[\u0026#34;Bob\u0026#34;] = 25; ageMap[\u0026#34;Carol\u0026#34;] = 35; // 访问元素 std::cout \u0026lt;\u0026lt; \u0026#34;Alice\u0026#39;s age: \u0026#34; \u0026lt;\u0026lt; ageMap[\u0026#34;Alice\u0026#34;] \u0026lt;\u0026lt; std::endl; // 查找元素 auto it = ageMap.find(\u0026#34;Bob\u0026#34;); if (it != ageMap.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Bob\u0026#39;s age: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; std::endl; } // 删除元素 ageMap.erase(\u0026#34;Carol\u0026#34;); // 遍历 map for (const auto\u0026amp; pair : ageMap) { std::cout \u0026lt;\u0026lt; pair.first \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; pair.second \u0026lt;\u0026lt; \u0026#34; years old.\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 1.4.注意事项 默认排序：std::map 默认使用 std::less 对键进行排序，如果需要自定义排序，可以提供自定义比较函数。\n键的类型：键的类型必须支持比较运算符，且不允许修改键的值。\n迭代器：std::map 提供了迭代器，可以用于遍历元素。\n异常安全：std::map 的操作通常抛出异常时，容器的状态不会被破坏，可以安全地处理异常。\n内存管理：std::map 会自动管理内存，不需要手动分配和释放内存。\nstd::map 是 C++ STL 中非常强大的容器之一，它提供了丰富的接口和高效的操作，适用于需要有序存储和快速查找的场景。\n2.class template 类模板 在C++中，类模板是一种支持泛型编程的工具，允许开发者创建可在多种数据类型间工作的类。类模板通过在类名前加上尖括号\u0026lt;\u0026gt;和参数列表来定义，参数可以是类型、值或其他模板。\n2.1.定义类模板 1 2 3 4 5 6 7 8 9 template \u0026lt;typename T\u0026gt; class MyClass { private: T data; public: MyClass(T value) : data(value) {} T getData() const { return data; } void setData(T value) { data = value; } }; 2.2.使用类模板 1 2 3 4 5 6 7 8 9 10 11 12 int main() { MyClass\u0026lt;int\u0026gt; intObj(10); MyClass\u0026lt;std::string\u0026gt; stringObj(\u0026#34;Hello, World!\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;intObj data: \u0026#34; \u0026lt;\u0026lt; intObj.getData() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;stringObj data: \u0026#34; \u0026lt;\u0026lt; stringObj.getData() \u0026lt;\u0026lt; std::endl; intObj.setData(20); std::cout \u0026lt;\u0026lt; \u0026#34;intObj data after update: \u0026#34; \u0026lt;\u0026lt; intObj.getData() \u0026lt;\u0026lt; std::endl; return 0; } 2.3.类模板的参数 类型参数：使用typename或class关键字（C++11之前使用class）。 非类型参数：可以是整数、枚举、指针大小等。 模板模板参数：允许模板接受另一个模板作为参数。 2.4.非类型模板参数示例 1 2 3 4 5 6 7 8 template \u0026lt;typename T, int size\u0026gt; class Array { private: T data[size]; public: T\u0026amp; operator[](int index) { return data[index]; } const T\u0026amp; operator[](int index) const { return data[index]; } }; 2.5.模板模板参数示例 1 2 3 4 5 6 7 8 9 template \u0026lt;template \u0026lt;typename\u0026gt; class TT\u0026gt; class Wrapper { TT\u0026lt;int\u0026gt; var; public: Wrapper() : var() {} }; // 使用Wrapper Wrapper\u0026lt;std::vector\u0026gt; w; 2.6.类模板的特化 类模板的特化是为特定类型提供特定实现的方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 原始模板 template \u0026lt;typename T\u0026gt; class MyClass { public: void print() { std::cout \u0026lt;\u0026lt; \u0026#34;Generic template\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 特化模板 template \u0026lt;\u0026gt; class MyClass\u0026lt;int\u0026gt; { public: void print() { std::cout \u0026lt;\u0026lt; \u0026#34;Specialized for int\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { MyClass\u0026lt;int\u0026gt; intObj; MyClass\u0026lt;double\u0026gt; doubleObj; intObj.print(); // 输出: Specialized for int doubleObj.print(); // 输出: Generic template return 0; } 2.7.注意事项 代码复用：类模板允许代码在多种数据类型间复用。 类型安全：模板参数可以确保类型安全。 性能：模板在编译时实例化，不会产生运行时开销。 特化和偏特化：可以为特定类型或模板参数提供特化版本。 编译分离：模板定义通常放在头文件中，因为它们在编译时需要对每个使用点都是可见的。 类模板是C++泛型编程的核心，它们提供了一种强大的方式来编写通用且类型安全的代码。\n3.类模板来创建一个通用的排序算法 在C++中，可以使用类模板和函数模板来创建一个通用的排序算法。以下是一个简单的示例，展示了如何使用模板来实现一个基本的冒泡排序算法：\n3.1.冒泡排序算法的模板实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;functional\u0026gt; // For std::less // 模板函数，用于交换元素 template \u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { T temp = a; a = b; b = temp; } // 模板函数，实现冒泡排序 template \u0026lt;typename T, typename Compare = std::less\u0026lt;\u0026gt;\u0026gt; void bubbleSort(T\u0026amp; arr, Compare comp = Compare()) { bool swapped = true; int n = arr.size(); while (swapped) { swapped = false; for (int i = 1; i \u0026lt; n; ++i) { if (comp(arr[i - 1], arr[i])) { swap(arr[i - 1], arr[i]); swapped = true; } } --n; // 最大元素已经排在正确的位置 } } int main() { std::vector\u0026lt;int\u0026gt; vec = { 5, 3, 8, 4, 2 }; bubbleSort(vec); std::cout \u0026lt;\u0026lt; \u0026#34;Sorted vector: \u0026#34;; for (int num : vec) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; std::vector\u0026lt;std::string\u0026gt; vecStr = { \u0026#34;z\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;m\u0026#34; }; bubbleSort(vecStr, std::greater\u0026lt;\u0026gt;()); std::cout \u0026lt;\u0026lt; \u0026#34;Sorted vector: \u0026#34;; for (const auto\u0026amp; str : vecStr) { std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，bubbleSort函数模板接受一个引用到排序数组的参数和一个比较函数，默认使用std::less，这意味着排序是升序的。如果你想降序排序，可以提供std::greater作为比较函数。\n3.2.注意事项 模板参数：T代表数组或容器的元素类型，Compare是一个比较函数类型，默认为std::less\u0026lt;\u0026gt;。\n交换元素：swap函数模板用于交换两个元素的值。\n比较函数：comp是一个比较函数，用于比较两个元素的大小。\n算法逻辑：冒泡排序算法的逻辑是重复地遍历数组，比较相邻的元素，并在需要时交换它们。\n性能：冒泡排序的平均和最坏情况时间复杂度都是O(n^2)，对于大数据集来说效率不高。\n稳定性：冒泡排序是一种稳定的排序算法，相同值的元素的相对顺序在排序后保持不变。\n通用性：通过使用模板，这个排序算法可以用于任何可比较的数据类型。\n这个通用的排序算法示例展示了如何使用模板来创建灵活且通用的代码。在实际应用中，你可能会使用更高效的排序算法，如快速排序、归并排序或STL中的std::sort。\n4.类模板实现一个稳定的排序算法 在C++中，实现一个稳定的排序算法通常意味着排序后相等的元素应该保持它们原始的顺序。归并排序（Merge Sort）是一种时间复杂度为O(n log n)且稳定的排序算法。以下是使用类模板实现归并排序的示例：\n4.1.归并排序算法的模板实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; // For std::copy // 辅助函数，用于合并两个已排序的子数组 template \u0026lt;typename T\u0026gt; void merge(T *begin, T *mid, T *end, T *temp) { int i = 0, j = 0, k = 0; while (begin + i \u0026lt; mid \u0026amp;\u0026amp; mid + j \u0026lt; end) { if (*(begin + i) \u0026lt;= *(mid + j)) { temp[k++] = *(begin + i++); } else { temp[k++] = *(mid + j++); } } while (begin + i \u0026lt; mid) { temp[k++] = *(begin + i++); } while (mid + j \u0026lt; end) { temp[k++] = *(mid + j++); } std::copy(temp, temp + k, begin); } // 归并排序的递归函数 template \u0026lt;typename T\u0026gt; void mergeSort(T *begin, T *end, T *temp) { if (end - begin \u0026lt;= 1) { return; } T *mid = begin + (end - begin) / 2; mergeSort(begin, mid, temp); mergeSort(mid, end, temp); merge(begin, mid, end, temp); } // 归并排序的模板类 template \u0026lt;typename T\u0026gt; class MergeSorter { public: void sort(T *array, int size) { T *temp = new T[size]; mergeSort(array, array + size, temp); delete[] temp; } }; int main() { std::vector\u0026lt;int\u0026gt; vec = {5, 3, 8, 4, 2, 3, 1}; MergeSorter\u0026lt;int\u0026gt; sorter; sorter.sort(vec.data(), vec.size()); std::cout \u0026lt;\u0026lt; \u0026#34;Sorted vector: \u0026#34;; for (int num : vec) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; MergeSorter\u0026lt;std::string\u0026gt; string_sorter; std::vector\u0026lt;std::string\u0026gt; vecStr = {\u0026#34;z\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;k\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;z\u0026#34;}; string_sorter.sort(vecStr.data(), vecStr.size()); std::cout \u0026lt;\u0026lt; \u0026#34;Sorted vector: \u0026#34;; for (const auto \u0026amp;str : vecStr) { std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，MergeSorter类模板包含一个sort成员函数，它接受一个数组和数组的大小，然后使用归并排序算法对数组进行排序。merge函数模板用于合并两个已排序的子数组，而mergeSort递归函数用于递归地将数组分成更小的部分并排序。\n4.2.注意事项 稳定性：归并排序通过将相等元素保持在原始顺序来确保稳定性。\n递归：归并排序算法是递归的，它将数组分成两半，直到每一半只有一个元素，然后开始合并。\n临时数组：归并排序需要一个临时数组来合并子数组。在排序完成后，临时数组被释放。\n性能：归并排序的时间复杂度为O(n log n)，这使得它比冒泡排序等简单排序算法更适合处理大数据集。\n内存使用：归并排序需要与输入数组大小相同的额外内存。\n泛型编程：通过使用模板，归并排序算法可以用于任何可比较的数据类型。\n归并排序是实现稳定排序的一个很好的选择，特别是当你需要处理大量数据时。在实际应用中，C++标准库提供的std::sort函数是一个高效的通用排序算法，它通常使用快速排序、堆排序或插入排序的混合实现，并且是稳定的。\n5.类模板实现栈 让我们更详细地探讨如何使用类模板实现一个通用的栈（Stack）数据结构，并提供更多的功能和注释。\n5.1.扩展的栈类模板实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stdexcept\u0026gt; // For std::out_of_range #include \u0026lt;iterator\u0026gt; // For std::begin, std::end // 栈的模板类定义 template \u0026lt;typename T\u0026gt; class Stack { private: std::vector\u0026lt;T\u0026gt; elements; // 使用标准库中的vector来存储栈元素 public: // 默认构造函数 Stack() = default; // 构造函数，接受一个初始化列表 Stack(std::initializer_list\u0026lt;T\u0026gt; init) : elements(init) {} // 将元素压入栈顶 void push(const T\u0026amp; element) { elements.push_back(element); } // 移除栈顶元素 void pop() { if (isEmpty()) { throw std::out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::pop(): empty stack\u0026#34;); } elements.pop_back(); } // 获取栈顶元素 T top() const { if (isEmpty()) { throw std::out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::top(): empty stack\u0026#34;); } return elements.back(); } // 检查栈是否为空 bool isEmpty() const { return elements.empty(); } // 获取栈的大小 size_t size() const { return elements.size(); } // 获取栈的容量 size_t capacity() const { return elements.capacity(); } // 清空栈 void clear() { elements.clear(); } // 交换两个栈的内容 void swap(Stack\u0026amp; other) { elements.swap(other.elements); } // 迭代器支持 using iterator = typename std::vector\u0026lt;T\u0026gt;::iterator; using const_iterator = typename std::vector\u0026lt;T\u0026gt;::const_iterator; iterator begin() { return elements.begin(); } const_iterator begin() const { return elements.begin(); } iterator end() { return elements.end(); } const_iterator end() const { return elements.end(); } }; int main() { Stack\u0026lt;int\u0026gt; intStack; intStack.push(1); intStack.push(2); intStack.push(3); std::cout \u0026lt;\u0026lt; \u0026#34;Top of stack: \u0026#34; \u0026lt;\u0026lt; intStack.top() \u0026lt;\u0026lt; std::endl; // 应该输出 3 intStack.pop(); std::cout \u0026lt;\u0026lt; \u0026#34;New top of stack: \u0026#34; \u0026lt;\u0026lt; intStack.top() \u0026lt;\u0026lt; std::endl; // 应该输出 2 std::cout \u0026lt;\u0026lt; \u0026#34;Stack size: \u0026#34; \u0026lt;\u0026lt; intStack.size() \u0026lt;\u0026lt; std::endl; // 应该输出 2 // 使用迭代器遍历栈 std::cout \u0026lt;\u0026lt; \u0026#34;Stack contents: \u0026#34;; for (const auto\u0026amp; value : intStack) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; std::endl; // 清空栈 intStack.clear(); std::cout \u0026lt;\u0026lt; \u0026#34;Stack size after clear: \u0026#34; \u0026lt;\u0026lt; intStack.size() \u0026lt;\u0026lt; std::endl; // 应该输出 0 return 0; } 5.2.代码解释 成员变量：\nelements：一个std::vector\u0026lt;T\u0026gt;，用于存储栈中的元素。 构造函数：\n默认构造函数使用默认实现。 一个构造函数接受一个初始化列表，允许在创建栈时使用花括号初始化。 成员函数：\npush：将一个元素添加到栈的顶部。 pop：移除栈顶的元素。如果栈为空，则抛出std::out_of_range异常。 top：返回栈顶的元素，但不移除它。如果栈为空，则抛出std::out_of_range异常。 isEmpty：检查栈是否为空。 size：返回栈中元素的数量。 capacity：返回栈的容量，即vector可以存储的元素数量而不需要重新分配内存。 clear：清空栈中的所有元素。 swap：交换两个栈的内容。 迭代器支持：\n提供了迭代器支持，允许使用范围基于的for循环或其他算法来遍历栈。 异常处理：\n在pop和top函数中，如果栈为空，则抛出异常，这是一种常见的错误处理方式。 模板类型：\n模板参数T允许栈存储任何类型的数据。 容器选择：\n使用std::vector作为底层容器，但它不是实现栈的唯一选择。你也可以使用std::list或std::deque。 常量成员函数：\ntop和isEmpty被声明为const成员函数，因为它们不会修改对象的状态。 通过使用类模板，这个栈实现可以用于任何数据类型，并且提供了一个类型安全的通用接口。在实际应用中，你可以根据需要添加更多的功能。\n6.类模板与多线程 要在C++中使用类模板实现一个通用的栈，并确保其在多线程环境中是线程安全的，你需要考虑以下几点：\n互斥锁（Mutex）：使用互斥锁来保护栈的操作，确保在多线程环境中对栈的访问是互斥的。\n条件变量（Condition Variables）：在某些情况下，你可能需要使用条件变量来同步线程。\n原子操作（Atomic Operations）：对于简单的数据操作，可以考虑使用原子操作来保证操作的原子性。\n以下是一个简单的线程安全的栈实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;stdexcept\u0026gt; template \u0026lt;typename T\u0026gt; class ThreadSafeStack { private: std::vector\u0026lt;T\u0026gt; data; mutable std::mutex mutex; public: ThreadSafeStack() = default; // 将元素压入栈顶 void push(const T\u0026amp; element) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); data.push_back(element); } // 移除栈顶元素 void pop() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); if (isEmpty()) { throw std::out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::pop(): empty stack\u0026#34;); } data.pop_back(); } // 获取栈顶元素 T top() const { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); if (isEmpty()) { throw std::out_of_range(\u0026#34;Stack\u0026lt;\u0026gt;::top(): empty stack\u0026#34;); } return data.back(); } // 检查栈是否为空 bool isEmpty() const { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); return data.empty(); } // 获取栈的大小 size_t size() const { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); return data.size(); } }; int main() { ThreadSafeStack\u0026lt;int\u0026gt; intStack; // 启动多个线程来操作栈 // ... return 0; } 在这个示例中，我们使用了std::mutex来保护栈的操作。每次对栈的操作（如push、pop、top等）都会先获取互斥锁，确保同一时间只有一个线程可以操作栈。\n6.1.注意事项 锁的粒度：锁的粒度越小，性能越好，但实现越复杂。在上述示例中，我们使用了std::lock_guard来自动管理锁的获取和释放。\n死锁：在多线程环境中，需要小心避免死锁的发生。确保在所有情况下锁都能被正确释放。\n性能：频繁的锁定和解锁可能会影响性能。在高并发环境下，可能需要更高级的同步机制，如无锁编程技术。\n异常处理：在多线程环境中，需要考虑异常处理。确保在抛出异常之前释放锁。\n测试：多线程程序的测试通常比单线程程序更复杂。确保对多线程代码进行充分的测试。\n通过使用模板，这个线程安全的栈实现可以用于任何数据类型，并且提供了一个类型安全的通用接口。在实际应用中，你可以根据需要添加更多的功能。\n7.类模板实现队列 探讨如何使用类模板实现一个通用的队列数据结构，并提供更多的功能和注释。\n7.1.扩展的队列类模板实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 #include \u0026lt;iostream\u0026gt; #include \u0026lt;deque\u0026gt; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;iterator\u0026gt; // 队列的模板类定义 template \u0026lt;typename T\u0026gt; class Queue { private: std::deque\u0026lt;T\u0026gt; elements; // 使用标准库中的deque来存储队列元素 public: // 默认构造函数 Queue() = default; // 构造函数，接受一个初始化列表 Queue(std::initializer_list\u0026lt;T\u0026gt; init) : elements(init) {} // 将元素添加到队列尾部 void enqueue(const T\u0026amp; element) { elements.push_back(element); } // 移除队列头部的元素 void dequeue() { if (isEmpty()) { throw std::out_of_range(\u0026#34;Queue\u0026lt;\u0026gt;::dequeue(): empty queue\u0026#34;); } elements.pop_front(); } // 获取队列头部的元素 T front() const { if (isEmpty()) { throw std::out_of_range(\u0026#34;Queue\u0026lt;\u0026gt;::front(): empty queue\u0026#34;); } return elements.front(); } // 获取队列尾部的元素 T back() const { if (isEmpty()) { throw std::out_of_range(\u0026#34;Queue\u0026lt;\u0026gt;::back(): empty queue\u0026#34;); } return elements.back(); } // 检查队列是否为空 bool isEmpty() const { return elements.empty(); } // 获取队列的大小 size_t size() const { return elements.size(); } // 清空队列 void clear() { elements.clear(); } // 交换两个队列的内容 void swap(Queue\u0026amp; other) { elements.swap(other.elements); } // 迭代器支持 using iterator = typename std::deque\u0026lt;T\u0026gt;::iterator; using const_iterator = typename std::deque\u0026lt;T\u0026gt;::const_iterator; iterator begin() { return elements.begin(); } const_iterator begin() const { return elements.begin(); } iterator end() { return elements.end(); } const_iterator end() const { return elements.end(); } }; int main() { Queue\u0026lt;int\u0026gt; intQueue; intQueue.enqueue(1); intQueue.enqueue(2); intQueue.enqueue(3); std::cout \u0026lt;\u0026lt; \u0026#34;Queue front: \u0026#34; \u0026lt;\u0026lt; intQueue.front() \u0026lt;\u0026lt; std::endl; // 应该输出 1 std::cout \u0026lt;\u0026lt; \u0026#34;Queue back: \u0026#34; \u0026lt;\u0026lt; intQueue.back() \u0026lt;\u0026lt; std::endl; // 应该输出 3 intQueue.dequeue(); std::cout \u0026lt;\u0026lt; \u0026#34;New queue front after one dequeue: \u0026#34; \u0026lt;\u0026lt; intQueue.front() \u0026lt;\u0026lt; std::endl; // 应该输出 2 std::cout \u0026lt;\u0026lt; \u0026#34;Queue size: \u0026#34; \u0026lt;\u0026lt; intQueue.size() \u0026lt;\u0026lt; std::endl; // 应该输出 2 // 使用迭代器遍历队列 std::cout \u0026lt;\u0026lt; \u0026#34;Queue contents: \u0026#34;; for (const auto\u0026amp; value : intQueue) { std::cout \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; std::endl; // 清空队列 intQueue.clear(); std::cout \u0026lt;\u0026lt; \u0026#34;Queue size after clear: \u0026#34; \u0026lt;\u0026lt; intQueue.size() \u0026lt;\u0026lt; std::endl; // 应该输出 0 return 0; } 7.2.代码解释 成员变量：\nelements：一个std::deque\u0026lt;T\u0026gt;，用于存储队列中的元素。 构造函数：\n默认构造函数使用默认实现。 一个构造函数接受一个初始化列表，允许在创建队列时使用花括号初始化。 成员函数：\nenqueue：将一个元素添加到队列的尾部。 dequeue：移除队列头部的元素。如果队列为空，则抛出std::out_of_range异常。 front：返回队列头部的元素，但不移除它。如果队列为空，则抛出std::out_of_range异常。 back：返回队列尾部的元素，但不移除它。如果队列为空，则抛出std::out_of_range异常。 isEmpty：检查队列是否为空。 size：返回队列中元素的数量。 clear：清空队列中的所有元素。 swap：交换两个队列的内容。 迭代器支持：\n提供了迭代器支持，允许使用范围基于的for循环或其他算法来遍历队列。 异常处理：\n在dequeue、front和back函数中，如果队列为空，则抛出异常，这是一种常见的错误处理方式。 模板类型：\n模板参数T允许队列存储任何类型的数据。 容器选择：\n使用std::deque作为底层容器，但它不是实现队列的唯一选择。你也可以使用std::list或std::vector。 常量成员函数：\nfront、back和isEmpty被声明为const成员函数，因为它们不会修改对象的状态。 通过使用类模板，这个队列实现可以用于任何数据类型，并且提供了一个类型安全的通用接口。在实际应用中，你可以根据需要添加更多的功能。\n8.template max 模板 最大值 在C++中，如果你想编写一个模板函数来获取两个值中的最大值，你可以使用std::max函数，这是标准库提供的一个模板函数。但如果你想自己实现一个模板函数来获取最大值，以下是一个简单的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; // 模板函数，用于获取两个值中的最大值 template \u0026lt;typename T\u0026gt; T max(T a, T b) { return (a \u0026gt; b) ? a : b; } int main() { int i = 5; int j = 10; std::cout \u0026lt;\u0026lt; \u0026#34;Max of \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; max(i, j) \u0026lt;\u0026lt; std::endl; double f = 5.5; double g = 10.7; std::cout \u0026lt;\u0026lt; \u0026#34;Max of \u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; g \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; max(f, g) \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，max函数模板接受两个参数a和b，并返回较大的那个。它使用了\u0026gt;运算符来比较两个值，并使用了三元运算符? :来选择返回值。\n8.1.注意事项 类型限制：max函数模板适用于所有支持\u0026gt;运算符的类型。\n标准库函数：实际上，C++标准库已经提供了std::max函数，因此通常不需要自己实现。\n模板推导：当使用模板函数时，编译器会自动推导出模板参数的类型。\n常量表达式：如果你的编译器支持C++14或更高版本，你可以使用constexpr关键字来定义max函数，使其可以在编译时计算常量表达式。\n如果你想使用标准库的std::max函数，以下是如何使用它的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // 包含std::max int main() { int i = 5; int j = 10; std::cout \u0026lt;\u0026lt; \u0026#34;Max of \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; std::max(i, j) \u0026lt;\u0026lt; std::endl; double f = 5.5; double g = 10.7; std::cout \u0026lt;\u0026lt; \u0026#34;Max of \u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#34; and \u0026#34; \u0026lt;\u0026lt; g \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; std::max(f, g) \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，我们直接使用了std::max函数来获取两个值中的最大值。这是推荐的方式，因为它是标准库的一部分，经过了优化和测试。\n9.template conversion 模板 转化 在C++中，模板特化（Template Specialization）是一种为特定类型提供特定实现的方式。这允许你定制模板类或模板函数的行为，以适应特定的数据类型。\n9.1.类模板特化 类模板特化是在模板定义的基础上，为特定的类型参数提供不同的实现。\n示例：特化一个类模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; // 普通模板定义 template \u0026lt;typename T\u0026gt; class MyClass { public: void display() { std::cout \u0026lt;\u0026lt; \u0026#34;Generic template\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 类模板特化 template \u0026lt;\u0026gt; class MyClass\u0026lt;int\u0026gt; { public: void display() { std::cout \u0026lt;\u0026lt; \u0026#34;Specialized for int\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 类模板部分特化 template \u0026lt;typename T\u0026gt; class MyClass\u0026lt;T*\u0026gt; { public: void display() { std::cout \u0026lt;\u0026lt; \u0026#34;Specialized for pointer\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { MyClass\u0026lt;double\u0026gt; myClassDouble; myClassDouble.display(); // 输出: Generic template MyClass\u0026lt;int\u0026gt; myClassInt; myClassInt.display(); // 输出: Specialized for int MyClass\u0026lt;char*\u0026gt; myClassCharPtr; myClassCharPtr.display(); // 输出: Specialized for pointer return 0; } 在这个例子中，我们有一个通用的MyClass模板，然后为int类型提供了一个特化的实现。此外，我们还提供了一个部分特化，用于所有指针类型。\n9.2.函数模板特化 函数模板特化允许你为特定的类型参数提供特定的函数实现。\n示例：特化一个函数模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; // 普通模板定义 template \u0026lt;typename T\u0026gt; void print(T value) { std::cout \u0026lt;\u0026lt; \u0026#34;Generic template: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } // 函数模板特化，针对 int 类型 template \u0026lt;\u0026gt; void print\u0026lt;int\u0026gt;(int value) { std::cout \u0026lt;\u0026lt; \u0026#34;Specialized for int: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } // 函数模板特化，针对 const char* 类型 template \u0026lt;\u0026gt; void print\u0026lt;const char*\u0026gt;(const char* value) { std::cout \u0026lt;\u0026lt; \u0026#34;Specialized for const char*: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } // 函数模板特化，针对 char* 类型 template \u0026lt;\u0026gt; void print\u0026lt;char*\u0026gt;(char* value) { std::cout \u0026lt;\u0026lt; \u0026#34;Specialized for char*: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } int main() { print(3.14); // 输出: Generic template: 3.14 print(42); // 输出: Specialized for int: 42 print(\u0026#34;Hello\u0026#34;); // 输出: Specialized for const char*: Hello char greeting[] = \u0026#34;Hi\u0026#34;; print(greeting); // 输出: Specialized for char*: Hi return 0; } 在这个例子中，我们为print函数模板提供了一个通用实现，然后为int类型提供了一个特化的实现。此外，我们还提供了一个部分特化，用于引用类型。\n9.3.注意事项 特化和重载：特化是为特定类型提供定制实现，而重载是为不同参数提供多个实现。\n特化和偏特化：特化是为特定类型提供实现，而偏特化是为模板参数的某些值提供实现。\n特化和继承：特化不应该与继承混淆。特化是模板概念，而继承是类概念。\n编译器查找：当模板实例化时，编译器会查找最适合的特化版本。\n头文件：特化通常应该放在头文件中，因为它们需要在每次模板实例化时都是可见的。\n链接问题：由于特化可能在多个编译单元中定义，确保特化的定义在所有编译单元中都是一致的，以避免链接问题。\n通过使用模板特化，你可以为特定类型提供优化的实现，从而提高代码的性能和灵活性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T00:59:46+08:00","permalink":"https://wesigj.github.io/p/c-practical-1-day8/","title":"C++ Practical-1 day8"},{"content":"C++ Practical-1 day7 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.operator 运算符重载 运算符重载在C++中是一种允许已定义的运算符（如+、-、*、/等）用于用户定义的类型的功能。通过运算符重载，可以使得自定义类型的操作更加直观和自然。\n1.1.运算符重载的规则 不能创建新的运算符：只能重载已有的运算符。 不能改变运算符的优先级：运算符重载不会影响运算符的优先级。 不能改变运算符的结合性：运算符重载不会影响运算符的结合性。 成员函数：运算符重载通常是成员函数，但也可以是非成员函数（全局函数）。 const修饰：如果重载的运算符需要返回一个修改了的值，通常需要一个非const的成员函数版本。 1.2.示例1：重载加法运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; class Point { public: int x, y; Point(int px, int py) : x(px), y(py) {} // 重载加法运算符 Point operator+(const Point\u0026amp; rhs) const { return Point(x + rhs.x, y + rhs.y); } }; int main() { Point p1(1, 2); Point p2(3, 4); Point p3 = p1 + p2; std::cout \u0026lt;\u0026lt; \u0026#34;p3: (\u0026#34; \u0026lt;\u0026lt; p3.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p3.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，Point类重载了加法运算符，使得两个Point对象可以相加得到一个新的Point对象。\n1.3.示例2：重载赋值运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; class Person { public: std::string name; int age; Person(const std::string \u0026amp;n, int a) : name(n), age(a) { } // 重载赋值运算符 Person \u0026amp;operator=(const Person \u0026amp;rhs) { if (this != \u0026amp;rhs) { name = rhs.name; age = rhs.age; } return *this; } }; int main() { Person p1(\u0026#34;Alice\u0026#34;, 30); Person p2 = p1; std::cout \u0026lt;\u0026lt; \u0026#34;p2: \u0026#34; \u0026lt;\u0026lt; p2.name \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，Person类重载了赋值运算符，允许将一个Person对象赋值给另一个Person对象。\n1.4.示例3：重载下标运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; class Matrix { private: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; data; public: Matrix(int rows, int cols) { data.resize(rows, std::vector\u0026lt;int\u0026gt;(cols)); } // 重载下标运算符 int\u0026amp; operator[](int index) { return data[index][0]; // Simplified for demonstration } }; int main() { Matrix mat(2, 2); mat[0] = 1; mat[1] = 2; std::cout \u0026lt;\u0026lt; \u0026#34;mat[0]: \u0026#34; \u0026lt;\u0026lt; mat[0] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;mat[1]: \u0026#34; \u0026lt;\u0026lt; mat[1] \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，Matrix类重载了下标运算符，允许使用下标访问矩阵的元素。\n1.5.注意事项 运算符重载和类型安全：运算符重载应该保持运算符原有的语义，除非有充分的理由。 友元函数：运算符重载函数可以是友元函数，这样可以访问类的私有成员。 成员函数和非成员函数：运算符重载可以是成员函数，也可以是非成员函数（全局函数）。 const限定：如果重载的运算符不应该修改对象的状态，应该将其声明为const。 异常安全：运算符重载应该考虑异常安全，确保在发生异常时不会导致资源泄漏。 运算符重载是C++中一个强大的特性，但应该谨慎使用，以避免使代码难以理解和维护。\n2.operator_overload_binary 二元运算符重载 在C++中，二元运算符重载是指为自定义类型提供已有二元运算符（如+、-、*、/等）的新意义。二元运算符通常需要两个操作数，因此它们的重载函数可以是非成员函数或成员函数。\n2.1.二元运算符重载的规则 成员函数：如果重载为成员函数，它应该接受一个参数，并且不能改变左侧操作数的状态。 非成员函数：如果重载为非成员函数（通常是友元函数），它可以接受两个参数。 const限定：如果重载的运算符不应该修改对象的状态，应该将其声明为const。 返回类型：重载函数应该返回一个有意义的值，通常是运算结果。 2.2.示例1：重载加法运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; class Point { public: int x, y; Point(int px, int py) : x(px), y(py) {} // 重载加法运算符（成员函数） Point operator+(const Point\u0026amp; rhs) const { return Point(x + rhs.x, y + rhs.y); } }; int main() { Point p1(1, 2); Point p2(3, 4); Point p3 = p1 + p2; // 使用重载的加法运算符 std::cout \u0026lt;\u0026lt; \u0026#34;p3: (\u0026#34; \u0026lt;\u0026lt; p3.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p3.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 2.3.示例2：重载减法运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; class Vector { public: double x, y; Vector(double px, double py) : x(px), y(py) {} // 重载减法运算符（成员函数） Vector operator-(const Vector\u0026amp; rhs) const { return Vector(x - rhs.x, y - rhs.y); } }; int main() { Vector v1(5.0, 3.0); Vector v2(1.0, 2.0); Vector v3 = v1 - v2; // 使用重载的减法运算符 std::cout \u0026lt;\u0026lt; \u0026#34;v3: (\u0026#34; \u0026lt;\u0026lt; v3.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; v3.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 2.4.示例3：重载乘法运算符（与标量） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; class Matrix { public: double m[2][2]; Matrix(double m11, double m12, double m21, double m22) { m[0][0] = m11; m[0][1] = m12; m[1][0] = m21; m[1][1] = m22; } // 重载乘法运算符（成员函数，与标量） Matrix operator*(double scalar) const { return Matrix(m[0][0] * scalar, m[0][1] * scalar, m[1][0] * scalar, m[1][1] * scalar); } }; int main() { Matrix mat(1.0, 2.0, 3.0, 4.0); Matrix result = mat * 2.0; // 使用重载的乘法运算符 std::cout \u0026lt;\u0026lt; \u0026#34;Matrix after multiplication: \u0026#34; \u0026lt;\u0026lt; result.m[0][0] \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; result.m[0][1] \u0026lt;\u0026lt; \u0026#34;; \u0026#34; \u0026lt;\u0026lt; result.m[1][0] \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; result.m[1][1] \u0026lt;\u0026lt; std::endl; return 0; } 2.5.注意事项 一致性：运算符重载应该保持运算符原有的语义，除非有充分的理由。 交换律：对于如加法和乘法这样的交换律运算符，考虑重载为非成员函数，以允许交换操作数。 异常安全：运算符重载应该考虑异常安全，确保在发生异常时不会导致资源泄漏。 友元函数：运算符重载函数可以是友元函数，这样可以访问类的私有成员。 运算符重载是C++中一个强大的特性，但应该谨慎使用，以避免使代码难以理解和维护。\n3.operator_overload_class 类运算符重载形式 在C++中，运算符重载可以以成员函数或友元函数的形式实现。每种形式都有其特定的语法和使用场景。以下是运算符重载的两种主要形式：\n3.1.成员函数形式 运算符重载作为成员函数时，它的第一个参数是参与运算的另一个对象（对于二元运算符）。成员函数形式的运算符重载不能改变左侧操作数的状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class MyClass { public: // 成员函数形式的运算符重载 MyClass operator+(const MyClass\u0026amp; rhs) const { MyClass result(*this); // 复制当前对象 result += rhs; // 调用赋值运算符 return result; } // 赋值运算符 MyClass\u0026amp; operator+=(const MyClass\u0026amp; rhs) { // 实现加法并更新当前对象 return *this; } }; 3.2.友元函数形式 运算符重载作为友元函数时，它可以访问类的私有成员，并且可以定义为非成员函数。友元函数形式允许运算符左侧的操作数被修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MyClass { public: // 友元函数声明 friend MyClass operator+(const MyClass \u0026amp;lhs, const MyClass \u0026amp;rhs); // 其他成员函数和数据 }; // 友元函数定义 MyClass operator+(const MyClass \u0026amp;lhs, const MyClass \u0026amp;rhs) { MyClass result(lhs); // 复制左侧操作数 result = result + rhs; // 调用赋值运算符 return result; } 3.3.示例：实现加法运算符重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; class Point { public: int x, y; Point(int px, int py) : x(px), y(py) {} // 成员函数形式的加法运算符重载 Point operator+(const Point\u0026amp; rhs) const { return Point(x + rhs.x, y + rhs.y); } // 友元函数形式的加法运算符重载 friend Point operator+(const Point\u0026amp; lhs, const Point\u0026amp; rhs); }; // 友元函数定义 Point operator+(const Point\u0026amp; lhs, const Point\u0026amp; rhs) { return Point(lhs.x + rhs.x, lhs.y + rhs.y); } int main() { Point p1(1, 2); Point p2(3, 4); Point p3 = p1 + p2; // 使用重载的加法运算符 std::cout \u0026lt;\u0026lt; \u0026#34;p3: (\u0026#34; \u0026lt;\u0026lt; p3.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p3.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，Point类重载了加法运算符，提供了成员函数和友元函数两种形式。\n3.4.注意事项 成员函数：作为成员函数时，左侧操作数是隐式传递的this指针，只能重载二元运算符。 友元函数：作为友元函数时，可以重载所有运算符，包括一元运算符。 const限定：如果运算符重载不应该修改对象的状态，应该将其声明为const。 返回类型：运算符重载应该返回一个有意义的值，通常是运算结果。 异常安全：运算符重载应该考虑异常安全，确保在发生异常时不会导致资源泄漏。 运算符重载提供了一种强大的机制，使得自定义类型的操作更加直观和自然。然而，应该谨慎使用，以避免使代码难以理解和维护。\n4.operator_overload_unary 一元运算符重载 在C++中，一元运算符重载是指为自定义类型提供已有一元运算符（如+、-、*、\u0026amp;等）的新意义。一元运算符只需要一个操作数，因此它们的重载函数不需要额外的参数。\n以下是一些常见的一元运算符及其重载示例：\n4.1.示例1：重载一元加和减运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; class Number { public: int value; Number(int val) : value(val) {} // 重载一元加运算符 Number operator+() const { return *this; // 返回当前对象的一个副本 } // 重载一元减运算符 Number operator-() const { return Number(-value); // 返回当前对象的相反数 } }; int main() { Number num(10); Number pos = +num; // 调用一元加运算符 Number neg = -num; // 调用一元减运算符 std::cout \u0026lt;\u0026lt; \u0026#34;Positive: \u0026#34; \u0026lt;\u0026lt; pos.value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Negative: \u0026#34; \u0026lt;\u0026lt; neg.value \u0026lt;\u0026lt; std::endl; return 0; } 4.2.示例2：重载一元取地址运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; class Pointer { private: int* ptr; public: Pointer(int* p) : ptr(p) {} // 重载一元取地址运算符 operator int*() const { return ptr; } }; int main() { int data = 42; Pointer ptr(\u0026amp;data); int* pdata = ptr; // 使用重载的取地址运算符 std::cout \u0026lt;\u0026lt; \u0026#34;Value: \u0026#34; \u0026lt;\u0026lt; *pdata \u0026lt;\u0026lt; std::endl; return 0; } 4.3.示例3：重载一元逻辑非运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; class Boolean { private: bool value; public: Boolean(bool val) : value(val) {} // 重载一元逻辑非运算符 bool operator!() const { return !value; } }; int main() { Boolean trueBool(true); Boolean falseBool(false); std::cout \u0026lt;\u0026lt; \u0026#34;TrueBool: \u0026#34; \u0026lt;\u0026lt; (!trueBool ? \u0026#34;False\u0026#34; : \u0026#34;True\u0026#34;) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;FalseBool: \u0026#34; \u0026lt;\u0026lt; (!falseBool ? \u0026#34;False\u0026#34; : \u0026#34;True\u0026#34;) \u0026lt;\u0026lt; std::endl; return 0; } 4.4.注意事项 一元运算符：一元运算符只需要一个操作数，因此它们的重载函数不需要额外的参数。\nconst限定：如果重载的运算符不应该修改对象的状态，应该将其声明为const。\n返回类型：运算符重载应该返回一个有意义的值，通常是运算结果。\n转换运算符：一元运算符operator+和operator-通常用于实现数值转换，而operator*用于实现指针转换。\n异常安全：运算符重载应该考虑异常安全，确保在发生异常时不会导致资源泄漏。\n逻辑非运算符：逻辑非运算符operator!通常用于实现布尔值的逻辑取反。\n一元运算符重载是C++中一个有用的特性，它使得自定义类型的操作更加直观和自然。然而，应该谨慎使用，以避免使代码难以理解和维护。\n5.operator_overload_equal 重载运算符= 在C++中，重载赋值运算符=是一种常见的做法，用于定义对象之间赋值时的行为。默认情况下，编译器会生成一个赋值运算符，但如果类包含动态分配的资源（如动态内存），则通常需要自定义赋值运算符以确保资源被正确管理。\n5.1.自定义赋值运算符的规则 检查自赋值：首先检查是否发生自赋值，即对象赋值给自己的情况。\n释放现有资源：在分配新资源之前，释放对象当前持有的资源。\n复制资源：复制源对象的资源到当前对象。\n交换指针：如果使用指针管理资源，可以直接交换指针，但这种做法不适用于包含动态分配内存的复合类型。\n返回当前对象的引用：返回当前对象的引用，以便支持链式赋值。\n5.2.示例：重载赋值运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; class String { private: char *data; public: String(const char *str = \u0026#34;\u0026#34;) { if (str) { data = new char[strlen(str) + 1]; strcpy(data, str); } else { data = new char[1]; *data = \u0026#39;\\0\u0026#39;; } } // 拷贝构造函数 String(const String \u0026amp;other) { if (other.data) { data = new char[strlen(other.data) + 1]; strcpy(data, other.data); } else { data = new char[1]; *data = \u0026#39;\\0\u0026#39;; } } // 重载赋值运算符 String \u0026amp;operator=(const String \u0026amp;other) { if (this != \u0026amp;other) { // 检查自赋值 delete[] data; // 释放现有资源 if (other.data) { data = new char[strlen(other.data) + 1]; strcpy(data, other.data); } else { data = new char[1]; *data = \u0026#39;\\0\u0026#39;; } } return *this; // 返回当前对象的引用 } ~String() { delete[] data; } // 输出字符串内容的函数 const char *c_str() const { return data; } }; int main() { String str1(\u0026#34;Hello\u0026#34;); String str2 = str1; // 调用拷贝构造函数 String str3; str3 = str1; // 调用赋值运算符 std::cout \u0026lt;\u0026lt; \u0026#34;str1: \u0026#34; \u0026lt;\u0026lt; str1.c_str() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;str2: \u0026#34; \u0026lt;\u0026lt; str2.c_str() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;str3: \u0026#34; \u0026lt;\u0026lt; str3.c_str() \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，String类重载了赋值运算符。它首先检查自赋值，然后释放现有资源，并复制源对象的资源。\n5.3.注意事项 自赋值：在执行赋值操作之前，应该检查并处理自赋值的情况。\n异常安全：赋值运算符应该确保在发生异常时，对象仍然处于有效状态。\n深拷贝：如果类包含指针，应该确保进行深拷贝，而不是仅仅复制指针。\n返回类型：赋值运算符应该返回对当前对象的引用，以支持链式赋值。\n规则一致性：赋值运算符的行为应该与类的其他成员函数一致。\n虚函数：不要在赋值运算符中调用虚函数，因为这时对象可能还没有完全构造好。\n通过正确实现赋值运算符，可以确保对象在赋值过程中资源被正确管理，避免资源泄漏和其他问题。\n6.重载下标运算符[] 在C++中，重载下标运算符[]允许对象像数组一样被访问。这通常用于提供对对象中元素的访问，例如，容器类或字符串类。\n6.1.下标运算符重载的规则 成员函数：下标运算符通常作为成员函数重载，并且不接受任何参数，或者接受一个参数表示索引。\n常量性：如果重载的下标运算符不应该修改对象的状态，应该将其声明为const。\n返回类型：返回类型通常是对内部数据的引用，以允许链式赋值。\n6.2.示例1：重载下标运算符用于访问元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stdexcept\u0026gt; // 用于标准异常 class IntArray { private: std::vector\u0026lt;int\u0026gt; data; public: // 带参数的下标运算符，用于修改元素 int \u0026amp;operator[](size_t index) { // 简单的边界检查 if (index \u0026gt;= data.size()) { throw std::out_of_range(\u0026#34;Index out of range\u0026#34;); } return data[index]; } // 带参数的下标运算符，用于读取元素 const int \u0026amp;operator[](size_t index) const { // 简单的边界检查 if (index \u0026gt;= data.size()) { throw std::out_of_range(\u0026#34;Index out of range\u0026#34;); } return data[index]; } // 添加元素的方法 void push_back(int value) { data.push_back(value); } }; int main() { IntArray arr; arr.push_back(10); arr.push_back(20); std::cout \u0026lt;\u0026lt; \u0026#34;Element at index 0: \u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; std::endl; // 读取元素 std::cout \u0026lt;\u0026lt; \u0026#34;Element at index 1: \u0026#34; \u0026lt;\u0026lt; arr[1] \u0026lt;\u0026lt; std::endl; // 修改元素 arr[0] = 30; std::cout \u0026lt;\u0026lt; \u0026#34;Element at index 0 after modification: \u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，IntArray类重载了下标运算符，允许用户使用下标访问和修改std::vector中的元素。\n6.3.示例2：重载下标运算符用于自定义字符串类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; // 包含toupper函数 class String { private: char *data; public: String(const char *str = \u0026#34;\u0026#34;) { if (str) { data = new char[strlen(str) + 1]; strcpy(data, str); } else { data = new char[1]; *data = \u0026#39;\\0\u0026#39;; } } ~String() { delete[] data; } // 重载下标运算符 char \u0026amp;operator[](size_t index) { // 边界检查 if (index \u0026gt;= strlen(data)) { throw std::out_of_range(\u0026#34;Index out of range\u0026#34;); } return data[index]; } const char \u0026amp;operator[](size_t index) const { // 边界检查 if (index \u0026gt;= strlen(data)) { throw std::out_of_range(\u0026#34;Index out of range\u0026#34;); } return data[index]; } // 获取字符串数据的访问器 const char *c_str() const { return data; } }; int main() { String str(\u0026#34;Hello\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;Original string: \u0026#34; \u0026lt;\u0026lt; str.c_str() \u0026lt;\u0026lt; std::endl; // 修改字符串中的字符 for (size_t i = 0; i \u0026lt; strlen(str.c_str()); ++i) { str[i] = toupper(str[i]); } std::cout \u0026lt;\u0026lt; \u0026#34;Modified string: \u0026#34; \u0026lt;\u0026lt; str.c_str() \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，String类重载了下标运算符，允许用户使用下标访问和修改字符串中的字符。\n6.4.注意事项 边界检查：在实现下标运算符时，应该考虑添加边界检查，以防止越界访问。\n异常安全：如果下标运算符可能会抛出异常，应该确保异常发生时对象仍然处于有效状态。\n返回引用：通常返回对元素的引用，以允许链式赋值。\n常量成员函数：如果下标运算符用于读取元素，应该将其声明为const。\n虚函数：下标运算符不应该声明为虚函数，因为它通常用于非多态场景。\n通过正确实现下标运算符，可以使得自定义类型的元素访问更加直观和自然。然而，应该谨慎使用，以避免使代码难以理解和维护。\n7.重载函数调用运算符() 在C++中，重载函数调用运算符()允许对象像函数一样被调用。这在设计模式中非常有用，特别是在实现工厂模式或者需要模拟函数指针时。\n7.1.重载函数调用运算符的规则 成员函数：运算符()必须作为成员函数重载。 无参数：运算符()不接受任何参数。 返回值：必须指定返回类型，通常是类本身或者一个函数指针。 7.2.示例1：重载()运算符用于模拟函数指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; class FunctionWrapper { public: // 存储一个可调用对象 std::function\u0026lt;void()\u0026gt; func; // 构造函数 FunctionWrapper(std::function\u0026lt;void()\u0026gt; f) : func(f) {} // 重载函数调用运算符 void operator()() { func(); } }; int main() { // 创建一个lambda表达式 auto lambda = []() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; }; // 创建FunctionWrapper对象 FunctionWrapper wrapper(lambda); // 使用重载的()运算符调用 wrapper(); // 输出: Hello, World! return 0; } 7.3.示例2：重载()运算符用于创建工厂对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; class StringFactory { public: // 重载函数调用运算符 std::string operator()(const std::string\u0026amp; str) const { return str; } }; int main() { StringFactory factory; std::string result = factory(\u0026#34;Hello, Factory!\u0026#34;); std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; // 输出: Hello, Factory! return 0; } 7.4.注意事项 返回类型：根据需要返回适当的类型，如果需要链式调用，则返回对象本身的引用。\nconst成员函数：如果重载的()运算符不应该修改对象的状态，应该将其声明为const。\n异常安全：确保在调用过程中即使发生异常，对象也保持有效状态。\n资源管理：如果运算符()涉及到资源管理，确保资源被正确分配和释放。\n通过重载函数调用运算符()，可以使对象的使用更加灵活和表达式更加简洁。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T00:59:45+08:00","permalink":"https://wesigj.github.io/p/c-practical-1-day7/","title":"C++ Practical-1 day7"},{"content":"C++ Practical-1 day6 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.abstract_class 抽象类 在C++中，抽象类是一种不能被实例化的类，它通常作为基类使用，用于定义一个接口或规范，确保派生类遵循某些方法。抽象类通过包含至少一个纯虚函数（pure virtual function）来实现。\n1.1.抽象类的特点 纯虚函数：抽象类至少包含一个纯虚函数。纯虚函数没有实现，使用= 0声明。\n不能被实例化：由于抽象类不提供完整的实现，因此不能创建其实例。\n派生类必须覆盖所有纯虚函数：派生类必须覆盖基类中的所有纯虚函数，除非派生类也是抽象类。\n虚析构函数：通常在抽象类中定义虚析构函数，以确保删除派生类对象时正确调用派生类的析构函数。\n1.2.示例：抽象类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // 抽象类 class Shape { public: // 纯虚函数 virtual void draw() const = 0; // 虚析构函数 virtual ~Shape() {} }; // 派生类 class Circle : public Shape { public: void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a circle.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 另一个派生类 class Rectangle : public Shape { public: void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a rectangle.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 使用基类指针指向派生类对象 std::unique_ptr\u0026lt;Shape\u0026gt; shape1(new Circle()); std::unique_ptr\u0026lt;Shape\u0026gt; shape2(new Rectangle()); shape1-\u0026gt;draw(); // 调用Circle的draw函数 shape2-\u0026gt;draw(); // 调用Rectangle的draw函数 return 0; } 在这个例子中，Shape是一个抽象类，它包含一个纯虚函数draw。Circle和Rectangle是派生自Shape的类，它们都覆盖了draw函数。在main函数中，我们使用Shape指针来指向Circle和Rectangle对象，并调用它们的draw函数。\n1.3.注意事项 接口定义：抽象类通常用于定义接口，它规定了派生类必须实现的函数。\n多态：抽象类通常与多态一起使用，允许通过基类指针或引用来调用派生类中覆盖的虚函数。\n抽象类和虚函数：抽象类可以包含多个纯虚函数和普通虚函数。普通虚函数提供了默认实现，而纯虚函数没有。\n抽象类和继承：派生类可以从多个抽象类继承，也可以是另一个抽象类的抽象类。\n抽象类的实现：虽然抽象类不能被实例化，但它们可以包含成员函数的实现，这些实现可以被派生类继承。\n工厂模式：抽象类经常与工厂模式结合使用，用于创建一系列相关对象。\n抽象类是C++中实现面向对象设计原则的重要工具，它有助于定义清晰的接口和促进代码的模块化。\n2.virtual_function 虚函数 在C++中，虚函数用于实现多态性，允许通过基类指针或引用调用派生类中覆盖的函数。以下是一个使用虚函数的编程实例：\n2.1.示例：动物叫声的多态性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; // 基类 class Animal { public: virtual void speak() const { std::cout \u0026lt;\u0026lt; \u0026#34;The animal makes a sound.\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Animal() {} // 虚析构函数 }; // 派生类：狗 class Dog : public Animal { public: void speak() const override { std::cout \u0026lt;\u0026lt; \u0026#34;The dog barks.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 派生类：猫 class Cat : public Animal { public: void speak() const override { std::cout \u0026lt;\u0026lt; \u0026#34;The cat meows.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Animal* myAnimal = nullptr; Dog myDog; myAnimal = \u0026amp;myDog; myAnimal-\u0026gt;speak(); // 输出: The dog barks. Cat myCat; myAnimal = \u0026amp;myCat; myAnimal-\u0026gt;speak(); // 输出: The cat meows. return 0; } 在这个例子中，Animal是一个基类，它有一个虚函数speak。Dog和Cat是派生自Animal的类，它们都覆盖了speak函数。在main函数中，我们使用Animal指针myAnimal来指向Dog和Cat对象，并调用它们的speak函数。\n2.2.示例：计算图形的面积 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; // 基类：形状 class Shape { public: virtual double area() const = 0; // 纯虚函数 virtual ~Shape() {} // 虚析构函数 }; // 派生类：圆形 class Circle : public Shape { private: double radius; public: Circle(double r) : radius(r) {} double area() const override { return 3.14159 * radius * radius; } }; // 派生类：矩形 class Rectangle : public Shape { private: double width, height; public: Rectangle(double w, double h) : width(w), height(h) {} double area() const override { return width * height; } }; int main() { const double pi = 3.14159; Shape* shape; Circle circle(5); // 半径为5的圆 shape = \u0026amp;circle; std::cout \u0026lt;\u0026lt; \u0026#34;Circle area: \u0026#34; \u0026lt;\u0026lt; shape-\u0026gt;area() \u0026lt;\u0026lt; std::endl; // 输出圆形的面积 Rectangle rectangle(4, 6); // 宽4高6的矩形 shape = \u0026amp;rectangle; std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle area: \u0026#34; \u0026lt;\u0026lt; shape-\u0026gt;area() \u0026lt;\u0026lt; std::endl; // 输出矩形的面积 return 0; } 在这个例子中，Shape是一个抽象基类，它有一个纯虚函数area。Circle和Rectangle是派生自Shape的类，它们都覆盖了area函数。在main函数中，我们使用Shape指针shape来指向Circle和Rectangle对象，并调用它们的area函数。\n2.3.注意事项 多态性：虚函数允许多态性，使得可以通过基类指针或引用来调用派生类中覆盖的函数。\n抽象基类：包含纯虚函数的类是抽象基类，不能被实例化。\n派生类覆盖虚函数：派生类可以使用override关键字来覆盖基类的虚函数。\n虚析构函数：在基类中声明虚析构函数，以确保删除派生类对象时正确调用派生类的析构函数。\n动态类型识别：可以使用dynamic_cast在运行时安全地将基类指针或引用转换为派生类指针或引用。\n虚函数是C++中实现多态性的关键，使得代码更加灵活和可扩展。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T00:59:44+08:00","permalink":"https://wesigj.github.io/p/c-practical-1-day6/","title":"C++ Practical-1 day6"},{"content":"C++ Practical-1 day5 继承多态 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.构造 在C++中，构造函数是一种特殊的成员函数，用于在创建对象时初始化对象的成员变量。构造函数具有与类同名的名称，且没有返回类型，甚至连void也不是返回类型。\n1.1.构造函数的特点 名称与类名相同。 没有返回类型，连void也不是。 可以重载，即一个类可以有多个构造函数，只要它们的参数列表不同。 自动调用，在创建对象时自动调用。 1.2.构造函数的类型 默认构造函数：如果没有定义任何构造函数，编译器会生成一个默认构造函数。 参数化构造函数：允许传递参数来初始化成员变量。 拷贝构造函数：用于创建一个对象的新实例，该实例是另一个同类型对象的副本。 1.3.示例1：参数化构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; class Point { public: int x, y; // 参数化构造函数 Point(int xValue, int yValue) : x(xValue), y(yValue) { std::cout \u0026lt;\u0026lt; \u0026#34;Constructor called. (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Point point1(10, 20); return 0; } 在这个例子中，Point类有一个参数化构造函数，它接受两个整数参数，并用它们来初始化成员变量x和y。\n1.4.示例2：默认构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; class Point { public: int x, y; // 默认构造函数 Point() : x(0), y(0) { std::cout \u0026lt;\u0026lt; \u0026#34;Default constructor called. (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Point point1; return 0; } 在这个例子中，Point类有一个默认构造函数，它将成员变量x和y初始化为0。\n1.5.示例3：拷贝构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; class Point { public: int x, y; // 参数化构造函数 Point(int xValue, int yValue) : x(xValue), y(yValue) {} // 拷贝构造函数 Point(const Point\u0026amp; other) : x(other.x), y(other.y) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy constructor called. (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Point point1(10, 20); Point point2 = point1; // 调用拷贝构造函数 return 0; } 在这个例子中，Point类有一个拷贝构造函数，它用于创建一个对象的新实例，该实例是另一个同类型对象的副本。\n1.6.示例4：使用成员初始化列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; class Point { public: int x, y; // 使用成员初始化列表 Point(int xValue, int yValue) : x(xValue), y(yValue) { std::cout \u0026lt;\u0026lt; \u0026#34;Constructor called. (\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Point point1(10, 20); return 0; } 在这个例子中，构造函数使用成员初始化列表来初始化成员变量x和y。这是初始化成员变量的首选方法，因为它更高效，特别是对于常量成员和引用成员。\n1.7.注意事项 构造函数可以是显式的，也可以是隐式的。显式构造函数不允许默认值，而隐式构造函数允许。 如果类中有成员变量没有在构造函数中初始化，编译器会生成一个默认构造函数来初始化它们。 构造函数可以调用其他构造函数来避免代码重复，使用this-\u0026gt;指针。 构造函数不能被声明为const，因为它们会修改成员变量。 构造函数是C++类中非常重要的部分，正确地使用构造函数可以确保对象在创建时处于有效状态。\n2.构造次序 在C++中，当创建一个对象时，构造函数的执行顺序非常重要，尤其是当涉及到成员变量和成员对象的初始化时。以下是构造过程中的步骤和初始化顺序：\n成员变量的初始化：在成员变量的声明中，可以使用默认值，或者在构造函数的初始化列表中进行初始化。\n成员对象的初始化：成员对象是指作为类成员的其他对象。成员对象的构造函数会在包含对象的类的构造函数体执行之前调用。\n基类的初始化：如果类是从另一个类派生的（即存在继承），基类的构造函数会在派生类的构造函数体执行之前调用。\n构造函数体：在所有成员变量和成员对象初始化之后，构造函数体中的代码将被执行。\n2.1.初始化顺序 基类成员变量：基类的成员变量按照它们在类中的声明顺序进行初始化。 派生类成员变量：派生类的成员变量也是按照它们在类中的声明顺序进行初始化。 基类构造函数：基类的构造函数按照它们在派生类列表中的声明顺序调用。 派生类构造函数：派生类的构造函数体中的代码在所有基类构造函数之后执行。 2.2.示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; class Base { public: Base() { std::cout \u0026lt;\u0026lt; \u0026#34;Base constructor called\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived : public Base { public: int a; int b; Derived(int x, int y) : a(x), b(y) { std::cout \u0026lt;\u0026lt; \u0026#34;Derived constructor called\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Derived obj(10, 20); return 0; } 在这个例子中，输出将是：\n1 2 Base constructor called Derived constructor called 这表明基类的构造函数首先被调用，然后才是派生类的构造函数。\n2.3.注意事项 初始化列表：成员变量和成员对象应该在构造函数的初始化列表中初始化，而不是在构造函数体中。这是因为初始化列表可以更有效地初始化成员，特别是对于常量成员和引用成员。 成员对象的构造：成员对象的构造函数会自动被调用，不需要在初始化列表中显式调用。 继承和初始化：在派生类中，基类的构造函数总是首先被调用，然后才是派生类成员的初始化。 默认构造函数：如果一个类没有显式定义任何构造函数，编译器会生成一个默认构造函数。这个默认构造函数会调用基类的默认构造函数，并按照成员变量的声明顺序进行默认初始化。 理解构造函数的调用和初始化顺序对于正确地设计和实现类非常重要，特别是在涉及到复杂的继承关系和成员初始化时。\n3.inherit 继承 在C++中，继承是面向对象编程的一个重要特性，它允许一个类（称为派生类或子类）继承另一个类（称为基类或父类）的属性和方法。继承提供了一种机制，通过这种机制，一个类可以扩展或修改另一个类的行为。\n3.1.继承的类型 公有继承（public）：基类的公有成员和保护成员在派生类中保持其原有的访问属性。 保护继承（protected）：基类的公有成员和保护成员在派生类中成为保护成员。 私有继承（private）：基类的公有成员和保护成员在派生类中成为私有成员。 3.2.访问控制 公有成员（public）：可以被任何对象访问。 保护成员（protected）：只能被类本身和子类访问。 私有成员（private）：只能被类本身访问。 3.3.示例1：公有继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; class Base { public: int publicData = 10; void publicFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;Base public function.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived : public Base { public: void derivedFunc() { publicFunc(); // 可以访问基类的公有成员 std::cout \u0026lt;\u0026lt; publicData \u0026lt;\u0026lt; std::endl; // 可以访问基类的公有成员 } }; int main() { Derived d; d.publicFunc(); // 可以访问派生类的公有继承成员 std::cout \u0026lt;\u0026lt; d.publicData \u0026lt;\u0026lt; std::endl; // 可以访问派生类的公有继承成员 d.derivedFunc(); return 0; } 3.4.示例2：保护继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; class Base { protected: int protectedData = 20; void protectedFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;Base protected function.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived : protected Base { public: void derivedFunc() { protectedFunc(); // 可以访问基类的保护成员 std::cout \u0026lt;\u0026lt; protectedData \u0026lt;\u0026lt; std::endl; // 可以访问基类的保护成员 } }; int main() { Derived d; // d.protectedFunc(); // 错误：基类的保护成员在派生类外部不可访问 // std::cout \u0026lt;\u0026lt; d.protectedData \u0026lt;\u0026lt; std::endl; // 错误：基类的保护成员在派生类外部不可访问 d.derivedFunc(); return 0; } 3.5.示例3：私有继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; class Base { private: int privateData = 30; void privateFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;Base private function.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived : private Base { public: void derivedFunc() { privateFunc(); // 可以访问基类的私有成员 std::cout \u0026lt;\u0026lt; privateData \u0026lt;\u0026lt; std::endl; // 可以访问基类的私有成员 } }; int main() { Derived d; // d.privateFunc(); // 错误：基类的私有成员在派生类外部不可访问 // std::cout \u0026lt;\u0026lt; d.privateData \u0026lt;\u0026lt; std::endl; // 错误：基类的私有成员在派生类外部不可访问 d.derivedFunc(); return 0; } 代码中存在几个问题，主要是因为基类的私有成员在派生类中无法直接访问，即使派生类继承了基类。此外，派生类的derivedFunc方法试图访问基类的私有成员，这在私有继承下是不允许的。\n3.5.1.问题 私有继承：当Derived类以私有方式继承Base类时，Base类的私有成员在Derived类中仍然是私有的，这意味着它们不能在Derived类的公共接口中被访问。\n访问限制：在Derived类的derivedFunc方法中，尝试访问Base类的私有成员privateData和privateFunc是不允许的，因为它们在Derived类中是私有的。\n3.5.2.解决方案 更改继承类型：如果需要在派生类中访问基类的私有成员，可以将继承类型改为保护继承或公有继承。\n提供访问器方法：在Base类中提供公共的访问器方法来访问私有成员。\n友元类：如果需要在派生类中访问基类的私有成员，可以将派生类声明为基类的友元类。\n3.5.3.修改后的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; class Base { private: int privateData = 30; void privateFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;Base private function.\u0026#34; \u0026lt;\u0026lt; std::endl; } public: // 提供访问器方法 int getPrivateData() const { return privateData; } void privateFuncPublic() { privateFunc(); } }; class Derived : public Base { // 改为公有继承 public: void derivedFunc() { privateFuncPublic(); // 调用公共接口访问私有成员函数 std::cout \u0026lt;\u0026lt; getPrivateData() \u0026lt;\u0026lt; std::endl; // 调用访问器方法 } }; int main() { Derived d; d.derivedFunc(); // 正确调用 return 0; } 在这个修改后的代码中，Base类提供了两个公共方法getPrivateData和privateFuncPublic来访问私有成员。Derived类通过公有继承Base类，可以访问这些公共方法。这样，Derived类的derivedFunc方法可以间接访问Base类的私有成员。\n3.5.4.注意事项 封装性：应该谨慎地暴露类的内部实现细节，以保持封装性。 继承和访问控制：继承不会改变成员的访问级别，但会影响它们在派生类中的可访问性。 友元类：使用友元类时要小心，因为它破坏了封装性，应该谨慎使用。 3.6.注意事项 继承访问控制：继承不会改变基类成员的访问控制属性，它只是影响成员在派生类中的访问控制。 友元：基类的友元在派生类中不是自动成为友元。 构造函数和析构函数：基类的构造函数和析构函数不能被继承，需要在派生类中显式调用。 多重继承：C++支持多重继承，但可能导致复杂的访问控制问题。 正确使用继承和访问控制可以提高代码的可重用性和可维护性，但也需要注意避免访问控制问题和设计上的复杂性。\n4.derive 派生 在C++中，\u0026ldquo;derive\u0026quot;通常指的是派生类的概念，即一个类（称为派生类或子类）继承另一个类（称为基类或父类）的过程。派生类可以继承基类的属性和方法，并且可以添加或修改自己的属性和方法。\n以下是派生类的一些关键点：\n公有继承（public）：这是最常见的继承类型。在公有继承中，基类的公有成员和保护成员在派生类中保持相同的访问级别。\n保护继承（protected）：在保护继承中，基类的公有成员和保护成员在派生类中都成为保护成员。这意味着它们只能在派生类及其子类中被访问。\n私有继承（private）：在私有继承中，基类的公有成员和保护成员在派生类中都成为私有成员。这意味着它们只能在派生类内部被访问。\n多重继承：C++允许一个类从多个基类继承属性和方法。\n虚拟继承：用于解决多重继承中的菱形继承问题（钻石继承）。\n4.1.示例：公有继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; // 基类 class Base { public: Base() { std::cout \u0026lt;\u0026lt; \u0026#34;Base constructor called.\\n\u0026#34;; } virtual void print() const { std::cout \u0026lt;\u0026lt; \u0026#34;Base print function.\\n\u0026#34;; } }; // 派生类 class Derived : public Base { public: Derived() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived constructor called.\\n\u0026#34;; } void print() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Derived print function.\\n\u0026#34;; } }; int main() { Derived d; d.print(); // 调用派生类的print函数 Base* b = \u0026amp;d; b-\u0026gt;print(); // 调用派生类的print函数，因为print函数是虚函数 return 0; } 在这个例子中，Derived类从Base类公有继承。Derived类有自己的print函数，覆盖了基类的print函数。\n4.2.示例：保护继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; // 基类 class Base { protected: int baseValue = 10; }; // 派生类 class Derived : protected Base { public: int getBaseValue() const { return baseValue; } }; int main() { Derived d; std::cout \u0026lt;\u0026lt; d.getBaseValue() \u0026lt;\u0026lt; std::endl; // 访问基类的保护成员 return 0; } 在这个例子中，Derived类从Base类保护继承，基类的公有成员在派生类中成为保护成员。\n4.3.示例：私有继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; // 基类 class Base { public: void baseFunction() const { std::cout \u0026lt;\u0026lt; \u0026#34;Base function.\\n\u0026#34;; } }; // 派生类 class Derived : private Base { public: void derivedFunction() const { baseFunction(); // 派生类可以访问基类的私有成员 } }; int main() { Derived d; // d.baseFunction(); // 错误：基类的私有成员在派生类外部不可访问 d.derivedFunction(); // 调用派生类的函数 return 0; } 在这个例子中，Derived类从Base类私有继承，基类的公有成员在派生类中成为私有成员。\n4.4.注意事项 派生类应该谨慎使用继承来，只有当存在\u0026quot;是一个(is-a)\u0026ldquo;关系时才使用继承。 虚函数在基类中声明，在派生类中可以被覆盖，以实现多态。 构造函数和析构函数不会自动从基类继承，需要在派生类中显式定义。 在派生类中，使用override关键字来明确指出要覆盖基类的虚函数。 使用final关键字可以防止类被进一步继承，或使用final关键字阻止虚函数被覆盖。 继承是C++中一个强大的特性，但应该谨慎使用，以避免复杂的继承层次结构和潜在的设计问题。\n4.5.虚继承 在C++中，虚继承（Virtual Inheritance）是一种解决多重继承中菱形继承问题（钻石继承结构）的机制。在没有虚继承的情况下，派生类会从基类继承两份相同的成员，这会导致数据冗余和不一致性。虚继承通过为基类创建一个单一的共享实例来解决这个问题。\n4.5.1.菱形继承问题 考虑以下情况，有两个基类B和C，它们都是从基类A派生而来，而派生类D又从B和C派生。如果没有虚继承，A的成员会被继承两次，一次来自B，一次来自C。\n1 2 3 4 5 A / \\ B C \\ / D 4.5.2.虚继承的语法 在C++中，通过在继承列表中使用virtual关键字来实现虚继承。\n4.5.3.示例：虚继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; class A { public: int data; A() { data = 10; } virtual void printData() { std::cout \u0026lt;\u0026lt; \u0026#34;A: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; } }; // 虚继承 A class B : virtual public A { public: B() { std::cout \u0026lt;\u0026lt; \u0026#34;B Constructor called\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 虚继承 A class C : virtual public A { public: C() { std::cout \u0026lt;\u0026lt; \u0026#34;C Constructor called\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 继承 B 和 C class D : public B, public C { public: D() { std::cout \u0026lt;\u0026lt; \u0026#34;D Constructor called\u0026#34; \u0026lt;\u0026lt; std::endl; } void printData() { std::cout \u0026lt;\u0026lt; \u0026#34;D: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; // 直接访问 A 的成员 } }; int main() { D d; d.printData(); // 输出 A 的数据成员 // d.B::printData(); // 错误：B 的 A 子对象是私有的 // d.C::printData(); // 错误：C 的 A 子对象是私有的 return 0; } 在这个例子中，B和C都虚继承自A，这意味着A的成员在D中只有一个共享实例。D可以直接访问A的成员。\n4.5.4.注意事项 虚基类：在虚继承中，基类A被称为虚基类。\n构造函数：虚基类的构造函数需要在派生类的构造函数中显式调用。\n访问控制：虚基类的访问级别在派生类中可能会改变。\n菱形继承：虚继承主要用于解决菱形继承问题，但也可以用于更复杂的继承结构。\n性能开销：虚继承可能会增加程序的复杂性和性能开销，因为需要维护虚基类的映射。\n虚继承和虚析构函数：虚基类的析构函数也应该声明为虚函数，以确保在删除派生类对象时正确释放资源。\n虚继承是C++中处理复杂继承关系的重要工具，但应该谨慎使用，以避免不必要的复杂性和性能问题。\n5.构造函数和析构函数的构造规则 在C++中，构造函数和析构函数是特殊的成员函数，它们在创建和销毁对象时自动调用。它们有一些特定的规则和特点：\n5.1.构造函数的规则 名称与类名相同：构造函数的名称必须与类名完全相同。\n没有返回类型：构造函数没有返回类型，也不返回任何值。\n可以被重载：一个类可以有多个构造函数，只要它们的参数列表不同。\n自动调用：当使用new运算符或在创建对象时，构造函数会被自动调用。\n初始化成员变量：构造函数可以使用成员初始化列表来初始化成员变量。\n调用基类构造函数：如果类继承自另一个类，构造函数会调用基类的构造函数。\n不能声明为const或volatile：构造函数用于创建对象，因此不能声明为const或volatile。\n5.2.析构函数的规则 名称：析构函数的名称是在类名前加上~符号。\n没有返回类型：析构函数没有返回类型，也不返回任何值。\n不能被重载：一个类只能有一个析构函数。\n自动调用：当对象离开作用域、被删除或程序结束时，析构函数会被自动调用。\n释放资源：析构函数通常用于释放对象占用的资源，如动态分配的内存、文件句柄、网络连接等。\n调用基类析构函数：如果类继承自另一个类，析构函数会调用基类的析构函数。\n可以声明为virtual：如果基类的析构函数声明为virtual，派生类的析构函数也会是虚函数。这允许通过基类指针或引用删除派生类对象时正确调用派生类的析构函数。\n5.3.示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; class Base { public: Base() { std::cout \u0026lt;\u0026lt; \u0026#34;Base constructor called\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Base() { std::cout \u0026lt;\u0026lt; \u0026#34;Base destructor called\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived : public Base { public: Derived() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived constructor called\u0026#34; \u0026lt;\u0026lt; std::endl; } ~Derived() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived destructor called\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { { Derived d; // 调用 Derived 的构造函数，然后调用 Base 的构造函数 } // d 离开作用域，调用 Derived 的析构函数，然后调用 Base 的析构函数 return 0; } 在这个例子中，当Derived对象d被创建时，首先调用Base类的构造函数，然后调用Derived类的构造函数。当d离开作用域时，首先调用Derived类的析构函数，然后调用Base类的析构函数。\n5.4.注意事项 成员初始化顺序：成员变量的初始化顺序是根据它们在类中声明的顺序，而不是它们在构造函数初始化列表中的顺序。\n构造函数和析构函数的匹配：每个对象的生命周期内，构造函数和析构函数都只调用一次。\n异常安全：构造函数不应该抛出异常，如果抛出异常，析构函数将不会被调用。\n资源管理：构造函数应该避免分配资源，以防止在构造过程中发生异常，导致资源泄漏。\n继承和构造函数：在派生类中，应该调用基类的构造函数来初始化基类部分。\n继承和析构函数：在派生类中，应该小心处理资源释放，确保基类的析构函数能够正确调用。\n理解和正确实现构造函数和析构函数对于确保对象的正确初始化和资源的正确释放至关重要。\n6.virtual 在C++中，virtual关键字用于声明虚函数，它允许在派生类中覆盖（override）基类的函数，并实现多态性。多态性是指允许不同类的对象对同一消息做出不同的响应。\n6.1.虚函数的特点 基类中声明：虚函数通常在基类中声明，并使用virtual关键字。\n派生类中覆盖：派生类可以覆盖基类的虚函数，提供特定的实现。\n动态绑定：在运行时，根据对象的实际类型调用相应的函数，而不是在编译时确定。\n使用override：在派生类中覆盖虚函数时，使用override关键字可以明确指出函数的覆盖意图，有助于编译器检查错误。\n使用virtual在析构函数：如果基类的析构函数声明为virtual，那么通过基类指针或引用删除派生类对象时，将正确调用派生类的析构函数。\n6.2.示例1：虚函数和覆盖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; class Base { public: virtual void print() const { std::cout \u0026lt;\u0026lt; \u0026#34;Base print function.\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Base() {} // 虚析构函数 }; class Derived : public Base { public: void print() const override { // 使用override关键字 std::cout \u0026lt;\u0026lt; \u0026#34;Derived print function.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Base* b = new Derived(); b-\u0026gt;print(); // 调用Derived的print函数 delete b; // 调用Derived的析构函数 return 0; } 在这个例子中，Base类有一个虚函数print，Derived类覆盖了这个函数。在main函数中，通过基类指针b调用print函数时，实际上调用的是Derived类的print函数。\n6.3.示例2：虚析构函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; class Base { public: virtual ~Base() { std::cout \u0026lt;\u0026lt; \u0026#34;Base destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived : public Base { public: ~Derived() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Base* b = new Derived(); delete b; // 调用Derived的析构函数，然后调用Base的析构函数 return 0; } 在这个例子中，Base类的析构函数被声明为虚函数。当删除基类指针b时，首先调用Derived类的析构函数，然后调用Base类的析构函数。\n在C++中，虚析构函数是一种重要的设计选择，特别是在处理继承体系时。它确保了当一个对象是通过基类的指针或引用被删除时，正确的析构函数链被调用，从而保证了资源的正确释放。\n6.3.1.为什么需要虚析构函数？ 在多重继承或简单的继承体系中，如果基类的析构函数不是虚的，那么在删除派生类对象时，基类的析构函数可能不会被调用。这可能导致资源泄漏，因为派生类的析构函数通常负责释放它分配的资源。\n6.3.2.示例1：没有虚析构函数的问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; class Base { public: ~Base() { std::cout \u0026lt;\u0026lt; \u0026#34;Base destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived : public Base { public: ~Derived() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Base* b = new Derived(); delete b; // 问题：Derived的析构函数没有被调用 return 0; } 在这个例子中，当b被删除时，只有Base的析构函数被调用，而Derived的析构函数没有被调用。\n6.3.3.示例2：使用虚析构函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; class Base { public: virtual ~Base() { std::cout \u0026lt;\u0026lt; \u0026#34;Base destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived : public Base { public: ~Derived() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Base* b = new Derived(); delete b; // 正确：Derived的析构函数首先被调用，然后是Base的析构函数 return 0; } 在这个修正后的代码中，Base的析构函数被声明为虚函数。当b被删除时，首先调用Derived的析构函数，然后调用Base的析构函数。\n6.3.4.注意事项 声明虚析构函数：在基类中，将析构函数声明为virtual，以确保在删除派生类对象时，正确的析构函数链被调用。\n多重继承：在多重继承中，每个基类都应该有一个虚析构函数，以确保所有基类的析构函数都能被正确调用。\n资源管理：确保在派生类的析构函数中正确释放资源。\n虚析构函数和纯虚函数：虚析构函数通常与纯虚函数一起使用，以实现多态和确保正确的资源释放。\n虚析构函数和对象切片：在处理对象切片时，虚析构函数可以确保派生类的部分被正确销毁。\n虚析构函数是C++中实现良好面向对象设计的关键部分，它有助于避免资源泄漏并确保资源的正确管理。\n6.4.注意事项 虚函数和继承：只有公有继承的虚函数才能在派生类中被覆盖。\n虚函数和静态类型：虚函数的调用依赖于对象的静态类型，而不是动态类型。如果通过基类类型的引用或指针调用虚函数，将调用对象实际类型的函数。\n虚函数和构造函数：构造函数不能是虚函数，因为对象在构造过程中尚未完全构造好。\n纯虚函数：使用= 0可以声明一个纯虚函数，它没有实现，并且使得类成为抽象类。派生类必须覆盖所有的纯虚函数才能创建对象。\nfinal关键字：可以使用final关键字阻止虚函数被进一步覆盖。\n正确使用虚函数可以提高代码的灵活性和可扩展性，但也需要仔细设计，以避免滥用和复杂的继承关系。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T00:59:43+08:00","permalink":"https://wesigj.github.io/p/c-practical-1-day5/","title":"C++ Practical-1 day5"},{"content":"C++ Practical-1 day4 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.operator 在C++中，运算符重载（Operator Overloading）是一种使得开发者可以为自定义类型（如类和结构体）提供已有运算符的新意义的功能。这使得自定义类型的使用更加直观和自然。\n1.1.运算符重载的规则 除了.*和::，几乎所有的C++运算符都可以被重载。 运算符重载函数必须是类的成员函数。 =（赋值运算符）和[]（下标运算符）不能为const成员函数。 =（赋值运算符）必须为类的成员函数。 不能创建新的运算符。 不能改变运算符的优先级和结合性。 1.2.示例1：重载加法运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; class Point { public: int x, y; Point(int px, int py) : x(px), y(py) {} // 重载加法运算符 Point operator+(const Point\u0026amp; rhs) const { return Point(x + rhs.x, y + rhs.y); } }; int main() { Point p1(1, 2); Point p2(3, 4); Point p3 = p1 + p2; std::cout \u0026lt;\u0026lt; \u0026#34;p3: (\u0026#34; \u0026lt;\u0026lt; p3.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p3.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 1.3.示例2：重载赋值运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; class Person { public: std::string name; int age; Person(const std::string\u0026amp; n, int a) : name(n), age(a) {} // 重载赋值运算符 Person\u0026amp; operator=(const Person\u0026amp; rhs) { if (this != \u0026amp;rhs) { name = rhs.name; age = rhs.age; } return *this; } }; int main() { Person p1(\u0026#34;Alice\u0026#34;, 30); Person p2 = p1; std::cout \u0026lt;\u0026lt; \u0026#34;p2: \u0026#34; \u0026lt;\u0026lt; p2.name \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; std::endl; return 0; } 1.4.示例3：重载下标运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; class Matrix { private: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; data; public: Matrix(int rows, int cols) { data.resize(rows, std::vector\u0026lt;int\u0026gt;(cols)); } // 重载下标运算符 int\u0026amp; operator[](int index) { return data[index][0]; // Simplified for demonstration } }; int main() { Matrix mat(2, 2); mat[0] = 1; mat[1] = 2; std::cout \u0026lt;\u0026lt; \u0026#34;mat[0]: \u0026#34; \u0026lt;\u0026lt; mat[0] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;mat[1]: \u0026#34; \u0026lt;\u0026lt; mat[1] \u0026lt;\u0026lt; std::endl; return 0; } 1.5.示例4：重载递增运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; class Counter { private: int count; public: Counter() : count(0) {} // 重载前置递增运算符 Counter\u0026amp; operator++() { ++count; return *this; } // 重载后置递增运算符 Counter operator++(int) { Counter temp = *this; ++(*this); return temp; } void display() const { std::cout \u0026lt;\u0026lt; count \u0026lt;\u0026lt; std::endl; } }; int main() { Counter c; std::cout \u0026lt;\u0026lt; \u0026#34;Before increment: \u0026#34;; c.display(); ++c; std::cout \u0026lt;\u0026lt; \u0026#34;After prefix increment: \u0026#34;; c.display(); c++; std::cout \u0026lt;\u0026lt; \u0026#34;After postfix increment: \u0026#34;; c.display(); return 0; } 1.6.注意事项 运算符重载应该保持运算符原有的语义，除非有充分的理由。 运算符重载应该保持一致性，例如，如果你重载了+，可能也需要重载-、*和/。 运算符重载应该考虑效率，避免不必要的对象创建和复制。 对于复杂的类，考虑重载流插入运算符\u0026lt;\u0026lt;和流提取运算符\u0026gt;\u0026gt;，以方便地输出和输入对象。 运算符重载是C++中一个强大的特性，但应该谨慎使用，以避免使代码难以理解和维护。\n2.const 在C++中，const关键字用于定义常量值，保证数据的安全性和稳定性。使用const可以防止数据被意外修改，同时也有助于代码的自我说明。\n2.1.const的用途 定义常量：确保变量的值不会改变。 修饰函数参数：防止函数内部修改参数值。 修饰函数返回值：确保返回值不会被修改。 修饰成员函数：表明成员函数不会修改对象的状态。 修饰指针：定义指向常量的指针或常指针。 2.2.示例1：定义常量 1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; int main() { const int hours = 24; // 定义一个常量 std::cout \u0026lt;\u0026lt; \u0026#34;Number of hours in a day: \u0026#34; \u0026lt;\u0026lt; hours \u0026lt;\u0026lt; std::endl; // hours = 25; // 错误：不能修改常量 return 0; } 2.3.示例2：修饰函数参数 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; void printMessage(const std::string\u0026amp; message) { std::cout \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; // message = \u0026#34;Hello\u0026#34;; // 错误：不能修改const引用 } int main() { printMessage(\u0026#34;Hello, World!\u0026#34;); return 0; } 2.4.示例3：修饰函数返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; const std::string getCurrentTime() { // 假设这是一个获取当前时间的函数 return \u0026#34;14:00\u0026#34;; } int main() { std::string time = getCurrentTime(); // time = getCurrentTime(); // 错误：不能修改const返回值 std::cout \u0026lt;\u0026lt; \u0026#34;Current time: \u0026#34; \u0026lt;\u0026lt; time \u0026lt;\u0026lt; std::endl; return 0; } 2.5.示例4：修饰成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; class Clock { private: int hour; int minute; public: Clock(int h, int m) : hour(h), minute(m) {} void setTime(int h, int m) { hour = h; minute = m; } // const成员函数 void displayTime() const { std::cout \u0026lt;\u0026lt; \u0026#34;Current time: \u0026#34; \u0026lt;\u0026lt; hour \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; minute \u0026lt;\u0026lt; std::endl; // setTime(12, 0); // 错误：不能在const成员函数中调用非const成员函数 } }; int main() { Clock myClock(11, 59); myClock.displayTime(); // 可以调用const成员函数 return 0; } 2.6.示例5：修饰指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; int main() { const int value = 42; const int *ptr = \u0026amp;value; // 指针ptr可以改变指向，但通过ptr不能修改value的值 // *ptr = 100; // 错误：尝试修改const变量 const int *constPtr = \u0026amp;value; // constPtr是一个指向const值的const指针，既不能改变指向，也不能通过constPtr修改值 // *constPtr = 100; // 错误：尝试修改const变量 // constPtr = \u0026amp;value; // 错误：尝试改变const指针的指向 int anotherValue = 24; int *const constPtr2 = \u0026amp;anotherValue; // constPtr2是一个指向int的const指针，不能改变指向，但可以通过constPtr2修改值 constPtr2 = \u0026amp;value; // 错误：尝试改变const指针的指向 return 0; } 2.7.注意事项 const修饰的变量必须在定义时初始化。 const成员函数不能修改对象的任何成员变量（除非成员变量也是mutable）。 const指针可以有多种组合，如指向常量的指针（const int*）、常指针（int* const）和指向常量的常指针（const int* const）。 const在函数参数中使用时，通常为引用或指针，以避免不必要的复制。 使用const可以帮助保证程序的稳定性，防止意外修改，同时也有助于提高代码的可读性和可维护性。\n3.拷贝构造函数 在C++中，拷贝构造函数是一种特殊的构造函数，它用于创建一个对象的新实例，该实例是另一个同类型对象的副本。拷贝构造函数在多种情况下会被自动调用，例如：\n当一个对象作为函数的返回值时。 当一个对象被用作函数参数传递时（通过值传递，而不是引用）。 当创建一个对象的副本时（例如，使用new运算符）。 3.1.拷贝构造函数的语法 1 2 3 4 5 class ClassName { public: ClassName(const ClassName\u0026amp; other); // 声明拷贝构造函数 // ... }; 3.2.示例1：简单的拷贝构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; class Point { public: int x, y; Point() : x(0), y(0) {} // 拷贝构造函数 Point(const Point\u0026amp; other) : x(other.x), y(other.y) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy constructor called\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Point p1; Point p2 = p1; // 调用拷贝构造函数 return 0; } 在这个例子中，Point类有一个拷贝构造函数，它接受一个对Point类型的引用，并初始化成员变量x和y。\n3.3.示例2：使用std::copy算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; class Point { public: int x, y; Point() : x(0), y(0) { // 默认构造函数 } // 拷贝构造函数 Point(const Point \u0026amp;other) : x(other.x), y(other.y) { std::cout \u0026lt;\u0026lt; \u0026#34;Copy constructor called\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { std::vector\u0026lt;Point\u0026gt; vec1; vec1.emplace_back(1, 2); // 使用emplace_back避免不必要的拷贝 vec1.emplace_back(3, 4); // 创建一个新的向量，包含vec1中所有元素的副本 std::vector\u0026lt;Point\u0026gt; vec2(vec1.begin(), vec1.end()); return 0; } 在这个例子中，我们使用了std::copy算法（通过vector的构造函数）来复制vec1中的所有元素到vec2。\n3.4.示例3：深拷贝和浅拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; class StringHolder { public: StringHolder() : data(nullptr) {} // 拷贝构造函数 StringHolder(const StringHolder\u0026amp; other) { data = new char[strlen(other.data) + 1]; strcpy(data, other.data); } ~StringHolder() { delete[] data; } private: char* data; }; int main() { StringHolder holder1; holder1.data = new char[6]; strcpy(holder1.data, \u0026#34;Hello\u0026#34;); StringHolder holder2 = holder1; // 调用拷贝构造函数 std::cout \u0026lt;\u0026lt; holder1.data \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; holder2.data \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，StringHolder类有一个指向动态分配的字符数组的指针。拷贝构造函数确保了数据被正确复制，这是一个深拷贝的例子。\n上面代码中存在几个问题，需要修正：\n成员变量data应该是public：为了让main函数能够访问data成员变量，你需要将其访问权限改为public。但是，通常我们不建议这样做，因为这样会破坏封装性。更好的做法是在类内部提供访问和修改成员变量的方法。\n深拷贝问题：在StringHolder的拷贝构造函数中，你正确地实现了深拷贝。但是，由于data是private成员，你不能在main函数中直接访问它。\n析构函数问题：析构函数应该确保释放分配的内存。这部分代码是正确的。\n使用new和delete[]：在main函数中，你使用了new来分配内存，这是正确的。但是，你应该在StringHolder类中封装这些操作，以保持资源的获取和释放的一致性。\n缺少赋值运算符：你的类缺少赋值运算符，这可能会导致意外的行为，特别是当对象作为函数参数传递时。\n缺少拷贝赋值运算符：为了避免浅拷贝问题，你应该实现一个拷贝赋值运算符。\n下面是修正后的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; class StringHolder { public: StringHolder() : data(nullptr) { } // 拷贝构造函数 StringHolder(const StringHolder \u0026amp;other) { if (other.data) { data = new char[strlen(other.data) + 1]; strcpy(data, other.data); } else { data = nullptr; } } // 赋值运算符 StringHolder\u0026amp; operator=(const StringHolder \u0026amp;other) { if (this != \u0026amp;other) { delete[] data; if (other.data) { data = new char[strlen(other.data) + 1]; strcpy(data, other.data); } else { data = nullptr; } } return *this; } ~StringHolder() { delete[] data; } // 添加一个方法来设置字符串 void setString(const char* str) { delete[] data; if (str) { data = new char[strlen(str) + 1]; strcpy(data, str); } else { data = nullptr; } } // 添加一个方法来获取字符串 const char* getString() const { return data; } private: char *data; }; int main() { StringHolder holder1; holder1.setString(\u0026#34;Hello\u0026#34;); StringHolder holder2 = holder1; // 调用拷贝构造函数 std::cout \u0026lt;\u0026lt; holder1.getString() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; holder2.getString() \u0026lt;\u0026lt; std::endl; return 0; } 在这个修正后的代码中，我添加了setString和getString方法来安全地设置和获取data成员变量的值。同时，我也实现了赋值运算符来确保对象可以通过赋值操作正确地复制。这样，你就不需要直接访问data成员变量了。\n3.5.注意事项 如果没有提供拷贝构造函数，编译器会生成一个默认的拷贝构造函数，它进行逐成员的拷贝，但对于含有指针成员的类，这可能会导致浅拷贝问题。 拷贝构造函数通常应该进行深拷贝，特别是当类包含指向动态分配资源的指针时。 在实现拷贝构造函数时，应该检查自赋值的情况，即当新对象是从它自身的副本创建时。 C++11引入了default关键字，可以用来显式地告诉编译器生成默认的拷贝构造函数：ClassName(const ClassName\u0026amp;) = default;。 正确实现拷贝构造函数对于确保资源的正确管理和避免内存泄漏非常重要。\n4.friend 在C++中，friend关键字用于声明友谊关系，使得一个函数或类能够访问另一个类的私有（private）或保护（protected）成员。这通常用于当一个类需要访问另一个类的内部数据，或者当需要优化性能时，比如在实现某些操作时避免使用成员函数。\n4.1.friend的用途 访问类的私有成员：允许非成员函数或另一个类的成员函数访问类的私有成员。 优化性能：允许函数直接访问数据成员，避免使用成员函数的开销。 实现操作符重载：允许非成员函数重载操作符，以便访问类的私有数据。 4.2.示例1：使用friend函数访问私有数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; class Account { private: double balance; public: Account(double initialBalance) : balance(initialBalance) {} // 声明friend函数 friend void displayBalance(const Account\u0026amp; account); }; // friend函数定义 void displayBalance(const Account\u0026amp; account) { std::cout \u0026lt;\u0026lt; \u0026#34;The balance is: $\u0026#34; \u0026lt;\u0026lt; account.balance \u0026lt;\u0026lt; std::endl; } int main() { Account myAccount(1000.0); displayBalance(myAccount); return 0; } 在这个例子中，displayBalance是一个friend函数，它可以直接访问Account类的私有成员balance。\n4.3.示例2：使用friend类实现互操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; class Date; // 前向声明 class Newspaper { private: Date publicationDate; // Newspaper依赖于Date类 std::string headline; public: friend class Date; // 声明Date为友元类 void printHeadline() const { std::cout \u0026lt;\u0026lt; headline \u0026lt;\u0026lt; std::endl; } }; class Date { private: int day; int month; int year; public: Date(int d, int m, int y) : day(d), month(m), year(y) {} // 访问Newspaper的私有成员 void printPublicationDate(const Newspaper\u0026amp; newspaper) const { std::cout \u0026lt;\u0026lt; \u0026#34;Published on: \u0026#34; \u0026lt;\u0026lt; day \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; month \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; year \u0026lt;\u0026lt; std::endl; } }; int main() { Newspaper newspaper(Date(25, 12, 2023)); newspaper.printHeadline(); newspaper.publicationDate.printPublicationDate(newspaper); return 0; } 在这个例子中，Date类被声明为Newspaper类的friend类，这样Date类就可以访问Newspaper类的私有成员publicationDate。\n代码中存在几个问题，需要修正：\n前向声明问题：Date 类在 Newspaper 类中被前向声明，这是正确的。但是，前向声明不允许你使用 Date 类型的成员变量，除非它是指针或引用。\n友元类声明问题：你不能在 Newspaper 类中声明 Date 为友元类，因为 Date 类还没有被完整定义。友元声明应该在 Date 类中进行。\n成员访问问题：Date 类的成员变量是私有的，所以 Newspaper 类不能直接访问它们。你需要在 Date 类中提供访问器方法。\nDate 类的构造函数问题：在 main 函数中，你尝试使用 Date(25, 12, 2023) 来初始化 newspaper 对象，但是 Date 类的构造函数需要三个参数，而且 newspaper 的初始化应该使用 Date 类型的对象。\nprintPublicationDate 方法的参数问题：printPublicationDate 方法尝试打印 Newspaper 对象的私有成员，但是它没有 const 修饰的引用参数。\nmain 函数中的调用错误：newspaper.publicationDate.printPublicationDate(newspaper); 这行代码是错误的，因为 publicationDate 是 Date 类型的对象，而不是 Newspaper 类型的对象。\n下面是修正后的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; class Date; // 前向声明 class Newspaper { private: Date publicationDate; // Newspaper依赖于Date类 std::string headline; public: Newspaper(const Date\u0026amp; date, const std::string\u0026amp; head) : publicationDate(date), headline(head) {} void printHeadline() const { std::cout \u0026lt;\u0026lt; headline \u0026lt;\u0026lt; std::endl; } // 允许Date类访问Newspaper的私有成员 friend class Date; }; class Date { private: int day; int month; int year; public: Date(int d, int m, int y) : day(d), month(m), year(y) {} // 访问Newspaper的私有成员 void printPublicationDate(const Newspaper\u0026amp; newspaper) const { std::cout \u0026lt;\u0026lt; \u0026#34;Published on: \u0026#34; \u0026lt;\u0026lt; day \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; month \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; year \u0026lt;\u0026lt; std::endl; } // 友元函数声明 friend void displayDate(const Date\u0026amp; date, const Newspaper\u0026amp; newspaper); }; // 友元函数定义 void displayDate(const Date\u0026amp; date, const Newspaper\u0026amp; newspaper) { std::cout \u0026lt;\u0026lt; \u0026#34;Newspaper published on: \u0026#34; \u0026lt;\u0026lt; date.day \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; date.month \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; date.year \u0026lt;\u0026lt; \u0026#34; with headline: \u0026#34; \u0026lt;\u0026lt; newspaper.headline \u0026lt;\u0026lt; std::endl; } int main() { Date date(25, 12, 2023); Newspaper newspaper(date, \u0026#34;Hello, World!\u0026#34;); newspaper.printHeadline(); displayDate(date, newspaper); return 0; } 在这个修正后的代码中，我添加了一个友元函数 displayDate，它可以接受 Date 和 Newspaper 对象作为参数，并打印出日期和标题。同时，我也修正了 Newspaper 类的构造函数，以便正确地初始化 publicationDate 和 headline 成员变量。最后，我在 main 函数中正确地初始化了 date 和 newspaper 对象，并调用了 displayDate 友元函数。\n4.4.示例3：重载\u0026lt;\u0026lt;操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; class Person { private: std::string name; public: Person(const std::string\u0026amp; n) : name(n) {} // 声明友元函数 friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Person\u0026amp; person); }; // 重载\u0026lt;\u0026lt;操作符 std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Person\u0026amp; person) { os \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; person.name; return os; } int main() { Person person(\u0026#34;Alice\u0026#34;); std::cout \u0026lt;\u0026lt; person \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，operator\u0026lt;\u0026lt;被重载以允许直接将Person对象输出到std::ostream（如std::cout）。\n4.5.注意事项 过度使用friend可能会导致代码的封装性变差，因为friend破坏了类之间的封装界限。 friend函数不是类的成员函数，因此它们不能直接访问类的成员，而是需要通过参数传递对象。 friend声明应该放在类的公共（public）部分。 friend声明不会继承，每个需要访问私有成员的类或函数都必须显式声明为friend。 使用friend时应该谨慎，以保持代码的清晰性和封装性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T00:59:42+08:00","permalink":"https://wesigj.github.io/p/c-practical-1-day4/","title":"C++ Practical-1 day4"},{"content":"C++ Practical-1 day3 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.inline 在C++中，inline 关键字是一种函数修饰符，用于建议编译器在编译时将函数的代码直接插入到每个函数调用的地方，从而避免函数调用的开销。这通常用于小型函数，特别是那些包含少量指令的函数。\n1.1.作用和优点 减少函数调用开销：通过避免函数调用的额外开销，可以提高程序的执行效率。 多个定义：inline 函数允许在程序中有多个定义点，这对于模板元编程特别有用。 模板：与模板结合使用时，inline 函数可以确保模板代码在每个使用点都得到实例化。 1.2.示例1：简单的内联函数 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; // 内联函数定义 inline int add(int a, int b) { return a + b; } int main() { int result = add(5, 3); std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，add 函数被定义为内联函数。这意味着编译器将尝试在每次调用 add 时直接将其代码替换为 return a + b;。\n1.3.示例2：内联成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; class Calculator { public: // 内联成员函数 inline int add(int a, int b) const { return a + b; } }; int main() { Calculator calc; int result = calc.add(5, 3); std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，Calculator 类的 add 成员函数被定义为内联函数。\n1.4.示例3：内联函数与模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; // 内联模板函数 template \u0026lt;typename T\u0026gt; inline T max(T a, T b) { return (a \u0026gt; b) ? a : b; } int main() { int i = max(3, 7); double d = max(6.4, 3.2); std::cout \u0026lt;\u0026lt; \u0026#34;Max int: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Max double: \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，max 函数是一个模板内联函数，它可以用于不同的数据类型。\n1.5.注意事项 编译器优化：虽然你可以通过 inline 关键字请求内联，但最终是否内联由编译器决定。编译器可能会忽略内联请求，特别是对于较大的函数。 定义点：对于内联函数，定义必须在包含它的每个源文件中可见。对于模板和类内的内联函数，定义通常与声明一起放在头文件中。 递归函数：递归函数通常不会被内联，因为递归调用可能导致大量的代码膨胀。 inline 关键字是一个有力的工具，可以帮助优化程序性能，特别是在调用小型函数时。然而，它应该谨慎使用，以避免潜在的代码膨胀和维护问题。\n2.函数综合练习题 当然，这里有一个C++函数的综合练习题，包括问题描述、代码实现和答案解析。\n2.1.练习题1：计算阶乘 问题描述： 编写一个C++程序，计算并输出一个给定非负整数的阶乘。阶乘函数定义为：n! = n * (n-1) * (n-2) * \u0026hellip; * 3 * 2 * 1。0的阶乘定义为1。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; unsigned long long factorial(int n) { if (n == 0) return 1; unsigned long long result = 1; for (int i = 1; i \u0026lt;= n; ++i) { result *= i; } return result; } int main() { int number; std::cout \u0026lt;\u0026lt; \u0026#34;Enter a non-negative integer: \u0026#34;; std::cin \u0026gt;\u0026gt; number; if (number \u0026lt; 0) { std::cout \u0026lt;\u0026lt; \u0026#34;Factorial is not defined for negative numbers.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Factorial of \u0026#34; \u0026lt;\u0026lt; number \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; factorial(number) \u0026lt;\u0026lt; std::endl; } return 0; } 答案解析： 这个程序定义了一个factorial函数，它使用一个循环来计算阶乘。主函数读取用户输入的非负整数，并调用factorial函数计算阶乘。\n2.2.练习题2：寻找数组中的最大值和最小值 问题描述： 编写一个C++程序，找出一个整数数组中的最大值和最小值，并输出它们。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;limits\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; numbers = {3, 9, 1, 4, 5, 7, 8, 2, 6}; int max_value = std::numeric_limits\u0026lt;int\u0026gt;::min(); int min_value = std::numeric_limits\u0026lt;int\u0026gt;::max(); for (int num : numbers) { if (num \u0026gt; max_value) { max_value = num; } if (num \u0026lt; min_value) { min_value = num; } } std::cout \u0026lt;\u0026lt; \u0026#34;Max value: \u0026#34; \u0026lt;\u0026lt; max_value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Min value: \u0026#34; \u0026lt;\u0026lt; min_value \u0026lt;\u0026lt; std::endl; return 0; } 答案解析： 这个程序使用std::vector存储整数数组。它初始化两个变量max_value和min_value来存储数组中的最大值和最小值，然后遍历数组，使用条件语句来更新这两个变量的值。\n2.3.练习题3：计算字符串中字符的出现次数 问题描述： 编写一个C++程序，计算并输出一个给定字符串中每个字符的出现次数。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; int main() { std::string text; std::cout \u0026lt;\u0026lt; \u0026#34;Enter a string: \u0026#34;; std::getline(std::cin, text); std::unordered_map\u0026lt;char, int\u0026gt; char_count; for (char c : text) { char_count[c]++; } std::cout \u0026lt;\u0026lt; \u0026#34;Character counts:\u0026#34; \u0026lt;\u0026lt; std::endl; for (const auto \u0026amp;kv : char_count) { std::cout \u0026lt;\u0026lt; kv.first \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; kv.second \u0026lt;\u0026lt; std::endl; } return 0; } 答案解析： 这个程序使用std::unordered_map来存储每个字符及其出现的次数。它遍历字符串中的每个字符，并使用字符作为键来更新计数器。最后，它遍历映射并输出每个字符及其计数。\n2.4.练习题4：实现一个简单的计算器 问题描述： 编写一个C++程序，实现一个简单的计算器，能够执行加、减、乘、除四种运算。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; double add(double a, double b) { return a + b; } double subtract(double a, double b) { return a - b; } double multiply(double a, double b) { return a * b; } double divide(double a, double b) { if (b != 0) { return a / b; } else { std::cerr \u0026lt;\u0026lt; \u0026#34;Error: Division by zero\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } } int main() { double num1, num2; char operation; std::cout \u0026lt;\u0026lt; \u0026#34;Enter first number: \u0026#34;; std::cin \u0026gt;\u0026gt; num1; std::cout \u0026lt;\u0026lt; \u0026#34;Enter second number: \u0026#34;; std::cin \u0026gt;\u0026gt; num2; std::cout \u0026lt;\u0026lt; \u0026#34;Enter operation (+, -, *, /): \u0026#34;; std::cin \u0026gt;\u0026gt; operation; switch (operation) { case \u0026#39;+\u0026#39;: std::cout \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; add(num1, num2) \u0026lt;\u0026lt; std::endl; break; case \u0026#39;-\u0026#39;: std::cout \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; \u0026#34; - \u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; subtract(num1, num2) \u0026lt;\u0026lt; std::endl; break; case \u0026#39;*\u0026#39;: std::cout \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; \u0026#34; * \u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; multiply(num1, num2) \u0026lt;\u0026lt; std::endl; break; case \u0026#39;/\u0026#39;: std::cout \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; \u0026#34; / \u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; divide(num1, num2) \u0026lt;\u0026lt; std::endl; break; default: std::cerr \u0026lt;\u0026lt; \u0026#34;Invalid operation\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 答案解析： 这个程序定义了四个函数来执行基本的算术运算。主函数读取用户输入的两个数字和一个运算符，然后根据运算符调用相应的函数并输出结果。如果用户尝试除以零，程序会输出错误消息。\n这些练习题覆盖了函数定义、循环、条件语句、输入输出和基本的算术运算，适合用来练习C++函数的使用。\n3.前向声明 在C++中，类前向声明（forward declaration）是一种声明类的方式，而不定义类的具体内容。这在你需要引用某个类，但又不想包含定义该类的头文件时非常有用。前向声明通常用于类的指针或引用，以及当两个或多个类相互引用时。\n3.1.为什么需要前向声明？ 避免头文件的循环依赖：当两个或多个类相互引用时，可能会导致头文件的循环依赖问题。前向声明可以打破这种循环依赖。\n减少包含头文件：如果你只需要使用类的指针或引用，而不是完整的类定义，前向声明可以减少包含头文件的需要，从而减少编译时间。\n3.2.如何前向声明一个类？ 使用class关键字加上类名来进行前向声明，如下所示：\n1 class MyClass; // 前向声明 3.3.示例1：避免循环依赖 假设有两个类A和B，类A有一个类B的成员，而类B有一个类A的成员。下面是如何使用前向声明来解决这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // A.h #ifndef A_H #define A_H class B; // 前向声明类B class A { B* b_ptr; // 类B的指针 public: A(B* b); // ... }; #endif // A_H 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // B.h #ifndef B_H #define B_H #include \u0026#34;A.h\u0026#34; // 包含A.h以获取A的前向声明 class B { A* a_ptr; // 类A的指针 public: B(A* a); // ... }; #endif // B_H 在这个例子中，A.h前向声明了类B，而B.h包含了A.h以获取类A的前向声明。这样，两个类就可以相互引用，而不会直接包含对方的完整定义。\n3.4.示例2：使用类指针或引用 如果你只需要使用类的指针或引用，而不需要完整的类定义，可以使用前向声明：\n1 2 3 4 5 6 7 8 9 // ForwardDeclaration.h #ifndef FORWARDDECLARATION_H #define FORWARDDECLARATION_H class ForwardClass; // 前向声明 void function(ForwardClass\u0026amp; obj); // 使用前向声明的类的引用 #endif // FORWARDDECLARATION_H 1 2 3 4 5 6 7 // ForwardDeclaration.cpp #include \u0026#34;ForwardDeclaration.h\u0026#34; #include \u0026#34;ForwardClass.h\u0026#34; // 实际定义 void function(ForwardClass\u0026amp; obj) { // ... } 在这个例子中，ForwardDeclaration.h前向声明了ForwardClass，而ForwardDeclaration.cpp包含了ForwardClass.h以获取完整的类定义。\n3.5.注意事项 前向声明只能用于声明类的指针、引用或作为参数传递对象。如果你需要创建类的对象实例或访问其成员，就必须包含完整的类定义。\n前向声明不适用于需要知道类大小或布局的情况。\n过度使用前向声明可能会使代码难以理解和维护，因为它隐藏了类的实际定义，所以在使用时应该谨慎。\n4.swap函数 在C++中，swap函数是一个非常有用的函数，它用于交换两个变量的值。C++标准库提供了std::swap函数，但你也可以自己实现一个简单的swap函数来加深理解。\n以下是一个简单的swap函数实现，以及如何在程序中使用它：\n4.1.示例1：自定义swap函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; // 自定义swap函数 template \u0026lt;typename T\u0026gt; void swap(T\u0026amp; a, T\u0026amp; b) { T temp = a; a = b; b = temp; } int main() { int x = 10; int y = 20; std::cout \u0026lt;\u0026lt; \u0026#34;Before swap: x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; swap(x, y); std::cout \u0026lt;\u0026lt; \u0026#34;After swap: x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; return 0; } 4.2.示例2：使用std::swap C++标准库提供了一个std::swap函数，你可以使用它来交换两个变量的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // 包含std::swap int main() { int x = 10; int y = 20; std::cout \u0026lt;\u0026lt; \u0026#34;Before swap: x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; std::swap(x, y); std::cout \u0026lt;\u0026lt; \u0026#34;After swap: x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; return 0; } 4.3.示例3：交换类对象 如果你有一个类，并希望交换两个对象，你可以在你的类中提供swap成员函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; class MyClass { public: int value; MyClass(int val) : value(val) {} friend void swap(MyClass\u0026amp; a, MyClass\u0026amp; b) { using std::swap; swap(a.value, b.value); } }; int main() { MyClass obj1(10); MyClass obj2(20); std::cout \u0026lt;\u0026lt; \u0026#34;Before swap: obj1 = \u0026#34; \u0026lt;\u0026lt; obj1.value \u0026lt;\u0026lt; \u0026#34;, obj2 = \u0026#34; \u0026lt;\u0026lt; obj2.value \u0026lt;\u0026lt; std::endl; swap(obj1, obj2); std::cout \u0026lt;\u0026lt; \u0026#34;After swap: obj1 = \u0026#34; \u0026lt;\u0026lt; obj1.value \u0026lt;\u0026lt; \u0026#34;, obj2 = \u0026#34; \u0026lt;\u0026lt; obj2.value \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，MyClass有一个value成员变量。我们定义了一个swap友元函数来交换两个MyClass对象的value成员。\n4.4.注意事项 当使用std::swap时，如果类型提供了自己的swap特化版本，编译器将使用该特化版本而不是标准库中的通用版本。\n自定义swap函数时，使用模板可以使其适用于任何类型的数据。\n在实现类时，提供一个swap成员函数或友元函数可以确保你的类对象可以正确地使用std::swap。\n交换操作应该尽可能地高效，避免不必要的复制，特别是对于大型对象。这就是为什么在自定义swap函数时通常使用std::swap或临时变量来减少复制次数。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T00:59:41+08:00","permalink":"https://wesigj.github.io/p/c-practical-1-day3/","title":"C++ Practical-1 day3"},{"content":"C++ Practical-1 day2 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.求π 计算圆周率 (\\pi) 的值可以通过多种算法实现。这里提供一个简单的 C++ 程序，使用莱布尼茨公式（Leibniz formula）来近似计算 (\\pi) 的值。莱布尼茨公式是一个无穷级数，可以用来计算 (\\pi)，公式如下：\n[ \\pi = 4 \\times \\left(1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\frac{1}{9} - \\cdots \\right) ]\n下面是一个使用莱布尼茨公式计算 (\\pi) 的 C++ 程序示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; double calculatePi(int terms) { double sum = 0.0; for (int i = 0; i \u0026lt; terms; i++) { // 交替加减1/(2n-1) if (i % 2 == 0) sum += 1.0 / (2 * i + 1); else sum -= 1.0 / (2 * i + 1); } return 4 * sum; } int main() { int terms; std::cout \u0026lt;\u0026lt; \u0026#34;Enter the number of terms to approximate Pi: \u0026#34;; std::cin \u0026gt;\u0026gt; terms; double pi = calculatePi(terms); std::cout \u0026lt;\u0026lt; \u0026#34;Calculated Pi: \u0026#34; \u0026lt;\u0026lt; std::setprecision(15) \u0026lt;\u0026lt; pi \u0026lt;\u0026lt; std::endl; return 0; } 1.1.程序说明 函数 calculatePi：这个函数接受一个整数 terms 作为参数，表示级数的项数。函数通过循环计算莱布尼茨级数的和，然后乘以 4 得到 (\\pi) 的近似值。 主函数：程序首先提示用户输入想要使用的项数。然后调用 calculatePi 函数，并输出计算得到的 (\\pi) 值。 1.2.注意 项数越多，计算结果越精确，但计算时间也会增加。 莱布尼茨公式收敛速度非常慢，对于实际应用，通常使用更高效的算法，如高斯-勒让德算法、BBP公式等。 这个程序是一个简单的示例，用于展示如何在 C++ 中实现 (\\pi) 的计算。对于高精度或性能要求，可能需要更复杂的算法。\n2.enum 在C++中，enum（枚举）是一种用户定义的类型，它允许为一组相关的值定义一个名字。使用枚举可以提高代码的可读性和可维护性。\n以下是一些C++中使用枚举的示例：\n2.1.示例1：基础枚举 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; enum Day { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday }; int main() { Day today = Wednesday; std::cout \u0026lt;\u0026lt; \u0026#34;Today is: \u0026#34; \u0026lt;\u0026lt; today \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Is today Friday? \u0026#34; \u0026lt;\u0026lt; (today == Friday ? \u0026#34;Yes\u0026#34; : \u0026#34;No\u0026#34;) \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，Day是一个枚举类型，它定义了一周的七天。在main函数中，我们创建了一个Day类型的变量today，并将其设置为Wednesday。\n2.2.示例2：带初始值的枚举 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; enum Color : unsigned int { Red = 10, Green, Blue }; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Red is: \u0026#34; \u0026lt;\u0026lt; Red \u0026lt;\u0026lt; std::endl; // 输出: Red is: 10 std::cout \u0026lt;\u0026lt; \u0026#34;Green is: \u0026#34; \u0026lt;\u0026lt; Green \u0026lt;\u0026lt; std::endl; // 输出: Green is: 11 std::cout \u0026lt;\u0026lt; \u0026#34;Blue is: \u0026#34; \u0026lt;\u0026lt; Blue \u0026lt;\u0026lt; std::endl; // 输出: Blue is: 12 return 0; } 在这个示例中，Color是一个枚举类型，它从Red开始赋予初始值10，然后自动为Green和Blue分别赋予11和12。\n2.3.示例3：基于字符串的枚举（C++11及以后） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; enum class Season { Spring, Summer, Autumn, Winter }; int main() { Season favSeason = Season::Autumn; switch (favSeason) { case Season::Spring: std::cout \u0026lt;\u0026lt; \u0026#34;Spring is the season of renewal.\u0026#34; \u0026lt;\u0026lt; std::endl; break; case Season::Summer: std::cout \u0026lt;\u0026lt; \u0026#34;Summer is the season of heat.\u0026#34; \u0026lt;\u0026lt; std::endl; break; case Season::Autumn: std::cout \u0026lt;\u0026lt; \u0026#34;Autumn is the season of harvest.\u0026#34; \u0026lt;\u0026lt; std::endl; break; case Season::Winter: std::cout \u0026lt;\u0026lt; \u0026#34;Winter is the season of cold.\u0026#34; \u0026lt;\u0026lt; std::endl; break; } return 0; } 在这个示例中，Season是一个枚举类型，我们使用enum class关键字来定义它。这种类型的枚举是强类型的，意味着我们必须使用Season::来指定枚举值。\n2.4.示例4：指定底层类型的枚举（C++11及以后） 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; enum class ErrorCode : int { None = 0, FileNotFound = 1, PermissionDenied = 2 }; int main() { ErrorCode error = ErrorCode::FileNotFound; std::cout \u0026lt;\u0026lt; \u0026#34;Error code: \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(error) \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，ErrorCode是一个枚举类型，它的底层类型被指定为int。我们可以使用static_cast\u0026lt;int\u0026gt;()将枚举值转换为其底层的整数值。\n枚举是C++中一种非常有用的构造，可以帮助我们以类型安全的方式处理一组相关的值。\n3.汉诺塔 汉诺塔问题是一个经典的递归问题，涉及到将一组盘子从一个柱子移动到另一个柱子，同时通过一个中间柱子作为辅助。在移动过程中，任何时候较大的盘子都不能放在较小的盘子上面。目标是找到一种方法，使得所有盘子都从起始柱子移动到目标柱子。\n下面是一个使用C++实现的汉诺塔问题的解决方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; // 递归函数，用于移动盘子 void hanoi(int n, char from_rod, char to_rod, char aux_rod) { if (n == 1) { std::cout \u0026lt;\u0026lt; \u0026#34;Move disk 1 from rod \u0026#34; \u0026lt;\u0026lt; from_rod \u0026lt;\u0026lt; \u0026#34; to rod \u0026#34; \u0026lt;\u0026lt; to_rod \u0026lt;\u0026lt; std::endl; return; } hanoi(n - 1, from_rod, aux_rod, to_rod); std::cout \u0026lt;\u0026lt; \u0026#34;Move disk \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; from rod \u0026#34; \u0026lt;\u0026lt; from_rod \u0026lt;\u0026lt; \u0026#34; to rod \u0026#34; \u0026lt;\u0026lt; to_rod \u0026lt;\u0026lt; std::endl; hanoi(n - 1, aux_rod, to_rod, from_rod); } int main() { int n; // 盘子的数目 std::cout \u0026lt;\u0026lt; \u0026#34;Enter number of disks: \u0026#34;; std::cin \u0026gt;\u0026gt; n; // 用户输入盘子的数量 // 调用递归函数开始解决汉诺塔问题 hanoi(n, \u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;); // A为起始柱子，C为目标柱子，B为辅助柱子 return 0; } 3.1.程序说明 函数 hanoi：\n这是一个递归函数，接收四个参数：盘子数 n、起始柱子的字符标识符 from_rod、目标柱子的字符标识符 to_rod 和辅助柱子的字符标识符 aux_rod。 如果只有一个盘子（n == 1），直接将其从起始柱子移动到目标柱子。 如果有多于一个盘子，算法分为三步： 先移动上面的 n-1 个盘子，从起始柱子借助目标柱子移动到辅助柱子。 将最大的盘子，也就是最底下的盘子，直接从起始柱子移动到目标柱子。 最后再将那 n-1 个盘子从辅助柱子借助起始柱子移动到目标柱子。 主函数 main：\n用户输入盘子的数量。 调用 hanoi 函数开始解决汉诺塔问题。 这个程序展示了如何使用递归方法解决汉诺塔问题。递归是解决这类问题的强大工具，因为它可以自然地分解问题为更小的子问题。\n4.x^n x的n次方 计算 (x) 的 (n) 次方是一个常见的数学运算，可以通过多种方式在C++中实现。下面是一个简单的C++程序，用于计算 (x) 的 (n) 次方：\n4.1.示例1：使用循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; // 用于abs函数 double power(double x, int n) { double result = 1; bool negative = n \u0026lt; 0; n = abs(n); for (int i = 0; i \u0026lt; n; i++) { result *= x; } return negative ? 1 / result : result; } int main() { double x; int n; std::cout \u0026lt;\u0026lt; \u0026#34;Enter base (x): \u0026#34;; std::cin \u0026gt;\u0026gt; x; std::cout \u0026lt;\u0026lt; \u0026#34;Enter exponent (n): \u0026#34;; std::cin \u0026gt;\u0026gt; n; double result = power(x, n); std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; raised to the power \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } 4.2.示例2：使用递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; // 用于abs函数 double power(double x, int n) { if (n == 0) { return 1; // 任何数的0次方都是1 } if (n \u0026lt; 0) { return 1 / power(x, -n); // 负指数转换为正指数的倒数 } double half = power(x, n / 2); if (n % 2 == 0) { return half * half; } else { return half * half * x; } } int main() { double x; int n; std::cout \u0026lt;\u0026lt; \u0026#34;Enter base (x): \u0026#34;; std::cin \u0026gt;\u0026gt; x; std::cout \u0026lt;\u0026lt; \u0026#34;Enter exponent (n): \u0026#34;; std::cin \u0026gt;\u0026gt; n; double result = power(x, n); std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; raised to the power \u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; is \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } 4.3.程序说明 函数 power：\n接受两个参数：基数 x 和指数 n。 使用循环或递归方法计算 (x^n)。 如果指数为负，计算 (x) 的 (-n) 次方，然后取倒数。 主函数 main：\n用户输入基数 (x) 和指数 (n)。 调用 power 函数计算结果，并输出。 这两个示例展示了如何使用循环和递归方法来计算幂。递归方法更简洁，但循环方法在处理非常大的指数时可能更高效。在实际应用中，你可以根据需要选择适合的方法。\n5.递归 递归是一种在函数中调用自身来解决问题的方法。递归通常用于那些可以分解为更小、更简单问题的情况。在C++中，递归经常被用来解决诸如汉诺塔、斐波那契数列、阶乘计算等问题。\n下面是一个简单的C++递归示例，计算阶乘：\n5.1.示例：阶乘的递归计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; // 递归函数，用于计算阶乘 unsigned long long factorial(int n) { if (n == 0) { // 递归终止条件 return 1; } return n * factorial(n - 1); // 递归调用 } int main() { int number; std::cout \u0026lt;\u0026lt; \u0026#34;Enter a positive integer: \u0026#34;; std::cin \u0026gt;\u0026gt; number; // 检查输入是否为正整数 if (number \u0026lt; 0) { std::cout \u0026lt;\u0026lt; \u0026#34;Factorial is not defined for negative numbers.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { unsigned long long result = factorial(number); std::cout \u0026lt;\u0026lt; \u0026#34;Factorial of \u0026#34; \u0026lt;\u0026lt; number \u0026lt;\u0026lt; \u0026#34; = \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } return 0; } 5.2.程序说明 函数 factorial：\n这是一个递归函数，用于计算一个整数的阶乘。 如果 n 为 0（递归终止条件），函数返回 1，因为0的阶乘定义为1。 如果 n 大于 0，函数通过 n * factorial(n - 1) 进行递归调用。 主函数 main：\n用户输入一个正整数。 程序检查输入是否为正整数。 如果是，调用 factorial 函数计算阶乘，并输出结果。 递归函数必须有一个终止条件，否则它将无限递归下去，最终导致栈溢出错误。在上述示例中，当 n 等于 0 时递归终止。\n递归虽然是一个强大的工具，但它也有缺点，如可能导致堆栈溢出（如果递归太深），以及可能比迭代解决方案更慢。因此，使用递归时需要谨慎，并确保有一个明确的终止条件。\n6.掷骰子 在C++中，模拟掷骰子的过程通常涉及到生成随机数。以下是一个简单的C++程序，用于模拟掷一个六面骰子的过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; // 包含rand()和srand() #include \u0026lt;ctime\u0026gt; // 包含time() int main() { // 初始化随机数生成器 srand(static_cast\u0026lt;unsigned int\u0026gt;(time(0))); // 生成一个1到6的随机数 int dice = rand() % 6 + 1; std::cout \u0026lt;\u0026lt; \u0026#34;You rolled a dice and got: \u0026#34; \u0026lt;\u0026lt; dice \u0026lt;\u0026lt; std::endl; return 0; } 6.1.程序说明 包含头文件：\n\u0026lt;iostream\u0026gt; 用于输入输出。 \u0026lt;cstdlib\u0026gt; 包含rand()和srand()函数。 \u0026lt;ctime\u0026gt; 包含time()函数。 初始化随机数生成器：\nsrand()函数用于设置随机数生成器的种子值，通常使用当前时间作为种子，通过time(0)获得。 生成随机数：\nrand() % 6 + 1生成一个1到6的随机数，模拟掷一个六面骰子的结果。 输出结果：\n使用std::cout输出掷骰子的结果。 6.2.更复杂的示例：多次掷骰子 下面的程序模拟掷两个骰子多次，并计算点数之和的频率：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; // 包含rand()和srand() #include \u0026lt;ctime\u0026gt; // 包含time() #include \u0026lt;map\u0026gt; int main() { const int rolls = 100000; // 掷骰子的次数 const int diceCount = 2; // 骰子的数量 std::map\u0026lt;int, int\u0026gt; frequency; // 用于存储点数之和的频率 // 初始化随机数生成器 srand(static_cast\u0026lt;unsigned int\u0026gt;(time(0))); for (int i = 0; i \u0026lt; rolls; ++i) { int sum = 0; for (int j = 0; j \u0026lt; diceCount; ++j) { sum += rand() % 6 + 1; // 每个骰子的点数 } ++frequency[sum]; // 更新频率 } std::cout \u0026lt;\u0026lt; \u0026#34;Sum Frequency after \u0026#34; \u0026lt;\u0026lt; rolls \u0026lt;\u0026lt; \u0026#34; rolls:\u0026#34; \u0026lt;\u0026lt; std::endl; for (const auto \u0026amp;kv : frequency) { std::cout \u0026lt;\u0026lt; \u0026#34;Sum \u0026#34; \u0026lt;\u0026lt; kv.first \u0026lt;\u0026lt; \u0026#34; appears \u0026#34; \u0026lt;\u0026lt; kv.second \u0026lt;\u0026lt; \u0026#34; times.\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 6.3.程序说明 定义常量：\nrolls 表示掷骰子的次数。 diceCount 表示骰子的数量。 初始化随机数生成器：\n使用当前时间作为种子。 循环掷骰子：\n每次循环掷两个骰子，计算点数之和。 更新频率：\n使用std::map记录每个点数之和的出现次数。 输出结果：\n输出每个点数之和的出现次数。 这个程序可以扩展到更多的骰子和更复杂的规则，例如在桌面游戏中使用。\n7.struct 在C++中，结构体（struct）是一种复合数据类型，允许你将多个不同的数据类型组合成一个单一的数据结构。结构体经常用于表示记录。\n以下是定义和使用结构体的基本示例：\n7.1.示例1：定义和使用简单的结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; // 定义一个结构体，用于表示点 struct Point { int x; int y; }; int main() { // 创建一个点 Point p; p.x = 10; p.y = 20; // 输出点的坐标 std::cout \u0026lt;\u0026lt; \u0026#34;Point: (\u0026#34; \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; // 创建另一个点 Point q = {5, 15}; // 列表初始化 // 修改并输出点的坐标 std::cout \u0026lt;\u0026lt; \u0026#34;Point: (\u0026#34; \u0026lt;\u0026lt; q.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; q.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 7.2.示例2：定义和使用包含函数的结构体 C++11允许在结构体中定义函数，这使得结构体可以包含方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; // 用于sqrt函数 // 定义一个结构体，用于表示点，并包含一个方法 struct Point { int x, y; // 方法：计算点到原点的距离 double distanceToOrigin() const { return sqrt(x * x + y * y); } }; int main() { Point p = {3, 4}; std::cout \u0026lt;\u0026lt; \u0026#34;Point: (\u0026#34; \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Distance to origin: \u0026#34; \u0026lt;\u0026lt; p.distanceToOrigin() \u0026lt;\u0026lt; std::endl; return 0; } 7.3.示例3：定义和使用包含构造函数的结构体 C++11也允许在结构体中定义构造函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; // 用于sqrt函数 // 定义一个结构体，用于表示点，并包含构造函数 struct Point { int x, y; // 构造函数 Point(int x, int y) : x(x), y(y) {} // 方法：计算点到原点的距离 double distanceToOrigin() const { return sqrt(x * x + y * y); } }; int main() { Point p(3, 4); std::cout \u0026lt;\u0026lt; \u0026#34;Point: (\u0026#34; \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Distance to origin: \u0026#34; \u0026lt;\u0026lt; p.distanceToOrigin() \u0026lt;\u0026lt; std::endl; return 0; } 7.4.示例4：定义和使用结构体数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; // 定义一个结构体，用于表示矩形 struct Rectangle { int width; int height; }; int main() { // 创建一个矩形数组 Rectangle rectangles[2] = { {10, 20}, {30, 40} }; // 遍历数组并输出每个矩形的尺寸 for (int i = 0; i \u0026lt; 2; ++i) { std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle \u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; \u0026#34;width = \u0026#34; \u0026lt;\u0026lt; rectangles[i].width \u0026lt;\u0026lt; \u0026#34;, height = \u0026#34; \u0026lt;\u0026lt; rectangles[i].height \u0026lt;\u0026lt; std::endl; } return 0; } 结构体在C++中非常有用，它们可以包含数据和函数，使得数据的组织和操作更加方便。\n8.在C++中，如何使用结构体来模拟一个简单的银行账户系统？ 在C++中，你可以使用结构体来模拟一个简单的银行账户系统。以下是一个示例，展示了如何定义一个银行账户结构体，并提供了存款、取款和显示账户信息的功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;iostream\u0026gt; // 定义银行账户结构体 struct BankAccount { std::string owner; // 账户持有人姓名 long accountNumber; // 账户号码 double balance; // 账户余额 }; // 存款函数 void deposit(BankAccount \u0026amp;account, double amount) { if (amount \u0026gt; 0) { account.balance += amount; std::cout \u0026lt;\u0026lt; \u0026#34;Deposited: \u0026#34; \u0026lt;\u0026lt; amount \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Invalid deposit amount\u0026#34; \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;Current balance: \u0026#34; \u0026lt;\u0026lt; account.balance \u0026lt;\u0026lt; std::endl; } // 取款函数 void withdraw(BankAccount \u0026amp;account, double amount) { if (amount \u0026gt; 0 \u0026amp;\u0026amp; account.balance \u0026gt;= amount) { account.balance -= amount; std::cout \u0026lt;\u0026lt; \u0026#34;Withdrew: \u0026#34; \u0026lt;\u0026lt; amount \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Invalid or insufficient funds\u0026#34; \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;Current balance: \u0026#34; \u0026lt;\u0026lt; account.balance \u0026lt;\u0026lt; std::endl; } // 显示账户信息函数 void displayAccountInfo(const BankAccount \u0026amp;account) { std::cout \u0026lt;\u0026lt; \u0026#34;Account owner: \u0026#34; \u0026lt;\u0026lt; account.owner \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Account number: \u0026#34; \u0026lt;\u0026lt; account.accountNumber \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Account balance: \u0026#34; \u0026lt;\u0026lt; account.balance \u0026lt;\u0026lt; std::endl; } int main() { // 创建一个银行账户实例 BankAccount myAccount = {\u0026#34;John Doe\u0026#34;, 123456789L, 1000.0}; // 显示账户信息 displayAccountInfo(myAccount); // 进行存款操作 deposit(myAccount, 200.0); // 进行取款操作 withdraw(myAccount, 500.0); // 再次显示账户信息 displayAccountInfo(myAccount); return 0; } 8.1.程序说明 定义结构体：\nBankAccount 结构体包含三个成员：owner（持有人姓名），accountNumber（账户号码），balance（账户余额）。 定义函数：\ndeposit 函数接受一个账户引用和存款金额，如果金额有效，则将其添加到账户余额中。 withdraw 函数接受一个账户引用和取款金额，如果取款金额有效且账户余额足够，则从账户余额中扣除。 displayAccountInfo 函数接受一个账户引用，并显示账户的详细信息。 主函数：\n创建一个 BankAccount 类型的实例 myAccount。 调用 displayAccountInfo 函数显示账户信息。 调用 deposit 函数进行存款操作。 调用 withdraw 函数进行取款操作。 最后再次调用 displayAccountInfo 函数显示账户信息。 这个程序展示了如何使用结构体和函数来模拟一个简单的银行账户系统。你可以根据需要扩展这个系统，例如添加密码验证、交易历史记录等功能。\n9.static 在C++中，static关键字有多种用途，包括：\n局部静态变量：在函数内部，static用于定义一个静态局部变量，这意味着变量的生命周期将持续到程序结束，而不仅仅是函数调用期间。\n全局静态变量：在函数外部，static用于定义一个全局变量，它的生命周期将持续到程序结束，但它的链接是局部的，只能在定义它的文件中访问。\n静态成员变量：在类中，static用于定义静态成员变量，这意味着该变量不是与类的具体实例相关联的，而是被类的所有实例共享。\n静态成员函数：在类中，static用于定义静态成员函数，这意味着该函数可以在没有类实例的情况下调用。\n静态类成员：在类模板中，static用于定义静态成员，这要求在类外初始化。\n以下是一些使用static的示例：\n9.1.示例1：局部静态变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; void function() { static int local_static_var = 1; local_static_var++; std::cout \u0026lt;\u0026lt; local_static_var \u0026lt;\u0026lt; std::endl; } int main() { function(); function(); function(); return 0; } 在这个示例中，local_static_var是一个静态局部变量，它在函数第一次调用时被初始化，然后在随后的调用中保持其值。\n9.2.示例2：全局静态变量 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; static int global_static_var = 10; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;global_static_var: \u0026#34; \u0026lt;\u0026lt; global_static_var \u0026lt;\u0026lt; std::endl; global_static_var++; std::cout \u0026lt;\u0026lt; \u0026#34;global_static_var: \u0026#34; \u0026lt;\u0026lt; global_static_var \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，global_static_var是一个静态全局变量，它只能在定义它的文件中访问。\n9.3.示例3：静态成员变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; class MyClass { public: static int staticMember; }; int MyClass::staticMember = 0; int main() { MyClass::staticMember = 100; std::cout \u0026lt;\u0026lt; \u0026#34;MyClass::staticMember: \u0026#34; \u0026lt;\u0026lt; MyClass::staticMember \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，staticMember是一个静态成员变量，可以通过类名直接访问。\n9.4.示例4：静态成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; class MyClass { public: static void staticMemberFunction() { std::cout \u0026lt;\u0026lt; \u0026#34;This is a static member function.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { MyClass::staticMemberFunction(); return 0; } 在这个示例中，staticMemberFunction是一个静态成员函数，可以在没有类实例的情况下调用。\n9.5.示例5：静态类模板成员 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; template \u0026lt;typename T\u0026gt; class MyClass { public: static std::string staticMember; }; template \u0026lt;typename T\u0026gt; std::string MyClass\u0026lt;T\u0026gt;::staticMember = \u0026#34;Hello, World!\u0026#34;; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;MyClass\u0026lt;int\u0026gt;::staticMember: \u0026#34; \u0026lt;\u0026lt; MyClass\u0026lt;int\u0026gt;::staticMember \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;MyClass\u0026lt;double\u0026gt;::staticMember: \u0026#34; \u0026lt;\u0026lt; MyClass\u0026lt;double\u0026gt;::staticMember \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，staticMember是一个静态成员，它在类模板中定义，并在类外初始化。\nstatic关键字是C++中一个非常有用的工具，可以用于多种场景，包括控制变量的生命周期和访问级别，以及实现类成员的特殊行为。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T00:59:40+08:00","permalink":"https://wesigj.github.io/p/c-practical-1-day2/","title":"C++ Practical-1 day2"},{"content":"C++ Practical-1 day1 [TOC]\nOverview C++不练习coding，就相当于空中楼阁，基础不扎实 光吃不干，等于没吃 1.hello world 1 2 3 4 5 6 7 #include \u0026lt;iostream\u0026gt; int main(int argc, char *argv[]) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello world!\u0026#34; \u0026lt;\u0026lt; std::endl; std::cin.get(); return 0; } 1.1.main函数中 argv argv含义 在C++中，main函数是一个特殊的函数，它是每个C++程序的入口点。main函数可以有两种不同的形式：\nint main() int main(int argc, char *argv[]) 其中，argc和argv是可选参数，它们用于处理命令行参数。\nargc（argument count）是一个整型变量，表示命令行参数的数量。 argv（argument vector）是一个字符指针数组，包含了命令行参数的值。 当你在命令行（如终端或命令提示符）中运行一个程序时，你可以传递一些参数给程序。这些参数会通过argc和argv传递给main函数。\n例如，如果你有一个C++程序，你可以通过以下方式运行它：\n1 ./program arg1 arg2 arg3 在这个例子中：\nargc的值将是4（包括程序本身的名称，所以实际参数数量是3）。 argv将包含以下元素： argv[0]是程序的名称（\u0026ldquo;program\u0026rdquo;）。 argv[1]是第一个参数（\u0026ldquo;arg1\u0026rdquo;）。 argv[2]是第二个参数（\u0026ldquo;arg2\u0026rdquo;）。 argv[3]是第三个参数（\u0026ldquo;arg3\u0026rdquo;）。 这是main函数使用argc和argv的一个简单示例：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; int main(int argc, char *argv[]) { std::cout \u0026lt;\u0026lt; \u0026#34;Number of arguments: \u0026#34; \u0026lt;\u0026lt; argc \u0026lt;\u0026lt; std::endl; for (int i = 0; i \u0026lt; argc; ++i) { std::cout \u0026lt;\u0026lt; \u0026#34;Argument \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; argv[i] \u0026lt;\u0026lt; std::endl; } return 0; } 在这个程序中，main函数打印出参数的数量和每个参数的值。如果你运行这个程序并传递一些参数，它将输出这些参数的数量和值。\n2.annotate 注释 1 2 3 4 5 6 7 8 9 10 11 12 // #include \u0026lt;iostream\u0026gt; /* #include \u0026lt;iostream\u0026gt; */ #if 0 #include \u0026lt;iostream\u0026gt; #endif #if 1 #include \u0026lt;iostream\u0026gt; #endif 在C++中，有几种不同的注释方法：\n单行注释： 使用两个斜杠 // 开始，直到行尾的所有内容都会被视为注释。\n1 2 // 这是一个单行注释 int a = 5; // 这也是一个单行注释 多行注释： 使用 /* 开始，*/ 结束。这种注释方式可以跨越多行。\n1 2 3 /* 这是一个多行注释 它可以跨越多行。 */ int a = 5; 文档注释（也称为文档化注释）： 使用 /** 开始，*/ 结束。这种注释方式通常用于生成文档。\n1 2 3 4 5 /** * 这是一个文档注释 * 它通常用于生成文档。 */ int a = 5; 嵌套注释： C++标准不支持在多行注释中嵌套注释。如果你尝试这样做，只有第一个 */ 之前的部分会被当作注释，剩下的部分会被当作代码。\n1 2 3 /* 这是一个注释 /* 这不是注释，而是代码 */ int a = 5; // 这会导致编译错误 条件编译注释： 使用 #if, #ifdef, #ifndef, #else, #elif, #endif 指令可以创建条件编译注释，这些指令可以控制代码的编译。\n1 2 3 4 5 6 7 8 #define DEBUG #if defined(DEBUG) // 调试模式下的代码 std::cout \u0026lt;\u0026lt; \u0026#34;Debug mode\u0026#34; \u0026lt;\u0026lt; std::endl; #else // 非调试模式下的代码 std::cout \u0026lt;\u0026lt; \u0026#34;Release mode\u0026#34; \u0026lt;\u0026lt; std::endl; #endif 预处理指令注释： 使用 # 开头的预处理指令，如 #include, #define, #undef 等，虽然它们不是注释，但它们用于控制编译过程。\n1 2 #include \u0026lt;iostream\u0026gt; // 包含标准输入输出库 #define PI 3.14159 // 定义常量PI 在实际编程中，单行注释是最常用的，因为它简洁且易于使用。多行注释则适用于需要注释掉较大块代码的情况。文档注释通常与文档生成工具（如Doxygen）一起使用，以自动提取注释生成程序文档。\n3.判断闰年 在C++中，判断一个年份是否为闰年可以通过以下规则：\n如果年份能被4整除且不能被100整除，则为闰年。 如果年份能被400整除，则也是闰年。 基于这些规则，你可以使用以下C++代码来判断一个年份是否为闰年：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; bool isLeapYear(int year) { if ((year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0) || (year % 400 == 0)) { return true; } else { return false; } } int main() { int year; std::cout \u0026lt;\u0026lt; \u0026#34;Enter a year: \u0026#34;; std::cin \u0026gt;\u0026gt; year; if (isLeapYear(year)) { std::cout \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#34; is a leap year.\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#34; is not a leap year.\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 这段代码定义了一个isLeapYear函数，它接受一个整数参数year，并返回一个布尔值，指示该年份是否为闰年。然后在main函数中，程序会提示用户输入一个年份，然后调用isLeapYear函数来判断并输出结果。\n这是一个简单且有效的判断闰年的方法。\n4.union 在C++中，union是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。union可以包含多个成员，但任何时候只能存储其中一个成员的值。union的大小由最大的成员决定。\n下面是一个union的简单示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; // 定义一个名为Data的union union Data { int i; double f; char str[20]; struct { int x; int y; int z; } u; int k; }; int main() { Data data; // 存储整数值 data.i = 10; std::cout \u0026lt;\u0026lt; \u0026#34;data.i: \u0026#34; \u0026lt;\u0026lt; data.i \u0026lt;\u0026lt; std::endl; // 输出: data.i: 10 // 存储浮点数值 data.f = 220.5; std::cout \u0026lt;\u0026lt; \u0026#34;data.f: \u0026#34; \u0026lt;\u0026lt; data.f \u0026lt;\u0026lt; std::endl; // 输出: data.f: 220.5 // 存储字符串 strcpy(data.str, \u0026#34;C++ Union\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;data.str: \u0026#34; \u0026lt;\u0026lt; data.str \u0026lt;\u0026lt; std::endl; // 输出: data.str: C++ Union data.u.x = 1; data.u.y = 2; data.u.z = 3; data.k = 4; // 覆盖掉第一个int空间值 printf(\u0026#34;%d %d %d %d\\n\u0026#34;, data.u.x, data.u.y, data.u.z, data.k); return 0; } 在这个例子中，Data是一个union，它包含一个整数i，一个浮点数f和一个字符数组str。在main函数中，我们创建了一个Data类型的变量data，并分别给它的成员赋值。\n请注意，尽管data可以存储不同类型的值，但一次只能存储一个成员的值。这意味着，当你给data.f赋值时，data.i的值会被覆盖，同样，当你给data.str赋值时，data.i和data.f的值都会被覆盖。\nunion的一个常见用途是处理不同的数据类型，但你知道在任何给定时间只会使用其中一种类型。这可以节省内存，因为不需要为每种可能的类型分配单独的空间。\n注意：在使用union时，需要确保不会同时访问多个成员，因为这会导致未定义的行为。此外，当使用union存储和访问数据时，需要格外小心，以避免数据覆盖和内存泄漏等问题。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-28T00:59:39+08:00","permalink":"https://wesigj.github.io/p/c-practical-1-day1/","title":"C++ Practical-1 day1"},{"content":"设计模式-抽象工厂abstract_factory [TOC]\nOverview 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式 用于创建一系列相关或依赖对象的接口，而无需指定它们具体的类 具体工厂生产具体产品 具体工厂继承抽象工厂 具体产品继承抽象产品 1.抽象工厂abstract_factory 抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，用于创建一系列相关或依赖对象的接口，而无需指定它们具体的类。这种模式允许系统独立于具体类的变化，从而提高了系统的灵活性和可扩展性。\n在C++中实现抽象工厂模式通常涉及以下几个步骤：\n定义产品接口：为不同的产品族定义一个或多个抽象接口。\n创建具体产品类：为每个产品接口实现具体类。\n定义抽象工厂接口：定义一个抽象工厂接口，声明创建各种产品的接口。\n创建具体工厂类：为每个具体的产品族实现一个具体工厂类。\n使用工厂方法：客户端代码使用抽象工厂接口来创建产品，而不需要知道具体工厂和产品的细节。\n下面是一个简单的C++示例，展示了如何实现抽象工厂模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // 产品接口 class Animal { public: virtual void makeSound() = 0; virtual ~Animal() {} }; // 具体产品 class Dog : public Animal { public: void makeSound() override { std::cout \u0026lt;\u0026lt; \u0026#34;Woof!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Cat : public Animal { public: void makeSound() override { std::cout \u0026lt;\u0026lt; \u0026#34;Meow!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 抽象工厂接口 class AnimalFactory { public: virtual std::unique_ptr\u0026lt;Animal\u0026gt; createDog() = 0; virtual std::unique_ptr\u0026lt;Animal\u0026gt; createCat() = 0; virtual ~AnimalFactory() {} }; // 具体工厂 class DogFactory : public AnimalFactory { public: std::unique_ptr\u0026lt;Animal\u0026gt; createDog() override { return std::make_unique\u0026lt;Dog\u0026gt;(); } std::unique_ptr\u0026lt;Animal\u0026gt; createCat() override { return nullptr; // DogFactory cannot create a Cat } }; class CatFactory : public AnimalFactory { public: std::unique_ptr\u0026lt;Animal\u0026gt; createDog() override { return nullptr; // CatFactory cannot create a Dog } std::unique_ptr\u0026lt;Animal\u0026gt; createCat() override { return std::make_unique\u0026lt;Cat\u0026gt;(); } }; // 客户端代码 int main() { AnimalFactory* factory = nullptr; factory = new DogFactory(); auto dog = factory-\u0026gt;createDog(); dog-\u0026gt;makeSound(); delete factory; factory = new CatFactory(); auto cat = factory-\u0026gt;createCat(); cat-\u0026gt;makeSound(); delete factory; return 0; } 在这个例子中，Animal 是一个产品接口，Dog 和 Cat 是具体产品。AnimalFactory 是抽象工厂接口，DogFactory 和 CatFactory 是具体工厂，它们分别实现了创建 Dog 和 Cat 的方法。客户端代码通过工厂接口来创建对象，而不需要知道具体是如何创建的。这样，如果需要添加新的动物类型，只需要添加相应的产品类和工厂类即可，不需要修改现有代码。\n2.在C++中，如何使用抽象工厂模式来创建一个更复杂的产品族？ 在C++中，使用抽象工厂模式创建一个更复杂的产品族涉及到定义多个产品层次结构和相应的工厂接口。以下是一个更复杂的产品族的示例，其中包含多个产品类别和相应的工厂方法。\n假设我们有一个复杂的产品族，包括不同类型的动物和它们的栖息地。每种动物都有特定的栖息地，例如，鸟类可能生活在树上或水边，而爬行动物可能生活在洞穴或沙漠中。\n首先，定义产品接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Animal.h class Animal { public: virtual ~Animal() {} virtual void makeSound() = 0; }; // Habitat.h class Habitat { public: virtual ~Habitat() {} virtual void describe() = 0; }; 接着，创建具体的产品类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // Bird.h #include \u0026#34;Animal.h\u0026#34; class Bird : public Animal { public: void makeSound() override { std::cout \u0026lt;\u0026lt; \u0026#34;Bird chirps!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // TreeHabitat.h #include \u0026#34;Habitat.h\u0026#34; class TreeHabitat : public Habitat { public: void describe() override { std::cout \u0026lt;\u0026lt; \u0026#34;This is a tree habitat.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // Reptile.h #include \u0026#34;Animal.h\u0026#34; class Reptile : public Animal { public: void makeSound() override { std::cout \u0026lt;\u0026lt; \u0026#34;Reptile hisses!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // DesertHabitat.h #include \u0026#34;Habitat.h\u0026#34; class DesertHabitat : public Habitat { public: void describe() override { std::cout \u0026lt;\u0026lt; \u0026#34;This is a desert habitat.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 然后，定义抽象工厂接口，包括创建动物和栖息地的方法：\n1 2 3 4 5 6 7 8 9 // AnimalHabitatFactory.h #include \u0026lt;memory\u0026gt; class AnimalHabitatFactory { public: virtual std::unique_ptr\u0026lt;Animal\u0026gt; createAnimal() = 0; virtual std::unique_ptr\u0026lt;Habitat\u0026gt; createHabitat() = 0; virtual ~AnimalHabitatFactory() {} }; 创建具体的工厂类，例如一个工厂专门创建鸟类和它们的栖息地：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // BirdHabitatFactory.h #include \u0026#34;AnimalHabitatFactory.h\u0026#34; #include \u0026#34;Bird.h\u0026#34; #include \u0026#34;TreeHabitat.h\u0026#34; class BirdHabitatFactory : public AnimalHabitatFactory { public: std::unique_ptr\u0026lt;Animal\u0026gt; createAnimal() override { return std::make_unique\u0026lt;Bird\u0026gt;(); } std::unique_ptr\u0026lt;Habitat\u0026gt; createHabitat() override { return std::make_unique\u0026lt;TreeHabitat\u0026gt;(); } }; 同样，可以创建另一个工厂类来创建爬行动物和它们的栖息地：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ReptileHabitatFactory.h #include \u0026#34;AnimalHabitatFactory.h\u0026#34; #include \u0026#34;Reptile.h\u0026#34; #include \u0026#34;DesertHabitat.h\u0026#34; class ReptileHabitatFactory : public AnimalHabitatFactory { public: std::unique_ptr\u0026lt;Animal\u0026gt; createAnimal() override { return std::make_unique\u0026lt;Reptile\u0026gt;(); } std::unique_ptr\u0026lt;Habitat\u0026gt; createHabitat() override { return std::make_unique\u0026lt;DesertHabitat\u0026gt;(); } }; 最后，客户端代码使用抽象工厂来创建对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // main.cpp #include \u0026#34;AnimalHabitatFactory.h\u0026#34; int main() { // Create a bird and its habitat std::unique_ptr\u0026lt;AnimalHabitatFactory\u0026gt; birdFactory = std::make_unique\u0026lt;BirdHabitatFactory\u0026gt;(); auto bird = birdFactory-\u0026gt;createAnimal(); auto birdHabitat = birdFactory-\u0026gt;createHabitat(); bird-\u0026gt;makeSound(); birdHabitat-\u0026gt;describe(); // Create a reptile and its habitat std::unique_ptr\u0026lt;AnimalHabitatFactory\u0026gt; reptileFactory = std::make_unique\u0026lt;ReptileHabitatFactory\u0026gt;(); auto reptile = reptileFactory-\u0026gt;createAnimal(); auto reptileHabitat = reptileFactory-\u0026gt;createHabitat(); reptile-\u0026gt;makeSound(); reptileHabitat-\u0026gt;describe(); return 0; } 在这个示例中，我们定义了两个产品层次结构：Animal 和 Habitat，每个层次结构都有自己的具体实现。我们定义了一个抽象工厂 AnimalHabitatFactory，它有两个方法来创建动物和它们的栖息地。然后，我们为每种产品族创建了具体的工厂类：BirdHabitatFactory 和 ReptileHabitatFactory。客户端代码通过工厂接口来创建对象，而不需要知道具体的实现细节。这样，如果需要添加新的动物或栖息地类型，只需要添加相应的产品类和工厂类即可，不需要修改现有代码。\n3.在C++中，抽象工厂模式的实现有哪些常见的问题和解决方案？ 在C++中实现抽象工厂模式时，可能会遇到一些常见问题以及相应的解决方案：\n问题：系统复杂性增加\n解决方案：确实，抽象工厂模式通过引入许多抽象类和接口，可能会使系统变得更加复杂。为了解决这个问题，应该在真正需要这种模式时才使用它，例如当存在多个产品族需要创建时。如果系统较为简单，可以考虑使用更简单的工厂模式或构造者模式 。 问题：难以支持新产品类型\n解决方案：当需要添加新的产品类型时，可能需要修改抽象工厂接口以及所有具体工厂类。为了避免这种情况，可以在设计初期就考虑到扩展性，或者使用更灵活的设计模式，例如原型模式或建造者模式 。 问题：违反依赖倒置原则\n解决方案：如果客户端代码直接依赖于具体的工厂实现，而不是抽象接口，这可能违反了依赖倒置原则。为了解决这个问题，确保客户端只通过抽象工厂接口与工厂交互，并使用依赖注入来提供具体的工厂实现 。 问题：难以扩展新的产品等级结构\n解决方案：抽象工厂模式的一个限制是，向系统添加新的产品等级结构可能比较困难。为了解决这个问题，可以在设计时采用更通用的接口，或者使用工厂方法模式来为每个产品单独创建工厂 。 问题：过度使用导致设计混乱\n解决方案：在一些情况下，过度使用抽象工厂模式可能会使设计变得混乱。为了避免这种情况，应该只在需要创建相关对象族时使用抽象工厂模式，并且确保每个工厂只负责创建一组紧密相关的产品 。 问题：参数化工厂与抽象工厂的混淆\n解决方案：抽象工厂和参数化工厂都用于创建一组不同的产品，但它们的使用场景不同。当产品具有不同的接口且需要向客户端明确这些差异时，应该使用抽象工厂。如果产品之间的差异不明显或者客户端不需要知道这些差异，可以使用参数化工厂 。 问题：C++中的内存管理\n解决方案：在现代C++中，推荐使用智能指针（如std::unique_ptr）来管理内存，避免使用裸指针和直接的new、delete操作。这有助于自动管理对象的生命周期，减少内存泄漏的风险 。 问题：接口或抽象类的使用选择\n解决方案：在实现工厂模式时，选择使用接口还是抽象类取决于具体需求。如果需要定义一个简单的工厂，只包含一个创建对象的方法，接口可能是更好的选择。如果工厂需要包含一些公共的实现细节或多个方法，抽象类可能更合适 。 通过考虑这些常见问题和解决方案，可以更有效地在C++中应用抽象工厂模式，同时保持代码的清晰和可维护性。\n4.如果我想在C++中实现一个更灵活的工厂模式，你有什么建议？ 在C++中实现一个更灵活的工厂模式，可以考虑以下几种方法和设计模式：\n使用参数化工厂方法：\n允许工厂方法接受参数，以决定创建哪种具体产品。这增加了灵活性，因为同一个工厂可以根据不同的输入参数创建不同的产品。 依赖注入：\n通过依赖注入（Dependency Injection），将创建对象的职责与使用对象的职责分离，从而提高灵活性和可测试性。 注册机制：\n使用注册机制允许在运行时动态注册和创建具体产品。这可以通过将工厂方法注册到一个中心注册表中来实现。 单例模式：\n对于某些类型的工厂，使用单例模式确保全局只有一个工厂实例，简化资源管理和访问。 原型模式：\n如果创建对象的开销很大，可以使用原型模式，通过复制现有的对象来创建新对象，而不是每次都从头开始创建。 建造者模式：\n当创建复杂对象时，使用建造者模式可以将对象的构造过程封装起来，允许逐步构建对象，并在最后提供一个完整的产品。 工厂方法模式：\n工厂方法模式允许将对象的创建委托给子类，这样可以根据子类的具体实现来创建不同的产品。 抽象工厂模式：\n如果需要创建相关或依赖的一组对象，可以使用抽象工厂模式。每个具体工厂类负责创建特定产品族的所有对象。 多态的使用：\n利用多态性，可以在不知道具体对象类型的情况下，通过接口或抽象类来使用对象。 模板和泛型：\n使用C++模板和泛型编程可以创建类型安全的工厂，这些工厂可以用于不同类型的对象，而不需要为每种类型编写单独的代码。 最小化工厂接口：\n只暴露必要的工厂接口给客户端，隐藏具体的实现细节，这样在不改变接口的情况下可以灵活地更改内部实现。 使用配置文件：\n使用配置文件来定义对象的创建逻辑，这样在不修改代码的情况下，通过更改配置就可以改变工厂的行为。 组合工厂模式：\n将多个工厂组合成一个更复杂的工厂，这样可以根据不同的情况使用不同的工厂来创建对象。 利用智能指针：\n使用智能指针（如std::unique_ptr或std::shared_ptr）来管理对象的生命周期，避免内存泄漏。 考虑线程安全：\n如果工厂模式将在多线程环境中使用，确保工厂的实现是线程安全的，或者使用线程安全的并发控制机制。 通过结合以上方法和设计模式，可以在C++中实现一个既灵活又强大的工厂模式，以满足不同场景下的需求。\n5.C++中，如何避免抽象工厂模式导致的系统复杂性增加？ 在C++中，避免抽象工厂模式导致的系统复杂性增加可以采取以下一些策略：\n合理使用设计模式：\n只在确实需要的时候使用抽象工厂模式。如果系统中的产品族不多，或者产品族之间的关联性不强，可能不需要使用抽象工厂模式。 简化产品接口：\n确保产品接口尽可能简洁，只包含必要的操作。减少接口的复杂性可以降低整个系统的复杂度。 限制产品族的数量：\n避免定义过多的产品族。每个产品族都需要相应的具体工厂，这会增加系统的复杂性。 使用依赖注入：\n通过依赖注入减少工厂与客户端之间的耦合，使系统更加灵活，并且易于测试。 避免过度设计：\n在设计初期避免过度设计。只有在确信未来会扩展更多产品族时，才使用抽象工厂模式。 利用组合优于继承：\n使用对象组合代替继承来扩展功能，这样可以减少类的数量，降低系统的复杂性。 单一职责原则：\n确保每个类只负责一项任务。如果发现类承担了过多职责，应该考虑将其拆分成更小的类。 代码复用：\n通过模板和泛型编程来复用代码，减少重复代码，降低系统复杂性。 模块化设计：\n将系统分解为多个模块，每个模块负责一部分功能，减少模块间的依赖。 文档和注释：\n编写清晰的文档和注释，帮助开发者理解系统的设计和各个组件的作用。 代码审查：\n定期进行代码审查，以识别和重构那些可能导致系统复杂性增加的部分。 使用现有的库和框架：\n尽可能使用已经存在的库和框架来实现工厂模式，避免重复造轮子。 灵活运用其他设计模式：\n根据需要，灵活运用工厂方法模式、建造者模式或原型模式等，这些模式可能在某些情况下比抽象工厂模式更简单。 逐步引入：\n如果可能，逐步引入抽象工厂模式。一开始可以使用更简单的工厂模式，随着系统的发展，再逐步迁移到抽象工厂模式。 通过上述方法，可以在保持系统灵活性和可扩展性的同时，有效控制和降低由于使用抽象工厂模式带来的系统复杂性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-abstract_factory/","title":"design pattern abstract_factory"},{"content":"设计模式-适配器模式-adapter pattern [TOC]\nOverview 适配器模式（Adapter Pattern）是一种结构性设计模式 用于使不兼容的接口能够一起工作 通过一个中间层（即适配器）来转换一个类的接口，使得原本由于接口不兼容而不能一起工作的类可以协同工作。 1.适配器模式（Adapter Pattern） 适配器模式（Adapter Pattern）是一种结构性设计模式，用于使不兼容的接口能够一起工作。它主要通过一个中间层（即适配器）来转换一个类的接口，使得原本由于接口不兼容而不能一起工作的类可以协同工作。\n1.1.适配器模式的主要角色包括 目标（Target）接口：\n定义客户端使用的特定领域相关的接口。 适配者（Adaptee）类：\n一个已经存在的类，需要适配，它拥有与目标接口不兼容的接口。 适配器（Adapter）类：\n通过在内部包装一个适配者对象，把源接口转换成目标接口。 1.2.适配器模式的分类 类适配器模式：\n使用对象组合，通过继承实现目标接口，并包含一个适配者的实例。 对象适配器模式：\n使用对象组合，通过一个单独的类来实现转换，这个类包含一个指向适配者对象的引用。 接口适配器模式：\n通过一个接口来适配，通常用于实现多个接口的情况。 1.3.类适配器 对象适配器 接口适配器 c++示例 类适配器、对象适配器和接口适配器是适配器模式的三种形式，它们用于解决接口不兼容的问题。以下是它们之间的主要区别以及C++示例：\n1.3.1.类适配器（Class Adapter） 使用继承来实现。 适配器类继承自目标接口和适配者类。 C++ 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 目标接口 class ITarget { public: virtual void request() = 0; }; // 适配者类 class Adaptee { public: void specificRequest() { std::cout \u0026lt;\u0026lt; \u0026#34;Adaptee specific request\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 类适配器 class ClassAdapter : public ITarget, private Adaptee { public: void request() override { specificRequest(); // 调用继承自 Adaptee 的方法 } }; 1.3.2.对象适配器（Object Adapter） 使用组合来实现。 适配器类包含一个适配者类的实例，并在内部委托调用。 C++ 示例：\n1 2 3 4 5 6 7 8 9 10 // 对象适配器 class ObjectAdapter : public ITarget { private: Adaptee adaptee; // 组合 Adaptee public: void request() override { adaptee.specificRequest(); // 委托调用 Adaptee 的方法 } }; 1.3.3.接口适配器（Interface Adapter） 通常指适配多个接口的情况。 适配器类实现多个源接口，并将它们的调用适配到目标接口。 C++ 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 另一个适配者接口 class IAnotherAdaptee { public: virtual void anotherRequest() = 0; }; // 另一个适配者实现 class AnotherAdapteeImpl : public IAnotherAdaptee { public: void anotherRequest() override { std::cout \u0026lt;\u0026lt; \u0026#34;Another Adaptee request\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 接口适配器实现 ITarget 和 IAnotherAdaptee class InterfaceAdapter : public ITarget, public IAnotherAdaptee { public: void request() override { anotherRequest(); // 实现 ITarget 的请求，委托给 IAnotherAdaptee 的实现 } void anotherRequest() override { // ... 实现 IAnotherAdaptee 的请求 } }; 1.3.4.区别总结 类适配器通过继承实现适配，适用于适配者接口较为固定的情况。 对象适配器通过组合实现适配，提供了更高的灵活性，可以在运行时动态改变适配者对象。 接口适配器通常用于适配多个具有不同接口的适配者，通过实现多个接口来统一调用。 在实际开发中，选择哪种适配器模式取决于具体的设计需求和现有的代码结构。\n1.4.适配器模式的应用场景 当你希望使用一个已经存在的类，但这个类的接口与你需要的不兼容时。 当你想创建一个可以复用的类，用于与一个或多个不兼容的接口进行交互时。 当你想提供一个统一的高层接口，用于访问不同的子系统或类库时。 适配器模式使得你可以在不修改原有类代码的前提下，通过引入一个中间层来适配不同类的接口，提高了代码的灵活性和复用性。\n2.适配器模式优缺点 优点 单一职责原则你可以将接口或数据转换代码从程序主要业务逻辑中分离。 开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端- 代码的情况下在程序中添加新类型的适配器。 缺点 代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。 3.适配器模式应用场景 适配器模式在实际开发中的应用非常广泛，以下是一些常见的应用场景：\n第三方库的集成： 当需要使用一个第三方库，但其接口与现有系统不兼容时，可以创建一个适配器来转换接口。\n新旧系统的迁移： 在新旧系统迁移过程中，旧系统可能使用一些特定的接口，通过适配器模式可以逐步将旧接口替换为新接口。\n硬件设备的控制： 在硬件设备通信中，不同的设备可能有不同的通信协议，适配器模式可以用来统一这些协议，简化控制逻辑。\nUI组件的复用： 在图形用户界面开发中，不同厂商提供的组件可能有不同的接口，使用适配器模式可以使这些组件能够在不同的环境中复用。\n支付网关集成： 集成多个支付平台时，每个平台的API可能不同，通过适配器模式可以为应用程序提供一个统一的支付接口。\n数据访问层： 在数据访问层，不同的数据库可能有不同的访问接口，适配器模式可以用来创建一个统一的数据访问接口。\n中间件开发： 中间件通常需要与不同的系统或应用程序交互，适配器模式可以用来适配这些不同的接口。\nWeb服务的消费者： 当使用多个Web服务时，每个服务可能使用不同的数据格式或通信协议，适配器模式可以用来标准化这些服务的调用。\n遗留代码的重构： 在处理遗留代码时，可能需要修改接口以适应新的需求，适配器模式可以在不修改原有代码的情况下实现这一点。\n模块化设计： 在模块化设计中，不同的模块可能使用不同的接口，适配器模式可以用来连接这些模块，实现松耦合。\n测试驱动开发： 在测试驱动开发中，适配器模式可以用来模拟外部系统的接口，方便进行单元测试。\n云服务集成： 集成不同的云服务时，每个服务可能有不同的API，适配器模式可以用来提供一个统一的接口。\n适配器模式通过提供一个中间层来转换接口，使得原本不兼容的接口可以协同工作，从而提高了系统的灵活性和可扩展性。\n4.类适配器 对象适配器 接口适配器区别 类适配器、对象适配器和接口适配器都是适配器模式的实现方式，它们用于解决接口不兼容的问题。以下是这三种适配器模式的主要区别：\n4.1.类适配器模式（Class Adapter Pattern） 使用继承来实现。 将目标接口作为基类，适配器类继承目标接口并包含一个适配者对象。 由于使用了继承，类适配器模式可能会受限于现有类的继承结构，并且可能违反里氏替换原则。 通常用于适配者和目标接口之间有较大差异的情况。 4.2.对象适配器模式（Object Adapter Pattern） 使用组合来实现。 适配器类包含一个指向适配者对象的引用，并通过委托方式调用适配者的方法。 适配器类实现目标接口，将调用转发给内部的适配者对象。 对象适配器模式更加灵活，不受限于继承结构，可以同时适配多个适配者类。 通常用于需要适配多个具有不同接口的适配者类的情况。 4.3.接口适配器模式（Interface Adapter Pattern） 这个术语在设计模式的官方分类中并不常见，它通常指的是使用接口来实现适配的功能。 接口适配器模式不直接继承或包含适配者，而是定义一个新的接口，该接口将多个不兼容的接口统一起来。 这种模式通常涉及到多个接口的适配，而不是单个类或对象。 它允许一个类实现多个接口，并将这些接口的方法映射到一个统一的接口上。 4.4.应用场景 类适配器适用于你想要使用一个已有的类，并且这个类的方法可以作为基类的一部分时。 对象适配器适用于你想要使用一个已有的类，但是不想通过继承改变其结构时，或者需要适配多个不同的类时。 接口适配器适用于需要将多个不兼容的接口统一为一个接口，以便可以在不同的上下文中使用它们时。 4.5.举例说明 类适配器：假设有一个MediaPlayer接口和一个AudioPlayer类，AudioPlayer有一个播放MP3的方法。如果需要让AudioPlayer播放视频，可以创建一个MediaAdapter类，继承自MediaPlayer，内部包含一个AudioPlayer实例，并添加播放视频的方法。 对象适配器：在上述例子中，如果不希望继承MediaPlayer接口，可以创建一个MediaAdapter类，包含一个AudioPlayer的实例，并实现MediaPlayer接口，将播放视频的方法委托给AudioPlayer的播放MP3方法。 接口适配器：如果存在多个播放接口，如PlayVideo和PlayAudio，可以创建一个UnifiedPlayer接口，它将这些播放方法统一起来，然后实现这个接口，将不同的播放请求映射到相应的播放方法。 每种适配器模式都有其适用场景和优缺点，开发者需要根据具体情况选择最合适的适配器模式。\n5.在实际项目中，如何决定使用类适配器还是对象适配器？ 在实际项目中，决定使用类适配器还是对象适配器取决于多种因素，包括设计要求、项目结构、代码复用性、灵活性需求以及维护性等。以下是一些指导原则，可以帮助你做出决定：\n复用现有子类：\n如果你需要复用现有的适配者子类，类适配器模式可能更合适，因为它通过继承来扩展现有类的功能。 多重继承问题：\n如果你的编程语言不支持多重继承，或者多重继承在项目中导致问题，对象适配器模式是更好的选择，因为它使用组合而非继承。 修改现有类：\n如果你不能或不想修改现有的适配者类（例如，当它是第三方库的一部分时），对象适配器模式允许你在不修改原有代码的情况下进行适配。 灵活性和扩展性：\n对象适配器模式提供了更高的灵活性，因为它允许你在运行时更换适配者对象，而类适配器则在编译时就确定了适配者。 单一职责原则：\n如果希望遵循单一职责原则，避免在类适配器中引入多个适配者接口的实现，对象适配器模式允许你将不同的适配者职责分离到不同的适配器类中。 接口转换：\n如果需要将多个不同的接口转换为一个统一的接口，对象适配器模式可能更合适，因为它可以包含多个适配者对象并统一它们的接口。 代码清晰性和可维护性：\n如果使用类适配器会使代码变得复杂难以理解，对象适配器模式可能更易于维护，因为它将适配逻辑封装在单独的类中。 性能考虑：\n在某些对性能要求极高的场景下，继承（类适配器）可能比组合（对象适配器）有更小的运行时开销。但这种差异通常非常小，不应成为主要决策因素。 设计一致性：\n考虑项目中的其他设计模式和原则，选择与项目整体设计风格一致的适配器模式。 团队熟悉度：\n考虑团队对两种模式的熟悉程度和使用经验，选择团队更熟悉和更易于维护的模式。 在实际应用中，两种适配器模式都可以用来解决接口不兼容的问题，选择哪一种取决于具体的上下文和上述提到的考虑因素。有时，为了保持设计的一致性或者满足特定的技术需求，项目可能会选择使用其中一种模式。在其他情况下，两种模式都适用，选择哪一种更多地取决于个人或团队的偏好。\n6.接口适配器在多线程环境下使用时需要注意哪些问题？ 在多线程环境下使用接口适配器时，需要注意以下几个问题：\n线程安全性： 确保适配器实现或继承的接口或类是线程安全的。如果适配器中包含共享资源，需要使用适当的同步机制（如互斥锁、信号量等）来避免竞态条件和数据不一致问题 。\n避免死锁： 在使用多个锁或资源时，要注意避免死锁的发生。确保以一致的顺序获取锁，或者使用锁管理工具来帮助避免死锁 。\n资源管理： 适配器在多线程环境中可能会涉及到资源的分配和释放，需要确保资源的正确管理，避免资源泄露或重复释放 。\n性能考虑： 适配器可能会引入额外的同步开销，特别是在高并发场景下。需要评估并优化适配器的性能，以避免成为系统的性能瓶颈 。\n异常处理： 适配器在多线程环境中可能会遇到线程中断或异常情况，需要妥善处理这些异常，确保系统的稳定性和健壮性 。\n线程局部变量： 如果适配器需要为每个线程维护独立的状态，可以使用线程局部变量（Thread Local Storage, TLS）来避免共享状态的问题 。\n并发集合类： 考虑使用Java提供的并发集合类，如ConcurrentHashMap，这些集合类在多线程环境下自动处理线程安全问题，可以减少适配器实现的复杂性 。\n锁的粒度和公平性： 选择合适的锁粒度和公平性策略，以平衡性能和线程调度的公平性，避免线程饥饿或锁竞争 。\n线程池的使用： 在多线程环境中，使用线程池来管理线程的创建和销毁，可以有效减少线程创建和销毁的开销，提高资源利用率 。\n通过考虑这些方面，可以确保接口适配器在多线程环境下的安全性、稳定性和性能。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-adapter-pattern/","title":"design pattern adapter pattern"},{"content":"设计模式-行为模式-behavioral patterns [TOC]\nOverview 1.行为模式（Behavioral Patterns） 行为模式（Behavioral Patterns）是软件设计模式的一种，主要关注对象之间的通信和职责的分配。行为模式提供了不同类和对象之间交互的一般化方法，有助于管理和简化复杂的交互逻辑。以下是十一种常见的行为设计模式：\n策略模式（Strategy Pattern）：\n定义一系列算法，将每个算法封装起来，并使它们可以互换。策略模式让算法的变化独立于使用算法的客户。 模板方法模式（Template Method Pattern）：\n在一个方法中定义一个算法的骨架，将一些步骤的执行延迟到子类中。模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法的某些特定步骤。 观察者模式（Observer Pattern）：\n定义对象之间的一对多依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。 迭代器模式（Iterator Pattern）：\n提供一种顺序访问聚合对象中的各个元素，而不需要暴露聚合对象的内部表示。 责任链模式（Chain of Responsibility Pattern）：\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。 命令模式（Command Pattern）：\n将请求或操作封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。 备忘录模式（Memento Pattern）：\n在不破坏封装性的前提下，捕获并保存一个对象的内部状态，以便以后可以恢复到这个状态。 状态模式（State Pattern）：\n允许一个对象在其内部状态发生改变时改变其行为，看起来好像改变了其类。 访问者模式（Visitor Pattern）：\n为一个对象结构（如组合结构）增加新能力，不改变结构中的类。 中介者模式（Mediator Pattern）：\n定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使得对象之间不再相互引用，而是通过中介者来进行交互。 解释器模式（Interpreter Pattern）：\n定义一个语言的文法，并建立一个解释器来解释该语言中的句子。解释器模式适合于简单的语言或脚本。 行为模式的应用场景包括但不限于：\n策略模式：适用于需要动态选择算法或行为的场景，如游戏AI、图像处理算法等。 模板方法模式：适用于需要固定算法结构，同时允许子类定制特定步骤的场景。 观察者模式：适用于需要建立对象之间的一对多依赖关系，如事件发布订阅系统。 迭代器模式：适用于需要访问聚合对象内部元素，但不想暴露其内部结构的场景。 责任链模式：适用于需要多个对象依次处理请求，且请求的处理者不明确的场景。 命令模式：适用于需要将操作封装为对象，支持命令的排队、记录或撤销的场景。 备忘录模式：适用于需要保存和恢复对象状态的场景，如撤销/重做操作。 状态模式：适用于对象状态变化导致行为变化的场景，如订单状态管理。 访问者模式：适用于需要对一个对象结构添加新操作，同时又不想修改现有对象结构的场景。 中介者模式：适用于需要降低多个对象或类之间的复杂交互关系的场景。 解释器模式：适用于需要实现简单的语言或语法解析的场景。 行为模式通过定义对象之间的相互作用，帮助开发者实现灵活、可扩展的系统设计。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-behavioral-patterns/","title":"design pattern behavioral patterns"},{"content":"设计模式-桥接模式-bridge pattern [TOC]\nOverview 桥接模式（Bridge Pattern）是一种结构性设计模式 用于将抽象部分与其实现部分分离，使它们可以独立地变化 通俗来说，桥接模式就是车上船，车就是具体实现 1.桥接模式（Bridge Pattern） 桥接模式（Bridge Pattern）是一种结构性设计模式，用于将抽象部分与其实现部分分离，使它们可以独立地变化。这种模式通过定义一个桥接接口，将实现的类和抽象的类解耦，从而能够独立地扩展抽象类和实现类。\n1.1.桥接模式的主要角色包括 抽象（Abstraction）：\n定义了客户使用的接口，维护一个指向实现化对象的引用。 扩展抽象（Refined Abstraction）：\n扩展抽象类，添加了更多的业务方法。 实现化（Implementor）：\n定义了实现化的接口，它不被抽象类直接使用，而是仅作为扩展抽象类的一部分。 具体实现化（Concrete Implementor）：\n实现化接口的具体类，包含了实现化的具体业务。 1.2.C++实现示例 首先，定义实现化接口：\n1 2 3 4 5 6 // Implementor.h class Implementor { public: virtual ~Implementor() {} virtual void operation() = 0; }; 接着，创建具体的实现化类：\n1 2 3 4 5 6 7 8 9 // ConcreteImplementor.h #include \u0026#34;Implementor.h\u0026#34; class ConcreteImplementor : public Implementor { public: void operation() override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteImplementor operation\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 然后，定义抽象类：\n1 2 3 4 5 6 7 8 9 10 11 12 // Abstraction.h #include \u0026#34;Implementor.h\u0026#34; class Abstraction { protected: Implementor* implementor; public: Abstraction(Implementor* imp) : implementor(imp) {} virtual ~Abstraction() {} virtual void request() = 0; }; 接着，扩展抽象类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // RefinedAbstraction.h #include \u0026#34;Abstraction.h\u0026#34; class RefinedAbstraction : public Abstraction { public: RefinedAbstraction(Implementor* imp) : Abstraction(imp) {} void request() override { implementor-\u0026gt;operation(); refinedRequest(); } void refinedRequest() { std::cout \u0026lt;\u0026lt; \u0026#34;Refined request\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 最后，客户端代码使用桥接模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // main.cpp #include \u0026#34;ConcreteImplementor.h\u0026#34; #include \u0026#34;RefinedAbstraction.h\u0026#34; int main() { Implementor* imp = new ConcreteImplementor(); Abstraction* abstraction = new RefinedAbstraction(imp); abstraction-\u0026gt;request(); delete abstraction; delete imp; return 0; } 1.3.桥接模式的应用场景 当一个类存在两个独立变化的维度时：\n例如，一个图形系统，图形的类型和颜色是两个独立变化的维度。 当一个类需要从多个角度进行扩展时：\n每个角度可以使用不同的实现化。 当需要通过第三方类扩展系统时：\n第三方类可以作为实现化部分，而系统的核心功能作为抽象部分。 当不希望使用继承来扩展系统时：\n使用组合和接口来扩展系统，避免继承带来的耦合和限制。 桥接模式提供了一种灵活的方式来扩展系统的功能，同时保持系统的可维护性和可扩展性。通过桥接模式，可以在不修改现有代码的前提下，通过增加新的实现化类来扩展系统。\n2.桥接模式优缺点 优点 你可以创建与平台无关的类和程序。 客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。 开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。 单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。 缺点 对高内聚的类使用该模式可能会让代码更加复杂。 3.桥接模式使用场景 在实际项目中，桥接模式（Bridge Pattern）可以应用于多种场景，尤其是当需要将一个类的抽象部分与它的实现部分分离，以便它们可以独立地变化和扩展时。以下是一些具体的应用实例：\n图形界面库开发：\n在开发图形界面库时，可以使用桥接模式将界面的绘制（抽象部分）与具体的控件类型（实现部分）分离。这样，增加新的控件类型或改变绘制方式时，不需要修改已有的代码。 支付系统设计：\n在支付系统中，支付方式（如信用卡、PayPal、微信支付）可以作为实现化角色，而支付接口作为抽象部分。这样，添加新的支付方式或修改现有支付逻辑时互不影响。 游戏角色和行为分离：\n在游戏开发中，角色（如战士、法师）可以有一个抽象类，而具体的行为（如攻击、防御、移动）可以作为实现化角色。这样，可以灵活地为不同角色分配不同的行为。 硬件设备的驱动程序开发：\n当开发硬件设备的驱动程序时，可以使用桥接模式将设备的硬件控制（抽象部分）与具体的操作（实现部分）分离。这样，更换设备或更新操作逻辑时更加灵活。 网络应用的协议处理：\n在网络通信中，可以使用桥接模式将协议的抽象处理与具体的协议实现分离。这样，增加新的协议或修改现有协议的处理逻辑时，不需要修改核心的协议处理代码。 报告生成系统：\n在报告生成系统中，报告的格式（如PDF、Excel、HTML）可以作为实现化角色，而报告的内容生成逻辑作为抽象部分。这样，添加新的报告格式或修改报告内容时互不干扰。 多语言支持：\n在需要多语言支持的应用程序中，可以使用桥接模式将用户界面的元素（抽象部分）与不同的语言资源（实现部分）分离。这样，添加新的语言或更新翻译时更加方便。 软件的插件架构：\n当软件采用插件架构时，可以使用桥接模式将插件的接口（抽象部分）与具体的插件实现（实现部分）分离。这样，开发新的插件或更新现有插件时互不影响。 资源管理器：\n在资源管理器中，可以使用桥接模式将资源的访问方式（抽象部分）与具体的资源类型（实现部分）分离。这样，增加新的资源类型或改变资源访问方式时更加灵活。 通过这些应用实例，我们可以看到桥接模式在实际项目中的价值，它有助于提高代码的可维护性、可扩展性和灵活性。在设计系统时，如果预见到某个类可能会有多个变化维度，考虑使用桥接模式来避免未来代码的复杂性。\n4.在实际项目中，如何确保桥接模式的实现与抽象部分的解耦？ 在实际项目中，确保桥接模式的实现与抽象部分的解耦，可以遵循以下几个关键步骤：\n明确角色职责：\n清晰定义抽象部分（Abstraction）和实现部分（Implementor）的职责，确保它们之间的接口是明确的，并且没有依赖关系。 使用接口或抽象类：\n为实现部分定义一个接口或抽象类，这个接口或抽象类将被抽象部分所依赖，而不是具体的实现类。 依赖关系反向：\n确保抽象部分不直接依赖具体实现类，而是依赖实现部分的接口或抽象类。 通过组合实现解耦：\n在抽象部分中，使用一个成员变量来组合实现部分的接口或抽象类，而不是具体实现类。 避免直接引用实现类：\n在抽象部分的代码中，避免直接引用任何实现类的实例，所有的操作都通过实现部分的接口或抽象类来进行。 使用工厂模式：\n可以使用工厂模式来创建实现部分的对象，这样可以进一步解耦实现部分的具体类和抽象部分。 定义清晰的协议：\n为实现部分定义清晰的协议或接口，确保所有实现类都遵循这个协议，这样抽象部分不依赖于任何特定的实现细节。 单一职责原则：\n遵循单一职责原则，确保抽象类和实现类都只处理它们应该处理的职责。 编写单元测试：\n为抽象部分和实现部分编写单元测试，确保它们可以独立于彼此进行测试。 代码审查：\n通过代码审查来确保实现遵循桥接模式的原则，没有不当的依赖关系。 文档和注释：\n编写清晰的文档和注释，说明抽象部分和实现部分的接口和职责。 逐步集成：\n在集成过程中，逐步将抽象部分和实现部分结合起来，确保它们可以协同工作，同时保持各自的独立性。 使用依赖注入：\n利用依赖注入（Dependency Injection）来动态地将实现部分注入到抽象部分中，而不是在抽象部分中创建具体实现的实例。 避免条件语句：\n避免在抽象部分中使用条件语句来判断具体的实现类型，这有助于保持解耦。 通过这些步骤，可以确保在实际项目中实现桥接模式时，抽象部分和实现部分能够保持高度的解耦，从而提高代码的灵活性和可维护性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-bridge-pattern/","title":"design pattern bridge pattern"},{"content":"设计模式-生成器模式 builder_pattern [TOC]\nOverview 生成器模式（Builder Pattern）是一种创建型设计模式 用于构造一个复杂的对象。这个对象的构建过程涉及多个步骤，并且希望将构建过程与表示对象本身分离，使得相同的构建过程能够创建出不同的表示。 一个指挥者（Director）对象来控制构建过程 一个产品（Product）接口表示要构建的复杂对象 一个或多个具体的构建者（Builder）类来实现构建过程。 1.生成器模式 builder_pattern 生成器模式（Builder Pattern）是一种创建型设计模式，用于构造一个复杂的对象。这个对象的构建过程涉及多个步骤，并且希望将构建过程与表示对象本身分离，使得相同的构建过程能够创建出不同的表示。\n生成器模式通过引入一个指挥者（Director）对象来控制构建过程，一个产品（Product）接口表示要构建的复杂对象，以及一个或多个具体的构建者（Builder）类来实现构建过程。这样，你可以在不改变构建过程的情况下，通过改变构建者的具体实现来创建不同的产品。\n以下是使用C++实现生成器模式的一个示例：\n首先，定义产品接口：\n1 2 3 4 5 6 // Product.h class Product { public: virtual ~Product() {} // 其他产品相关的接口和实现... }; 接着，创建具体的产品类：\n1 2 3 4 5 6 7 // ConcreteProduct.h #include \u0026#34;Product.h\u0026#34; class ConcreteProduct : public Product { public: // 具体产品的实现... }; 然后，定义构建者接口：\n1 2 3 4 5 6 7 8 9 10 11 // Builder.h #include \u0026#34;Product.h\u0026#34; class Builder { public: virtual ~Builder() {} virtual void BuildPartA() = 0; virtual void BuildPartB() = 0; // 其他构建方法... virtual Product* GetProduct() = 0; }; 接下来，创建具体的构建者类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // ConcreteBuilder.h #include \u0026#34;Builder.h\u0026#34; #include \u0026#34;ConcreteProduct.h\u0026#34; class ConcreteBuilder : public Builder { ConcreteProduct* product_; public: ConcreteBuilder() : product_(new ConcreteProduct()) {} ~ConcreteBuilder() {} void BuildPartA() override { // 构建产品的一部分... } void BuildPartB() override { // 构建产品的一部分... } Product* GetProduct() override { return product_; } }; 然后，定义指挥者类：\n1 2 3 4 5 6 7 8 9 10 11 // Director.h #include \u0026#34;Builder.h\u0026#34; class Director { public: void Construct(Builder* builder) { builder-\u0026gt;BuildPartA(); builder-\u0026gt;BuildPartB(); // 调用其他构建方法... } }; 最后，客户端代码使用生成器模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // main.cpp #include \u0026#34;Director.h\u0026#34; #include \u0026#34;ConcreteBuilder.h\u0026#34; int main() { Director director; ConcreteBuilder builder; director.Construct(\u0026amp;builder); Product* product = builder.GetProduct(); // 使用构建好的产品... delete product; // 清理资源 return 0; } 在这个示例中，Product 是产品接口，ConcreteProduct 是具体产品。Builder 是构建者接口，ConcreteBuilder 是具体构建者，实现了构建过程。Director 是指挥者，负责调用构建者的方法来构建产品。客户端代码通过指挥者和构建者来创建复杂的产品对象，而不需要知道具体的构建细节。这样，如果需要添加新的产品类型，只需要添加相应的具体构建者即可，不需要修改现有代码。\n2.生成器模式优缺点 2.1.优点 你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。 生成不同形式的产品时， 你可以复用相同的制造代码。 单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。 2.2.缺点 由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。 3.生成器模式在实际开发中有哪些应用场景？ 生成器模式（Builder Pattern）在实际开发中有多种应用场景，尤其适用于创建一个复杂对象的步骤很多，或者对象的创建过程需要高度的灵活性时。以下是一些具体的应用实例：\n构建复杂对象：\n当对象的构造需要多个步骤，并且这些步骤可能会经常变化时，使用生成器模式可以将构建过程封装起来，便于管理和修改。 GUI组件构建：\n在图形用户界面（GUI）编程中，生成器模式可以用来构建复杂的界面组件，如面板、菜单、工具栏等，这些组件可能由多个小部件组成。 数据库连接：\n在数据库编程中，可以使用生成器模式构建数据库连接字符串，不同的数据库类型（如MySQL、PostgreSQL）可能需要不同的连接参数。 配置文件解析：\n当需要从配置文件（如XML、JSON）构建配置对象时，生成器模式可以提供一种灵活的方式来处理不同的配置选项。 Web页面内容生成：\n在Web开发中，生成器模式可以用来构建复杂的页面内容，如HTML、CSS、JavaScript代码，这些代码可能由多个部分组成。 报表生成：\n报表软件中，生成器模式可以用来构建复杂的报表，报表可能包含文本、图表、表格等多种元素。 数据结构的构建：\n在算法实现中，如果需要构建复杂的数据结构，如树、图等，生成器模式可以提供一种清晰的方式来组织构建过程。 对象的版本控制：\n当对象有多个版本或变体时，可以使用不同的构建者来创建对象的不同版本。 API请求构建：\n在网络编程中，生成器模式可以用来构建复杂的API请求，包括设置请求头、请求体、参数等。 游戏角色创建：\n在游戏开发中，生成器模式可以用来创建具有多种属性和技能的游戏角色。 汽车配置：\n在实际的汽车制造系统中，生成器模式可以用来根据不同的配置选项构建汽车，如发动机类型、颜色、内饰等。 产品定制：\n对于需要定制的产品，如家具、电脑硬件等，生成器模式可以帮助用户选择不同的组件和选项来定制产品。 使用生成器模式可以使得构建过程与表示对象本身分离，提高系统的灵活性和可扩展性。同时，它也使得相同的构建过程能够创建出不同的表示，增加了代码的复用性。\n4.生成器模式和工厂模式有什么区别，它们各自适用于什么情况？ 生成器模式（Builder Pattern）和工厂模式（Factory Pattern）都是创建型设计模式，用于创建对象，但它们在应用场景和设计意图上存在一些关键的区别：\n4.1.生成器模式（Builder Pattern） 适用场景：生成器模式适用于创建一个复杂对象，这个对象的构建过程涉及多个步骤，并且希望将构建过程与表示对象本身分离，使得相同的构建过程能够创建出不同的表示。 特点： 创建的对象通常由多个部分组成，且这些部分的构建顺序很重要。 允许用户通过指定的构建步骤来创建一个复杂的对象。 可以存在多个不同的构建者，它们实现了相同的构建接口，但构建过程的细节可能不同。 4.2.工厂模式（Factory Pattern） 适用场景：工厂模式用于创建一个对象，当这个对象的创建逻辑与使用该对象的客户端逻辑分离时，可以使用工厂模式。它适用于当创建对象的逻辑较为简单，不需要多个步骤时。 特点： 提供一个接口用于创建对象，让子类决定实例化哪一个类。 通常用于处理对象的创建，这些对象的创建过程不会太复杂。 隐藏了实例创建的细节，由工厂类来决定如何创建对象。 4.3.区别 复杂性：\n生成器模式适合创建过程复杂的对象，而工厂模式适合创建过程简单的对象。 分离度：\n生成器模式通过构建者类和指挥者类进一步分离了创建逻辑和表示细节，而工厂模式通常只包含一个工厂类来处理创建逻辑。 灵活性：\n生成器模式提供了更高的灵活性，可以通过不同的构建者类创建不同的产品，而工厂模式通常只能创建一种类型的对象。 使用场景：\n如果对象的创建涉及到多个步骤，并且这些步骤可能会变化，生成器模式是一个更好的选择。 如果对象的创建逻辑相对简单，或者创建逻辑是固定的，工厂模式可能更合适。 可扩展性：\n生成器模式更容易扩展以支持新的产品类型，因为可以引入新的构建者类而不需要修改现有的构建过程。 代码结构：\n生成器模式通常包含多个类（产品、构建者接口、具体构建者、指挥者），而工厂模式可能只包含一个工厂类和产品类。 在选择使用哪种模式时，需要根据实际的需求和上下文来决定。如果对象的创建过程复杂且可能变化，生成器模式提供了更好的解决方案；如果对象的创建过程简单且不太可能变化，工厂模式可能是一个更简单直接的选择。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-builder_pattern/","title":"design pattern builder_pattern"},{"content":"设计模式-责任链模式-Chain of Responsibility Pattern [TOC]\nOverview 责任链模式（Chain of Responsibility Pattern）是一种行为设计模式 它允许一个请求沿着一条链（多个对象组成的链）传递，直到链上的某个对象能够处理该请求为止 这种模式将请求的发送者和接收者解耦，使得多个对象都有机会处理请求，从而增加了系统的灵活性 能看多少是多少，看不完下次记得回来看 1.责任链模式（Chain of Responsibility Pattern） 责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它允许一个请求沿着一条链（多个对象组成的链）传递，直到链上的某个对象能够处理该请求为止。这种模式将请求的发送者和接收者解耦，使得多个对象都有机会处理请求，从而增加了系统的灵活性。\n责任链模式的主要特点包括：\n请求的传递性：请求在责任链上的多个对象间传递，直到被处理。 对象的解耦：请求的发送者不需要知道哪个具体对象会处理其请求，也不需要知道链的结构。 动态调整：责任链可以根据需要动态地增加或移除处理对象，提高了系统的可扩展性。 处理的多样性：一个请求可以被多个对象处理，或者由链上的某个对象最终处理。 责任链模式的结构通常包括以下角色：\nHandler（抽象处理者）：定义一个处理请求的接口，通常包含一个指向下一个处理者的引用。 ConcreteHandler（具体处理者）：实现抽象处理者接口，负责处理请求或将请求传递给链上的下一个处理者。 Client（客户端）：创建处理者链，并提交请求。 以下是一个简单的责任链模式的实现示例（以C++为例）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // 抽象处理者 class Handler { public: virtual ~Handler() {} virtual void HandleRequest(int request) = 0; virtual void SetSuccessor(std::shared_ptr\u0026lt;Handler\u0026gt; successor) = 0; }; // 具体处理者A class ConcreteHandlerA : public Handler { std::shared_ptr\u0026lt;Handler\u0026gt; successor; public: void HandleRequest(int request) override { if (request \u0026gt;= 0 \u0026amp;\u0026amp; request \u0026lt; 10) { std::cout \u0026lt;\u0026lt; \u0026#34;HandlerA handles request \u0026#34; \u0026lt;\u0026lt; request \u0026lt;\u0026lt; std::endl; } else { if (successor) { successor-\u0026gt;HandleRequest(request); } } } void SetSuccessor(std::shared_ptr\u0026lt;Handler\u0026gt; successor) override { this-\u0026gt;successor = successor; } }; // 具体处理者B class ConcreteHandlerB : public Handler { std::shared_ptr\u0026lt;Handler\u0026gt; successor; public: void HandleRequest(int request) override { if (request \u0026gt;= 10 \u0026amp;\u0026amp; request \u0026lt; 20) { std::cout \u0026lt;\u0026lt; \u0026#34;HandlerB handles request \u0026#34; \u0026lt;\u0026lt; request \u0026lt;\u0026lt; std::endl; } else { if (successor) { successor-\u0026gt;HandleRequest(request); } } } void SetSuccessor(std::shared_ptr\u0026lt;Handler\u0026gt; successor) override { this-\u0026gt;successor = successor; } }; int main() { auto handlerA = std::make_shared\u0026lt;ConcreteHandlerA\u0026gt;(); auto handlerB = std::make_shared\u0026lt;ConcreteHandlerB\u0026gt;(); handlerA-\u0026gt;SetSuccessor(handlerB); handlerB-\u0026gt;SetSuccessor(nullptr); // 链的末端 handlerA-\u0026gt;HandleRequest(5); // 由HandlerA处理 handlerA-\u0026gt;HandleRequest(15); // 由HandlerB处理 handlerA-\u0026gt;HandleRequest(25); // 无人处理 return 0; } 在这个例子中，Handler是一个抽象类，定义了处理请求的接口和设置下一个处理者的接口。ConcreteHandlerA和ConcreteHandlerB是具体的处理者，它们实现了Handler接口。客户端创建了两个处理者对象，并设置它们之间的责任链。然后，客户端通过责任链提交请求。\n责任链模式适用于以下场景：\n多个对象可能处理同一个请求，但具体哪个对象处理该请求并不明确。 需要动态地增加或移除责任链中的处理者。 客户端只需要发送请求，而不需要知道请求是如何被处理的，也不需要知道有哪些对象参与了处理。 2.责任链模式优缺点 优点 你可以控制请求处理的顺序。 单一职责原则。 你可对发起操作和执行操作的类进行解耦。 开闭原则。 你可以在不更改现有代码的情况下在程序中新增处理者。 缺点 部分请求可能未被处理。 3.如何设计一个责任链模式的客户端来使用这个模式？ 在C++中设计一个责任链模式的客户端，可以遵循以下步骤：\n定义处理者接口：创建一个抽象基类，定义处理请求的接口和设置下一个处理者的指针。\n实现具体处理者：创建具体处理者类，继承自处理者接口，并实现处理请求的方法。\n组装责任链：在客户端代码中，创建具体处理者对象的实例，并将它们连接成链。\n发送请求：客户端创建请求并将其发送给责任链的第一个处理者。\n以下是一个C++中责任链模式的示例实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; // 定义请求类 class Request { public: int type; // 请求类型 explicit Request(int type) : type(type) {} }; // 定义处理者接口 class Handler { public: virtual ~Handler() {} virtual void HandleRequest(std::shared_ptr\u0026lt;Request\u0026gt; request) = 0; virtual void SetSuccessor(std::shared_ptr\u0026lt;Handler\u0026gt; successor) = 0; }; // 实现具体处理者A class ConcreteHandlerA : public Handler { private: std::shared_ptr\u0026lt;Handler\u0026gt; successor; public: void HandleRequest(std::shared_ptr\u0026lt;Request\u0026gt; request) override { if (request-\u0026gt;type == 1) { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteHandlerA handles the request.\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (successor) { successor-\u0026gt;HandleRequest(request); } } void SetSuccessor(std::shared_ptr\u0026lt;Handler\u0026gt; successor) override { this-\u0026gt;successor = successor; } }; // 实现具体处理者B class ConcreteHandlerB : public Handler { private: std::shared_ptr\u0026lt;Handler\u0026gt; successor; public: void HandleRequest(std::shared_ptr\u0026lt;Request\u0026gt; request) override { if (request-\u0026gt;type == 2) { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteHandlerB handles the request.\u0026#34; \u0026lt;\u0026lt; std::endl; } else if (successor) { successor-\u0026gt;HandleRequest(request); } } void SetSuccessor(std::shared_ptr\u0026lt;Handler\u0026gt; successor) override { this-\u0026gt;successor = successor; } }; // 客户端代码 int main() { auto handlerA = std::make_shared\u0026lt;ConcreteHandlerA\u0026gt;(); auto handlerB = std::make_shared\u0026lt;ConcreteHandlerB\u0026gt;(); handlerA-\u0026gt;SetSuccessor(handlerB); // 组装责任链 // 创建请求并发送 std::shared_ptr\u0026lt;Request\u0026gt; requestA = std::make_shared\u0026lt;Request\u0026gt;(1); std::shared_ptr\u0026lt;Request\u0026gt; requestB = std::make_shared\u0026lt;Request\u0026gt;(2); handlerA-\u0026gt;HandleRequest(requestA); // 应该由ConcreteHandlerA处理 handlerA-\u0026gt;HandleRequest(requestB); // 应该由ConcreteHandlerB处理 return 0; } 在这个示例中，Handler 是一个抽象基类，定义了 HandleRequest 和 SetSuccessor 方法。ConcreteHandlerA 和 ConcreteHandlerB 是具体处理者类，它们实现了 Handler 接口。每个处理者在处理请求时，会检查请求类型是否符合自己的处理条件，如果不符合且存在后继者，则将请求传递给后继者。\n客户端代码创建了 ConcreteHandlerA 和 ConcreteHandlerB 的实例，并通过调用 SetSuccessor 方法将它们连接成一条责任链。然后，客户端创建了两个请求，并将它们发送给责任链的第一个处理者（handlerA）。\n通过这种方式，客户端可以灵活地使用责任链模式来处理请求，同时保持请求发送者和接收者之间的解耦。\n4.责任链模式在实际项目中有哪些应用场景？ 责任链模式在实际项目中的应用场景非常广泛，以下是一些典型的应用案例：\n多步骤审批流程：例如，在企业内部的审批系统中，一个审批请求可能需要经过多个层级的审批者，如部门经理、财务经理、总经理等。每个审批者根据自己的职责和权限处理请求，如果无法处理则传递给下一个审批者。这种场景可以通过责任链模式实现，使得审批流程清晰且易于管理。\n权限控制系统：在权限控制中，用户的不同操作可能需要不同权限级别的审批。责任链模式可以用于构建一个权限验证链，每个节点代表一个权限检查，请求在链上传递直到被适当权限的节点处理。\n事件处理系统：在图形用户界面（GUI）编程中，事件（如鼠标点击、键盘输入）可能需要多个组件处理。责任链模式允许事件在组件层级结构中传递，直到某个组件处理该事件。\n日志系统：在日志系统中，可以根据日志级别（如INFO、DEBUG、ERROR）将日志消息传递给不同的处理器。责任链模式可以用于构建日志处理器链，每个处理器处理特定级别的日志。\n过滤器链：在Java的Servlet过滤器中，请求在到达目标资源之前可能需要通过多个过滤器的处理。每个过滤器可以执行特定的任务，如身份验证、日志记录等，然后将请求传递给下一个过滤器。\n工作流系统：在工作流管理系统中，任务可能需要按照特定的顺序经过多个处理步骤。责任链模式可以用来构建这样的工作流，每个步骤作为一个处理节点，任务在链上传递直到完成。\n错误处理：在软件系统中，错误和异常可能需要多个处理器来处理。责任链模式可以用于构建一个错误处理链，每个节点负责处理特定类型的错误。\n性能优化：在某些情况下，责任链模式可以用于优化性能，例如通过缓存机制避免不必要的处理，或者通过请求过滤减少责任链的遍历。\nTomcat 过滤器：在Tomcat服务器中，过滤器链用于处理HTTP请求和响应。每个过滤器可以执行特定的任务，如权限检查、请求日志记录等，然后将请求传递给下一个过滤器。\n通过这些应用场景，我们可以看到责任链模式如何帮助系统设计变得更加灵活和可维护，同时也提高了代码的可读性和可扩展性。\n5.责任链模式在权限控制系统中是如何实现的，能否举例说明？ 责任链模式在权限控制系统中的应用主要是通过创建一系列的处理对象（处理器），每个对象负责特定的权限验证任务。这些处理对象按照特定的顺序连接成一条链，当一个权限验证请求到来时，请求会沿着这条链传递，直到被适当的处理对象处理。\n以下是责任链模式在权限控制系统中实现的步骤和技术细节：\n定义处理接口：首先定义一个处理接口，通常包含一个处理方法和一个设置下一个处理者的引用的方法。\n创建具体处理者：根据不同的权限验证需求，创建具体的处理者类，每个类实现处理接口，并在处理方法中添加具体的验证逻辑。\n组装责任链：在系统初始化或运行时，根据配置信息或业务逻辑动态地组装责任链，将各个处理者连接起来。\n请求处理：当用户发起权限请求时，请求首先被发送到责任链的第一个处理者，如果该处理者无法处理，则将请求传递给链中的下一个处理者，依此类推。\n处理结果：一旦请求被处理，处理者可以返回处理结果，或者根据业务需求继续沿着责任链传递。\n错误处理和日志记录：在责任链的实现中，通常需要考虑错误处理和日志记录的逻辑，以便于调试和审计。\n例如，在一个Web应用中，可能需要对用户的请求进行登录验证、角色检查、权限验证等多个步骤的检查。每个步骤都由一个具体处理者实现，这些处理者按照请求处理的顺序连接成一条责任链。用户的请求首先经过登录验证处理器，如果通过，则传递给角色检查处理器，以此类推，直到所有的验证都通过，或者某个验证失败并返回错误信息。\n通过责任链模式，权限控制系统可以灵活地增加、删除或修改权限验证的步骤，而不需要修改现有的代码，提高了系统的可扩展性和可维护性。同时，该模式也使得请求处理的流程更加清晰，便于理解和管理。\n6.在责任链模式中，如果某个处理者无法处理请求，它会如何影响整个责任链？ 在责任链模式中，如果某个处理者无法处理请求，这通常会导致以下几种情况：\n传递给下一个处理者：如果当前处理者无法处理请求，它会将请求传递给链中的下一个处理者。这个过程会一直持续，直到请求被处理或传递到链的末端。\n请求未被处理：如果责任链中的所有处理者都无法处理请求，那么请求可能会被忽略或被视为无效。在这种情况下，客户端可能需要提供一种默认的处理策略或错误处理机制。\n错误处理：在某些实现中，如果请求无法被处理，可能会触发一个错误处理流程。这可以是责任链中的一个特殊处理者，或者是一个在链外独立的错误处理机制。\n记录日志：在请求无法被处理的情况下，系统可能会记录日志信息，以便后续分析和调试。\n通知客户端：在某些设计中，如果请求无法被处理，责任链可能会通过某种方式通知客户端，例如返回一个错误码或抛出一个异常。\n终止处理：如果某个处理者无法处理请求，它可以选择不将请求传递给下一个处理者，从而终止进一步的处理。\n回退处理：在某些情况下，如果后续处理者都无法处理请求，责任链可能会回退到之前的处理者，尝试其他可能的处理策略。\n为了确保责任链的正确性和健壮性，设计时应该考虑以下因素：\n默认处理者：在责任链的末端设置一个默认处理者，以处理那些未被前面处理者处理的请求。 错误处理策略：定义清晰的错误处理策略，以便在请求无法被处理时采取适当的措施。 日志记录：在责任链的每个处理者中添加日志记录，以便于跟踪请求的处理过程和诊断问题。 客户端反馈：确保客户端能够接收到关于请求处理结果的反馈，无论是成功处理还是无法处理。 通过这些措施，可以确保责任链模式在处理请求时的灵活性和可靠性，同时减少因请求未被处理而带来的潜在问题。\n7.如果责任链中的某个处理者抛出异常，应该如何设计异常处理机制？ 在责任链模式中，如果某个处理者在处理请求时抛出异常，应该设计一个健壮的异常处理机制来确保系统的稳定性和可靠性。以下是设计异常处理机制的一些建议：\n在处理者中捕获异常：每个处理者应该在其handleRequest方法中添加异常捕获逻辑，以便在处理请求时捕获并处理可能发生的异常。\n定义异常处理策略：为责任链定义一个统一的异常处理策略，例如记录日志、发送错误通知、清理资源等。\n传递异常信息：如果当前处理者无法处理异常，可以将异常信息传递给链中的下一个处理者，或者传递给链外的异常处理器。\n设置异常处理者：在责任链的末端或特定位置设置一个专门用于处理异常的处理者，它负责处理链中其他处理者未能处理的异常。\n向上抛出异常：在某些情况下，如果责任链无法处理异常，可以选择将异常向上抛出，由客户端代码来处理。\n客户端异常处理：客户端代码应该准备好处理可能从责任链抛出的异常，这可能包括为用户提供错误信息或执行其他恢复操作。\n使用模板方法模式：可以使用模板方法模式在基类中定义责任链的处理流程，并在适当的时机处理异常，这样具体处理者只需要关注业务逻辑。\n异常日志记录：确保所有捕获的异常都被记录在日志中，以便于问题追踪和系统监控。\n异常透明性：在设计责任链时，应该明确哪些异常是处理者必须处理的，哪些是可以传递的，这有助于减少异常处理的混乱。\n资源清理：在捕获异常后，确保进行适当的资源清理工作，以防止资源泄漏。\n以下是一个简单的C++代码示例，展示了如何在责任链模式中处理异常：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;iostream\u0026gt; #include \u0026lt;exception\u0026gt; #include \u0026lt;memory\u0026gt; // 处理者接口 class Handler { public: virtual ~Handler() {} virtual void HandleRequest(Request\u0026amp; request) = 0; virtual void SetSuccessor(std::shared_ptr\u0026lt;Handler\u0026gt; successor) = 0; virtual std::shared_ptr\u0026lt;Handler\u0026gt; GetSuccessor() = 0; }; // 具体处理者 class ConcreteHandler : public Handler { private: std::shared_ptr\u0026lt;Handler\u0026gt; successor; void HandleException(const std::exception\u0026amp; e) { // 异常处理逻辑，例如日志记录 std::cerr \u0026lt;\u0026lt; \u0026#34;Exception caught: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } protected: void ProcessRequest(Request\u0026amp; request) { try { // 业务处理逻辑 // ... } catch (const std::exception\u0026amp; e) { HandleException(e); // 可以选择将异常传递给下一个处理者 if (successor) { successor-\u0026gt;HandleRequest(request); } } } public: void HandleRequest(Request\u0026amp; request) override { ProcessRequest(request); } void SetSuccessor(std::shared_ptr\u0026lt;Handler\u0026gt; successor) override { this-\u0026gt;successor = successor; } std::shared_ptr\u0026lt;Handler\u0026gt; GetSuccessor() override { return successor; } }; // 请求类 class Request { // 请求数据 }; // 客户端 int main() { auto handlerA = std::make_shared\u0026lt;ConcreteHandler\u0026gt;(); auto handlerB = std::make_shared\u0026lt;ConcreteHandler\u0026gt;(); handlerA-\u0026gt;SetSuccessor(handlerB); Request request; // 发送请求可能会抛出异常 try { handlerA-\u0026gt;HandleRequest(request); } catch (const std::exception\u0026amp; e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Exception in client: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; // 客户端可以执行额外的异常处理逻辑 } return 0; } 在这个示例中，ConcreteHandler 类在处理请求时可能会抛出异常。在ProcessRequest方法中，我们使用try-catch块来捕获异常，并调用HandleException方法来处理异常。如果存在后继者，我们可以将异常传递给链中的下一个处理者。在客户端代码中，我们也准备了一个try-catch块来捕获可能从责任链抛出的异常。\n通过这种方式，责任链模式中的异常可以被适当地捕获和处理，同时保证了系统的健壮性和稳定性。\n8.在设计责任链时，如何确保异常处理的透明性和一致性？ 在设计责任链时，确保异常处理的透明性和一致性可以通过以下方法实现：\n统一异常处理策略：定义一个统一的异常处理接口或抽象类，确保所有处理器都遵循相同的异常处理规则。这可以通过在处理器接口中定义一个异常处理方法来实现，例如 handleException(Exception e)。\n异常捕获与传播：在每个处理器中，使用 try-catch 块来捕获可能发生的异常，并根据需要处理或将异常传递给链中的下一个处理器。如果当前处理器无法处理异常，应确保异常能够透明地传递到链中的下一个处理器。\n日志记录：在异常处理方法中添加日志记录，记录异常的发生、处理器的名称和异常信息。这有助于调试和监控责任链中的异常情况。\n异常封装：如果需要对异常进行额外的处理或转换，可以在处理器中封装异常，然后继续沿着责任链传递或返回给客户端。\n链末端的异常处理：在责任链的末端设置一个默认的异常处理器，用于处理链中未被捕获的异常。这可以确保所有异常都能得到妥善处理。\n客户端透明性：客户端发送请求时，不需要知道责任链中的具体异常处理逻辑。处理器链应隐藏异常处理的细节，只向客户端返回最终的处理结果。\n使用模板方法模式：可以使用模板方法模式在基类中定义责任链的处理流程，包括异常处理的模板方法，具体处理器只需实现具体的业务逻辑。\n异常处理的一致性：确保所有处理器使用相同的异常处理策略，例如使用相同的日志格式、异常处理流程和错误代码。\n测试和验证：对责任链中的异常处理机制进行充分的测试，包括单元测试和集成测试，确保在各种异常情况下都能正常工作。\n通过这些方法，可以确保责任链中的异常处理既透明又一致，从而提高系统的健壮性和可维护性。\n9.在设计异常处理策略时，有哪些常见的错误或者陷阱我需要避免？ 在设计异常处理策略时，确实存在一些常见的错误和陷阱，以下是你应该避免的几点：\n捕获所有异常：\n避免使用一个通用的 catch 块来捕获所有类型的异常。这样做会掩盖错误的本质，使得调试变得困难，并且可能会隐藏一些不应该被忽略的错误。 忽略异常：\n不要忽略或不处理捕获到的异常。如果一个异常被捕获，应该采取适当的措施，如记录日志、清理资源或向上层抛出更具体的异常。 过度使用异常：\n异常应该用于处理非正常的情况，而不是正常的程序流程控制。不要使用异常来代替正常的程序逻辑，如使用异常来控制循环或条件分支。 不恰当的异常类型：\n抛出的异常应该是合适的类型，能够准确描述错误情况。避免抛出过于通用的异常，如 Exception 或 Throwable，而应该使用更具体的异常类型。 不清晰的错误信息：\n当抛出异常时，应该提供清晰和详细的错误信息，这有助于调试和错误追踪。避免抛出空的或含糊不清的异常信息。 资源泄露：\n在异常处理中，确保所有分配的资源（如文件句柄、数据库连接、网络连接等）在发生异常时都能被正确释放，避免资源泄露。 不恢复状态：\n在捕获异常后，应该尽可能恢复系统到一个安全和一致的状态。例如，在数据库操作中，如果发生异常，应该确保事务被回滚。 不记录异常：\n对于捕获的异常，应该记录足够的信息，包括异常类型、堆栈跟踪和可能的错误上下文。这对于事后分析和问题解决非常重要。 不进行异常的适当转换：\n当捕获一个异常并需要抛出另一个异常时，应该适当地转换异常，而不是直接抛出原始异常，这样可以避免暴露实现细节。 不测试异常处理代码：\n异常处理代码应该被包含在测试中。确保你的异常处理逻辑能够正确处理预期的异常情况。 不一致的异常处理：\n在整个应用程序中，应该保持一致的异常处理策略。这包括异常的捕获、处理和抛出方式。 不处理外部库的异常：\n当使用外部库或框架时，应该了解它们可能抛出的异常，并在应用程序中适当地处理这些异常。 通过避免这些常见的错误和陷阱，你可以设计出一个健壮且有效的异常处理策略，提高应用程序的稳定性和可维护性。\n10.在编写异常处理代码时，有哪些最佳实践可以遵循？ 在编写异常处理代码时，遵循以下最佳实践可以帮助你更好地管理异常，确保代码的健壮性和可维护性：\n精确捕获异常：\n尽可能捕获具体的异常类型，而不是通用的 Exception 类。这有助于针对不同类型的异常采取适当的处理措施。 避免空的 catch 块：\n不要仅仅捕获异常而不做任何处理。如果没有必要处理特定的异常，不如不捕获它，让上层代码或默认的异常处理器来处理。 使用finally块或try-with-resources语句：\n确保在 finally 块中释放资源，或者在Java 7及以上版本中使用try-with-resources语句自动管理资源。 不要在finally块中忽略异常：\n在 finally 块中，不要忽略或吞没异常。如果必须在 finally 块中抛出异常，确保它不是由方法调用产生的新异常，否则会覆盖原始异常。 提供有用的错误信息：\n当抛出异常时，提供清晰和详细的错误消息。如果可能，包括错误代码、用户提示信息和可能的解决方案。 不要使用异常进行流程控制：\n异常应该用于处理非正常情况，而不是正常的程序流程控制。不要使用异常来代替if-else语句。 记录异常：\n在捕获异常时，记录足够的信息，包括异常类型、堆栈跟踪和上下文信息，以便于调试和监控。 恢复或回滚状态：\n在捕获异常后，尽可能恢复系统到一个安全和一致的状态，或者回滚到操作前的状态。 封装和转换异常：\n当捕获一个异常并需要抛出另一个异常时，封装原始异常的信息，或者转换为更具体的异常类型。 测试异常处理代码：\n确保对异常处理代码进行充分的测试，包括单元测试和集成测试，以验证异常处理逻辑的正确性。 保持异常处理的一致性：\n在整个应用程序中，保持异常处理策略的一致性，包括异常的捕获、处理和抛出方式。 处理第三方库的异常：\n了解并妥善处理第三方库可能抛出的异常，确保它们不会破坏应用程序的稳定性。 避免异常链中的循环引用：\n在封装或转换异常时，避免创建循环引用，这可能会导致内存泄露。 使用自定义异常：\n为特定的错误条件创建自定义异常类，这样可以提供更清晰的错误处理逻辑和更好的API设计。 考虑异常的可见性：\n仅向可能需要知道异常发生的代码层公开异常。例如，不要在API的公共方法签名中抛出实现细节的异常。 通过遵循这些最佳实践，你可以确保异常处理代码既有效又高效，同时提高应用程序的整体质量和用户体验。\n11.在进行错误处理机制的测试时，有哪些常见的测试场景和测试方法？ 在进行错误处理机制的测试时，以下是一些常见的测试场景和测试方法：\n测试环境设置：根据软件测试技术设置测试环境，确保测试过程能够顺利进行。这包括计划测试并确保被测试系统包含较少的重要数据，因为测试期间可能会出现系统崩溃问题 。\n生成测试用例：创建可能引发错误的不同测试用例。例如，如果软件操作在分数上，则将分数的分母设置为零。测试用例的生成与开发团队有关，因为不了解内部代码就无法设计测试用例 。\n执行测试用例：在生成测试用例后，开始实际的测试过程。这包括运行程序并使用生成的测试用例。\n结果和分析：执行测试用例后，分析其结果。包括检查生成测试用例的预期输出的不一致性。程序可能会进入无限循环，导致软件失败 。\n重新测试：如果测试失败，则在分析后再次执行所有上述步骤来测试系统。它还包括使用最近生成的新测试用例进行系统测试 。\n测试异常捕获：确保在每个处理器中使用 try-catch 块来捕获可能发生的异常，并根据需要处理或将异常传递给链中的下一个处理器。\n测试资源清理：在捕获异常后，确保进行适当的资源清理工作，以防止资源泄漏。\n测试异常链：在封装或转换异常时，确保不会创建循环引用，这可能会导致内存泄露。\n测试日志记录：确保在捕获异常时记录足够的信息，包括异常类型、堆栈跟踪和上下文信息，以便于调试和监控。\n测试客户端错误处理：客户端代码应该准备好处理可能从责任链抛出的异常，这可能包括为用户提供错误信息或执行其他恢复操作。\n测试异常处理的透明性和一致性：确保所有处理器使用相同的异常处理策略，例如使用相同的日志格式、异常处理流程和错误代码。\n测试自定义异常：为特定的错误条件创建自定义异常类，这样可以提供更清晰的错误处理逻辑和更好的API设计。\n通过这些测试场景和方法，可以确保错误处理机制在各种异常情况下都能正常工作，提高应用程序的稳定性和可靠性。\n12.在测试错误处理机制时，如何确保测试用例的覆盖面足够全面？ 确保测试错误处理机制时测试用例的覆盖面足够全面，可以遵循以下最佳实践：\n理解错误处理逻辑：\n在编写测试用例之前，彻底理解应用程序的错误处理逻辑，包括可能抛出的异常类型、错误处理路径、资源清理逻辑等。 边界值分析：\n设计测试用例以检查边界条件，这些往往是错误和异常的常见来源。 等价类划分：\n将输入数据划分为有效的和无效的等价类，并为每个等价类设计测试用例。 异常场景覆盖：\n识别所有可能的异常场景，并为每种场景设计测试用例，包括但不限于网络故障、数据格式错误、资源不足、权限问题等。 使用自动化工具：\n使用自动化测试工具来生成测试用例，这些工具可以帮助识别代码中未被测试覆盖的部分。 集成测试：\n进行集成测试以确保组件间的错误处理逻辑能够协同工作。 压力测试和负载测试：\n通过压力测试和负载测试来模拟系统在高负载下的错误处理能力。 负测试：\n特别设计测试用例来验证系统对错误输入的处理能力，例如非法参数、异常数据类型等。 异常链测试：\n测试异常链，即一个异常导致另一个异常的情况，确保系统能够正确处理异常链。 代码覆盖工具：\n使用代码覆盖工具来检查测试用例是否覆盖了所有的错误处理代码路径。 模拟和桩：\n使用模拟对象和桩来模拟外部依赖项，并测试错误处理逻辑。 持续集成：\n在持续集成（CI）流程中包含错误处理测试，确保每次代码提交都经过测试。 探索性测试：\n结合探索性测试来发现未被自动化测试覆盖的错误处理场景。 用户反馈：\n利用用户反馈来发现实际使用中的错误处理问题，并根据这些反馈设计测试用例。 回归测试：\n在每次修改错误处理逻辑后进行回归测试，确保修改没有引入新的问题。 文档和注释：\n检查错误处理代码的文档和注释，确保测试用例覆盖了所有文档化的错误处理逻辑。 通过上述方法，可以确保测试用例覆盖各种可能的错误情况，从而提高错误处理机制的健壮性和可靠性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-chain-of-responsibility-pattern/","title":"design pattern Chain of Responsibility Pattern"},{"content":"设计模式-命令模式-Command Pattern [TOC]\nOverview 命令模式（Command Pattern）是一种行为设计模式 它将一个请求封装为一个对象，从而允许用户使用不同的请求、队列或日志请求来参数化其他对象 命令模式也支持可撤销的操作 1.命令模式（Command Pattern） 命令模式（Command Pattern）是一种行为设计模式，它将一个请求封装为一个对象，从而允许用户使用不同的请求、队列或日志请求来参数化其他对象。命令模式也支持可撤销的操作。它通常包含以下角色：\nCommand（命令接口）：\n定义命令的接口，声明执行操作的方法。 ConcreteCommand（具体命令）：\n实现命令接口，对应于具体的行为和接收者的绑定。 Client（客户端）：\n创建具体的命令对象，并设置其接收者。 Invoker（调用者）：\n要求命令对象执行请求。 Receiver（接收者）：\n知道如何实施与执行一个请求相关的操作。 命令模式的主要优点包括：\n解耦：命令模式将发起操作的对象（客户端）与执行操作的对象（接收者）解耦。 扩展性：可以较容易地新增Command类来扩展新的命令，而无需修改已有代码。 复合命令：可以将多个命令组织成复合命令（如宏命令）。 支持撤销：可以实现命令的撤销和重做功能。 命令模式的典型应用场景包括：\n宏命令：将一系列命令组合成一个宏命令。 按钮和菜单项：在GUI应用程序中，按钮和菜单项的点击事件可以封装为命令对象。 事务管理：在需要支持事务撤销和重做的系统中，命令模式可以捕获所有必要的信息来实现这些功能。 以下是一个简单的C++实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; // The Command interface class Command { public: virtual ~Command() {} virtual void Execute() = 0; virtual void Undo() = 0; }; // A ConcreteCommand class Light { public: void On() { std::cout \u0026lt;\u0026lt; \u0026#34;Light is on\\n\u0026#34;; } void Off() { std::cout \u0026lt;\u0026lt; \u0026#34;Light is off\\n\u0026#34;; } }; class SwitchOnCommand : public Command { private: Light* light; public: SwitchOnCommand(Light* light) { this-\u0026gt;light = light; } void Execute() override { light-\u0026gt;On(); } void Undo() override { light-\u0026gt;Off(); } }; class SwitchOffCommand : public Command { private: Light* light; public: SwitchOffCommand(Light* light) { this-\u0026gt;light = light; } void Execute() override { light-\u0026gt;Off(); } void Undo() override { light-\u0026gt;On(); } }; // The Invoker class RemoteControl { private: std::vector\u0026lt;std::shared_ptr\u0026lt;Command\u0026gt;\u0026gt; commandHistory; public: void StoreAndExecute(Command* command) { command-\u0026gt;Execute(); commandHistory.push_back(std::shared_ptr\u0026lt;Command\u0026gt;(command)); } void Undo() { if (!commandHistory.empty()) { commandHistory.back()-\u0026gt;Undo(); commandHistory.pop_back(); } } }; int main() { Light* light = new Light(); RemoteControl* remote = new RemoteControl(); std::shared_ptr\u0026lt;Command\u0026gt; switchOn = std::make_shared\u0026lt;SwitchOnCommand\u0026gt;(light); std::shared_ptr\u0026lt;Command\u0026gt; switchOff = std::make_shared\u0026lt;SwitchOffCommand\u0026gt;(light); remote-\u0026gt;StoreAndExecute(switchOn.get()); remote-\u0026gt;StoreAndExecute(switchOff.get()); remote-\u0026gt;Undo(); remote-\u0026gt;Undo(); delete light; delete remote; return 0; } 在这个例子中，Light 是接收者，SwitchOnCommand 和 SwitchOffCommand 是具体命令，RemoteControl 是调用者。客户端创建了开关灯的命令，并由遥控器执行。同时，遥控器还记录了命令的历史，允许撤销操作。\n2.命令模式优缺点 优点 单一职责原则。 你可以解耦触发和执行操作的类。 开闭原则。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。 你可以实现撤销和恢复功能。 你可以实现操作的延迟执行。 你可以将一组简单命令组合成一个复杂命令。 缺点 代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。 3.命令模式在实际开发中有哪些常见的应用场景？ 命令模式在实际开发中的应用场景非常广泛，它可以帮助将请求发送者和接收者解耦，同时提供额外的功能，如日志记录、事务处理和支持撤销操作。以下是一些常见的应用场景：\n图形用户界面（GUI）：\n在GUI应用程序中，命令模式可以用来封装用户的动作，如点击按钮、选择菜单项等。每个动作都可以通过一个命令对象来表示，这些命令对象可以被触发器（如按钮）调用。 事务处理系统：\n在需要支持事务撤销和重做的系统中，命令模式可以捕获执行操作所需的所有信息，允许系统在需要时回滚到之前的状态。 宏命令：\n可以将一系列命令组合成一个宏命令，以便一次性执行多个操作。这在文本编辑器、图形编辑器和其他需要宏功能的应用程序中非常有用。 网络应用程序：\n在客户端-服务器架构中，命令模式可以用来封装客户端请求，将请求序列化为命令对象，然后发送到服务器端执行。 游戏开发：\n在游戏中，玩家的每个动作（如移动、跳跃、攻击）都可以被视为一个命令。命令模式可以用来管理和调度这些动作。 定时任务和计划任务：\n命令模式可以用来封装定时任务或计划任务的操作，允许系统在特定时间执行这些任务。 硬件控制系统：\n在嵌入式系统或智能家居系统中，命令模式可以用来控制硬件设备，如开关灯、调节温度等。 权限控制系统：\n在需要细粒度权限控制的系统中，命令模式可以用来封装权限检查逻辑，确保只有具备相应权限的用户才能执行特定操作。 数据库操作：\n在数据库应用程序中，命令模式可以用来封装SQL命令或存储过程调用，使得数据库操作更加灵活和可管理。 设计模式组合：\n命令模式可以与其他设计模式结合使用，如组合模式、策略模式等，以实现更复杂的功能。 远程过程调用（RPC）：\n在RPC系统中，命令模式可以用来封装远程调用的请求，允许客户端像调用本地方法一样调用远程服务。 命令行工具：\n在命令行工具中，命令模式可以用来解析和执行用户输入的命令。 通过这些应用场景，命令模式提供了一种灵活和可扩展的方式来封装和调度操作，使得代码更加清晰和易于维护。\n4.如何用命令模式实现一个撤销功能？ 实现撤销功能是命令模式的一个典型应用。撤销功能允许用户回退到之前的状态，这在许多应用程序中都非常有用，如文本编辑器、图形编辑器和游戏等。以下是使用命令模式实现撤销功能的步骤：\n定义命令接口： 创建一个命令接口，它包含执行操作的方法（如 Execute）和撤销操作的方法（如 Undo）。\n1 2 3 4 5 6 class Command { public: virtual ~Command() {} virtual void Execute() = 0; virtual void Undo() = 0; }; 创建具体命令： 为每个可撤销的操作创建具体的命令类，实现命令接口。这些类将包含执行操作和撤销操作的逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class DrawCommand : public Command { private: Canvas* canvas; std::vector\u0026lt;Point\u0026gt; points; // 假设是绘制的线条或形状的点集 public: DrawCommand(Canvas* canvas, const std::vector\u0026lt;Point\u0026gt;\u0026amp; points) : canvas(canvas), points(points) {} void Execute() override { canvas-\u0026gt;Draw(points); } void Undo() override { canvas-\u0026gt;Erase(points); } }; 创建接收者： 创建一个接收者类，它知道如何执行与请求相关的操作。在上面的例子中，Canvas 类是接收者，它知道如何绘制和擦除图形。\n1 2 3 4 5 6 7 8 9 10 class Canvas { public: void Draw(const std::vector\u0026lt;Point\u0026gt;\u0026amp; points) { // 绘制图形的逻辑 } void Erase(const std::vector\u0026lt;Point\u0026gt;\u0026amp; points) { // 擦除图形的逻辑 } }; 创建调用者： 创建一个调用者类，它负责执行命令。调用者维护一个命令的历史记录，以便可以执行撤销操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class CommandInvoker { private: std::vector\u0026lt;Command*\u0026gt; commandHistory; public: void StoreAndExecute(Command* command) { command-\u0026gt;Execute(); commandHistory.push_back(command); } void Undo() { if (!commandHistory.empty()) { Command* command = commandHistory.back(); command-\u0026gt;Undo(); commandHistory.pop_back(); } } }; 客户端代码： 在客户端代码中，创建命令对象并将其传递给调用者。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { Canvas canvas; CommandInvoker invoker; // 创建并执行命令 Command* drawCmd = new DrawCommand(\u0026amp;canvas, { /* 点集 */ }); invoker.StoreAndExecute(drawCmd); // 撤销命令 invoker.Undo(); // 清理 delete drawCmd; return 0; } 在这个例子中，DrawCommand 是一个具体命令，它知道如何让 Canvas 接收者执行绘制操作。当用户想要撤销操作时，CommandInvoker 调用命令的 Undo 方法，命令对象则调用 Canvas 的 Erase 方法来擦除之前的绘制。\n通过这种方式，命令模式不仅将请求的发起者和执行者解耦，而且还支持撤销操作，使得用户可以回退到之前的状态。这种模式还可以很容易地扩展，以支持重做（redo）操作，只需在调用者中添加一个向前的命令历史记录即可。\n5.如何为命令模式中的命令接口添加参数传递功能？ 在命令模式中，为了向命令接口添加参数传递功能，可以在命令接口中定义一个或多个参数。这些参数可以在命令对象被创建时传递，并在执行操作时使用。以下是如何实现这一点的步骤：\n修改命令接口： 在命令接口中添加一个或多个参数，这些参数将用于执行命令。\n1 2 3 4 5 6 class Command { public: virtual ~Command() {} virtual void Execute(const std::string\u0026amp; param) = 0; virtual void Undo(const std::string\u0026amp; param) = 0; }; 创建具体命令： 在具体命令类中，实现命令接口，并在 Execute 和 Undo 方法中使用传递的参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class OpenFileCommand : public Command { private: FileManager* fileManager; std::string fileName; public: OpenFileCommand(FileManager* manager, const std::string\u0026amp; name) : fileManager(manager), fileName(name) {} void Execute(const std::string\u0026amp; param) override { fileManager-\u0026gt;OpenFile(fileName, param); } void Undo(const std::string\u0026amp; param) override { fileManager-\u0026gt;CloseFile(fileName, param); } }; 创建接收者： 接收者类将包含实际执行操作的方法，这些方法可以接受命令对象传递的参数。\n1 2 3 4 5 6 7 8 9 10 class FileManager { public: void OpenFile(const std::string\u0026amp; name, const std::string\u0026amp; mode) { // 打开文件的逻辑 } void CloseFile(const std::string\u0026amp; name, const std::string\u0026amp; mode) { // 关闭文件的逻辑 } }; 创建调用者： 调用者类负责执行命令，并将参数传递给命令对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class CommandInvoker { private: std::vector\u0026lt;Command*\u0026gt; commandHistory; public: void StoreAndExecute(Command* command, const std::string\u0026amp; param) { command-\u0026gt;Execute(param); commandHistory.push_back(command); } void Undo(const std::string\u0026amp; param) { if (!commandHistory.empty()) { Command* command = commandHistory.back(); command-\u0026gt;Undo(param); commandHistory.pop_back(); } } }; 客户端代码： 在客户端代码中，创建命令对象时传递参数，并执行命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { FileManager fileManager; CommandInvoker invoker; // 创建命令对象并传递参数 Command* openCmd = new OpenFileCommand(\u0026amp;fileManager, \u0026#34;example.txt\u0026#34;); invoker.StoreAndExecute(openCmd, \u0026#34;read\u0026#34;); // 假设 \u0026#34;read\u0026#34; 是打开文件的模式 // 撤销命令 invoker.Undo(\u0026#34;read\u0026#34;); // 清理 delete openCmd; return 0; } 在这个例子中，OpenFileCommand 是一个具体命令，它接受一个文件名和打开模式作为参数。当命令被执行时，它将这些参数传递给 FileManager 的 OpenFile 方法。同样，撤销操作也会传递相应的参数。\n通过这种方式，命令模式允许你灵活地向命令对象传递所需的参数，并在执行和撤销操作时使用这些参数。这使得命令模式非常适用于需要传递复杂参数或多个参数的场景。\n6.在GUI应用程序中，如何使用命令模式来提高用户交互的效率？ 在GUI（图形用户界面）应用程序中，命令模式可以提高用户交互的效率，因为它将用户的动作（如点击按钮、选择菜单项等）与执行的动作解耦，并且允许用户撤销和重做操作。以下是如何在GUI应用程序中使用命令模式的步骤：\n定义命令接口： 创建一个命令接口，通常包含 Execute、Undo 和可能的 Redo 方法。\n1 2 3 4 5 6 7 class Command { public: virtual ~Command() {} virtual void Execute() = 0; virtual void Undo() = 0; virtual void Redo() = 0; }; 创建具体命令类： 为每个用户动作创建具体的命令类，实现命令接口。这些命令对象将封装与用户动作相关的所有信息。\n1 2 3 4 5 6 7 8 9 class SaveCommand : public Command { private: TextEditor* editor; public: SaveCommand(TextEditor* editor) : editor(editor) {} void Execute() override { editor-\u0026gt;Save(); } void Undo() override { /* 保存操作通常不需要撤销 */ } void Redo() override { Execute(); } }; 创建接收者类： 接收者类是实际执行命令的类，它提供了命令对象需要调用的方法。\n1 2 3 4 5 6 7 class TextEditor { public: void Save() { // 保存文档的逻辑 } // ... 其他方法 ... }; 创建调用者类： 调用者类负责接收用户输入并执行相应的命令。它通常包含一个命令历史列表，用于撤销和重做操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MenuBar { private: TextEditor* editor; Command* currentCommand; public: MenuBar(TextEditor* editor) : editor(editor), currentCommand(nullptr) {} void ExecuteCommand(Command* command) { if (currentCommand) { currentCommand-\u0026gt;Undo(); } command-\u0026gt;Execute(); currentCommand = command; } void Undo() { if (currentCommand) { currentCommand-\u0026gt;Undo(); currentCommand = nullptr; } } void Redo() { if (currentCommand) { currentCommand-\u0026gt;Redo(); } } }; 将命令对象与用户界面元素绑定： 在GUI中，将命令对象与按钮、菜单项或其他用户界面元素绑定。当用户与这些元素交互时，相应的命令对象被执行。\n1 2 3 // 假设有一个SaveButton和SaveMenuItem SaveButton-\u0026gt;SetCommand(new SaveCommand(editor)); SaveMenuItem-\u0026gt;SetCommand(new SaveCommand(editor)); 实现撤销和重做功能： 在调用者类中实现撤销和重做功能，允许用户回退和重新执行最近的操作。\n1 2 3 4 5 // 在用户点击撤销按钮时调用 MenuBar-\u0026gt;Undo(); // 在用户点击重做按钮时调用 MenuBar-\u0026gt;Redo(); 客户端代码： 在客户端代码中，创建命令对象并将其与用户界面元素关联。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int main() { TextEditor editor; MenuBar menuBar(\u0026amp;editor); // 创建命令对象 Command* saveCmd = new SaveCommand(\u0026amp;editor); // 绑定命令对象到用户界面元素 // ... // 执行命令 menuBar.ExecuteCommand(saveCmd); // 撤销命令 menuBar.Undo(); // 重做命令 menuBar.Redo(); // 清理 delete saveCmd; return 0; } 通过这种方式，命令模式使得GUI应用程序能够以一种灵活和可扩展的方式来处理用户操作，同时提供了撤销和重做功能，从而提高了用户交互的效率和用户体验。\n7.如何确保在GUI应用程序中正确地实现撤销和重做功能？ 要确保在GUI应用程序中正确地实现撤销和重做功能，可以遵循以下步骤和最佳实践：\n使用命令模式：命令模式是实现撤销和重做功能的核心。每个用户操作都封装为一个命令对象，这些对象包含执行操作所需的所有信息以及撤销和重做操作的方法。\n命令接口扩展：扩展命令接口以支持撤销和重做操作。通常，命令接口会包含 Execute、Undo 和 Redo 方法。\n管理命令历史：创建一个命令历史管理器来管理命令历史，包括撤销和重做的命令栈。当执行操作时，将命令推入撤销栈；当撤销操作时，从撤销栈中弹出命令并执行撤销，同时将命令推入重做栈；当重做操作时，从重做栈中弹出命令并执行重做，同时将命令推回撤销栈。\n具体命令实现：为每个具体操作创建命令类，实现命令接口，并在其中实现执行、撤销和重做逻辑。\n调用者和接收者：创建调用者类来执行命令，调用者通常包含一个命令引用。创建接收者类来实际执行与命令相关的操作。\n集成到GUI：将命令对象与GUI元素（如按钮、菜单项等）绑定，确保用户交互能够触发相应的命令执行。\n测试和验证：对撤销和重做功能进行充分的测试，包括单元测试和集成测试，确保在各种操作场景下都能正确地撤销和重做。\n用户界面反馈：在用户界面中提供清晰的反馈，如禁用已撤销的操作的重做按钮，或者在状态栏中显示当前的撤销和重做状态。\n性能优化：考虑到撤销和重做操作可能会对性能产生影响，特别是在处理大量数据时，需要进行性能优化，如使用快照、差异记录等技术。\n异常处理：确保在执行命令时妥善处理异常，避免因异常而导致命令历史不一致。\n通过遵循这些步骤和最佳实践，可以确保在GUI应用程序中实现一个健壮且用户友好的撤销和重做功能。\n8.命令模式在事务处理系统中是如何实现事务的撤销和重做的？ 在事务处理系统中，命令模式可以通过以下方式实现事务的撤销和重做功能：\n定义命令接口：创建一个命令接口，它包含 Execute、Undo 和 Redo 方法。这些方法分别用于执行命令、撤销操作和重做操作。\n创建具体命令类：为系统中的每个操作创建具体的命令类，这些类实现命令接口，并在其中封装接收者对象和执行操作所需的所有信息。\n实现接收者类：接收者类是实际执行命令操作的对象。它包含与命令相关的业务逻辑，并提供必要的方法来执行操作和撤销操作。\n创建调用者类：调用者类负责接收命令对象，并在适当的时候执行命令。它通常包含一个命令历史列表，用于记录执行过的命令，以便进行撤销和重做。\n管理命令历史：使用两个栈（或其他数据结构）来管理命令历史，一个用于撤销操作的命令历史，另一个用于重做操作的命令历史。\n执行命令：当用户执行一个操作时，调用者对象创建一个具体命令对象，并通过调用其 Execute 方法来执行操作。执行后，命令对象被推入撤销栈。\n撤销操作：当需要撤销操作时，调用者对象从撤销栈中弹出最顶层的命令对象，并调用其 Undo 方法。如果撤销成功，该命令对象被推入重做栈。\n重做操作：当需要重做操作时，调用者对象从重做栈中弹出最顶层的命令对象，并调用其 Redo 方法。如果重做成功，该命令对象被推回撤销栈。\n通过这种方式，命令模式不仅支持事务的撤销和重做，还提供了一种灵活的方式来管理和执行系统中的操作。这种模式使得每个操作都可以独立地被控制，同时保持了系统的灵活性和可维护性。\n9.命令模式在多线程环境下如何保证操作的原子性？ 在C++中，命令模式的原子性通常可以通过以下方式来保证：\n互斥锁（Mutex）： 使用互斥锁是确保多线程环境下操作原子性的常用方法。在命令的执行方法中加锁，确保同一时间只有一个线程可以执行该命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;mutex\u0026gt; class Command { protected: std::mutex mtx; // ... 其他成员 ... public: void execute() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); // ... 执行命令 ... } void undo() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); // ... 撤销命令 ... } }; 原子操作： 对于简单的数据类型，可以使用C++11引入的原子类型，如 std::atomic，来保证操作的原子性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;atomic\u0026gt; class CounterCommand { private: std::atomic\u0026lt;int\u0026gt; counter; public: void increment() { counter.fetch_add(1, std::memory_order_relaxed); } void decrement() { counter.fetch_sub(1, std::memory_order_relaxed); } }; 条件变量： 如果命令的执行依赖于某些条件，可以使用条件变量来同步线程。条件变量可以与互斥锁结合使用，以确保在条件满足时，只有一个线程执行命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; class ConditionalCommand { private: std::mutex mtx; std::condition_variable cv; bool condition_met = false; public: void waitForCondition() { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx); cv.wait(lock, [this]{ return condition_met; }); // ... 执行命令 ... } void signalCondition() { { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx); condition_met = true; } cv.notify_one(); } }; 线程局部存储： 如果命令的状态不需要在多个线程间共享，可以使用线程局部存储（thread_local 关键字）来存储每个线程的命令状态，从而避免同步。\n1 2 3 4 5 6 7 8 9 10 11 12 thread_local static int threadSpecificCounter = 0; class ThreadLocalCounterCommand { public: void increment() { ++threadSpecificCounter; } void decrement() { --threadSpecificCounter; } }; 不可变对象： 设计命令和接收者对象为不可变对象，一旦创建就不能被修改。这样可以避免多线程环境下的并发修改问题。\n事务内存（Transactional Memory）： 某些编译器和硬件支持事务内存，这是一种高级的同步机制，可以简化并发编程。在C++中，这通常是通过第三方库实现的。\n避免共享状态： 尽可能设计无状态或只有局部状态的命令对象，避免共享状态，从而减少需要同步的操作。\n使用锁自由的数据结构： 使用专门为并发设计的锁自由数据结构，这些数据结构通常使用复杂的算法来保证线程安全，而不需要传统的锁。\n在实际应用中，应该根据具体的业务需求和性能要求选择合适的策略来保证命令模式在多线程环境下操作的原子性。通常，互斥锁是最直接和常用的方法，但在高并发环境下，可能需要考虑更高效的并发控制机制。\n10.如何使用C++11的原子操作来实现线程安全的命令执行？ 在C++11中，std::atomic 提供了一种机制来确保在多线程环境中对变量的操作是原子的，这意味着操作是不可分割的，不会被其他线程中断。这对于实现线程安全的命令执行至关重要。以下是如何使用 std::atomic 来实现线程安全的命令执行的一些关键点：\n使用原子类型：你可以将需要原子操作的变量声明为 std::atomic 类型。例如，如果你有一个需要原子操作的整数计数器，你可以声明它为 std::atomic\u0026lt;int\u0026gt;。\n1 std::atomic\u0026lt;int\u0026gt; counter(0); 原子操作：std::atomic 提供了一系列原子操作，如 store、load、exchange、compare_exchange_weak 和 compare_exchange_strong 等。这些操作保证了在多线程环境中对变量的访问和修改是原子的。\n1 2 counter.store(10); // 原子地设置counter的值 int value = counter.load(); // 原子地读取counter的值 内存顺序：C++11中的原子操作还允许你指定内存顺序（memory_order），这是对操作可见性的保证。例如，memory_order_seq_cst 提供了顺序一致的内存顺序，而 memory_order_relaxed 则提供了最弱的同步保证。\n1 counter.fetch_add(1, std::memory_order_relaxed); // 原子地增加counter的值 避免数据竞争：通过使用 std::atomic，你可以避免多个线程之间的数据竞争，因为原子操作保证了在任何时候只有一个线程可以修改变量。\n使用原子指针：如果你需要对指针进行原子操作，std::atomic 也支持指针类型。这对于实现线程安全的内存管理非常有用。\n1 std::atomic\u0026lt;int*\u0026gt; ptr; 使用原子操作共享指针：从C++20开始，std::atomic 支持 std::shared_ptr，允许你原子地操作共享指针，这对于管理共享资源的生命周期非常有用。\n1 std::atomic\u0026lt;std::shared_ptr\u0026lt;int\u0026gt;\u0026gt; sharedPtr; 通过上述方法，你可以确保在多线程环境中命令的执行是线程安全的，从而避免由于并发访问导致的数据不一致问题。使用 std::atomic 是C++11提供的一种有效机制，用于在不使用互斥锁的情况下实现线程安全的编程。\n11.能否举例说明命令模式在游戏开发中是如何应用的？ 命令模式（Command Pattern）是一种行为设计模式，它将一个请求封装为一个对象，从而允许用户使用不同的请求、队列或日志请求来参数化其他对象。命令模式也支持可撤销的操作。在游戏开发中，命令模式可以用于实现游戏操作的执行、撤销和重做等功能。下面是一个简单的示例，说明如何在游戏开发中应用命令模式。\n11.1.场景描述 假设我们正在开发一个简单的回合制策略游戏，玩家可以在地图上移动单位。我们希望能够执行、撤销和重做这些移动操作。\n11.2.组件 Command 接口：定义执行操作的方法。 ConcreteCommand 类：实现 Command 接口，对应于具体的行为和接收者。 Client：创建具体的命令对象，并设置其接收者。 Invoker：要求命令对象执行请求。 Receiver：知道如何实施与执行一个请求相关的操作。 11.3.示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 // Command 接口 class Command { public: virtual ~Command() {} virtual void execute() = 0; virtual void undo() = 0; }; // ConcreteCommand 类 class MoveUnitCommand : public Command { private: Unit* unit; int oldPositionX; int oldPositionY; int newPositionX; int newPositionY; public: MoveUnitCommand(Unit* unit, int newX, int newY) : unit(unit), newPositionX(newX), newPositionY(newY) { // 在构造函数中保存旧位置 oldPositionX = unit-\u0026gt;getX(); oldPositionY = unit-\u0026gt;getY(); } void execute() override { // 执行移动操作 unit-\u0026gt;move(newPositionX, newPositionY); } void undo() override { // 撤销移动操作 unit-\u0026gt;move(oldPositionX, oldPositionY); } }; // Receiver 类 class Unit { private: int x, y; public: void move(int newX, int newY) { x = newX; y = newY; // 更新单位在地图上的位置 } int getX() const { return x; } int getY() const { return y; } }; // Invoker 类 class Game { private: std::vector\u0026lt;Command*\u0026gt; commandHistory; public: void executeCommand(Command* command) { command-\u0026gt;execute(); commandHistory.push_back(command); } void undoCommand() { if (!commandHistory.empty()) { Command* command = commandHistory.back(); command-\u0026gt;undo(); commandHistory.pop_back(); } } }; // Client 代码 int main() { Game game; Unit unit; // 创建一个命令对象 Command* moveCommand = new MoveUnitCommand(\u0026amp;unit, 5, 5); // 执行命令 game.executeCommand(moveCommand); // 撤销命令 game.undoCommand(); // 清理 delete moveCommand; return 0; } 11.4.应用解释 Command：定义了 execute 和 undo 方法的接口。 MoveUnitCommand：实现了 Command 接口，记录了一个单位的移动操作。它保存了单位的旧位置和新位置，并提供了执行和撤销操作的方法。 Unit：表示游戏中的一个单位，具有移动的能力。 Game：作为 Invoker，管理命令的执行和撤销。它记录了命令的历史，以便可以撤销操作。 Client：创建具体的命令对象，并将其传递给游戏（Invoker）以执行。 通过使用命令模式，游戏可以灵活地添加新的命令类型，而不需要修改现有的游戏逻辑。同时，它也支持撤销和重做功能，提高了游戏的交互性和用户体验。\n12.如何确保命令模式在游戏开发中的性能和效率？ 在游戏开发中，命令模式可以通过以下方式来确保性能和效率：\n减少对象创建和销毁：通过复用命令对象，减少在游戏循环中频繁创建和销毁对象的性能开销。\n使用对象池：对于命令对象，可以使用对象池（Object Pool）模式来管理，这样可以减少内存分配和回收的开销。\n避免过度的继承：命令模式可能会导致大量的类继承，这在某些情况下可能会影响性能。可以通过使用组合（Composition）来减少继承。\n合理使用命令队列：将命令对象存储在队列中，可以控制命令的执行顺序，同时也可以通过优先级队列来优化命令的执行顺序。\n减少命令执行的复杂度：确保命令对象的 execute 方法尽可能高效，避免在其中执行复杂的计算或者长时间的操作。\n使用多线程和并行处理：对于可以并行处理的命令，可以考虑使用多线程来执行，以提高游戏的响应速度和性能。\n优化命令的存储结构：选择合适的数据结构来存储命令对象，比如使用数组、链表或者哈希表，根据命令的访问模式来优化存储结构。\n减少命令的依赖：尽量减少命令对象之间的依赖关系，这样可以降低系统的复杂度，提高系统的可维护性和性能。\n使用高效的同步机制：在多线程环境下，如果需要同步，可以使用轻量级的同步机制，如 std::atomic 操作，来保证线程安全，而不是使用重量级的锁机制。\n减少命令的撤销/重做操作的开销：如果游戏支持撤销和重做功能，应该优化这些操作的性能，比如通过快照（Snapshot）或者命令日志的方式来实现，而不是每次都重新计算状态。\n通过上述方法，可以在游戏开发中有效地应用命令模式，同时确保游戏的性能和效率。\n13.命令模式在游戏开发中如何与事件驱动架构相结合？ 在游戏开发中，命令模式与事件驱动架构的结合可以通过以下方式实现：\n封装玩家操作为命令：游戏中玩家的每个动作，如移动、攻击、施法等，都可以封装为一个具体的命令对象。这些命令对象在被触发时执行相应的游戏逻辑。\n事件队列管理：游戏服务器可以使用一个事件队列来管理这些命令对象。当玩家发出动作时，客户端将请求转换为命令对象并发送给服务器，服务器将这些命令对象放入事件队列中。\n异步处理：服务器的事件循环可以从事件队列中取出命令对象并异步执行它们，这样可以保证游戏的实时响应性，并且在高并发场景下保持良好的性能。\n事件驱动的反馈：命令执行后可能会触发新的事件，例如，玩家攻击命中后触发伤害事件，这些事件可以进一步驱动游戏逻辑。\n优先级管理：对于关键命令，如战斗操作，可以通过优先级队列确保它们能够快速执行，以保证游戏的流畅性和玩家体验。\n错误处理与调试：在异步和事件驱动的环境中，错误处理和调试可能会变得复杂。可以通过引入集中化的日志管理、分布式跟踪和全面的异常处理机制来帮助识别和解决问题。\n使用成熟框架：为了简化开发，可以使用现有的框架或工具来支持命令模式与事件驱动编程的结合，例如CQRS（Command Query Responsibility Segregation）模式。\n性能优化：在高并发场景中，可以通过多线程或协程来并发处理事件和命令，或者使用分布式消息队列来提高系统的吞吐量。\n监控和调试工具：使用分布式追踪系统、集中化日志管理和性能监控工具来监控系统的性能指标，如事件处理时间和命令执行延迟。\n通过上述方式，命令模式与事件驱动架构的结合可以在游戏开发中实现高效的命令执行、灵活的事件处理和良好的系统性能。这种结合不仅适用于游戏开发，也适用于需要处理复杂业务逻辑和高并发的其他应用场景。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-command-pattern/","title":"design pattern Command Pattern"},{"content":"设计模式-组合模式-Composite Pattern [TOC]\nOverview 组合模式（Composite Pattern）是一种结构型设计模式 它主要用于将对象组合成树形结构，以表示“部分-整体”的层次关系 以表示“部分-整体”的层次关系。这种模式使得用户可以统一地对待单个对象和组合对象 1.组合模式（Composite Pattern） 组合模式（Composite Pattern）是一种结构型设计模式，它主要用于将对象组合成树形结构，以表示“部分-整体”的层次关系。这种模式使得用户可以统一地对待单个对象和组合对象。\n1.1.组合模式的主要角色包括 组件（Component）：\n定义了组合中所有对象的一致操作方式或接口，可以是抽象类或接口。 叶节点（Leaf）：\n表示组合中的末端对象，不包含子节点。 Composite：\n表示组合中的容器对象，可以包含子节点，同时也继承自组件接口。 客户端（Client）：\n使用组件接口与组合结构交互。 1.2.C++实现示例 首先，定义组件接口：\n1 2 3 4 5 6 // Component.h class Component { public: virtual ~Component() {} virtual void Operation() = 0; }; 接着，创建叶节点类：\n1 2 3 4 5 6 7 8 9 // Leaf.h #include \u0026#34;Component.h\u0026#34; class Leaf : public Component { public: void Operation() override { // 叶节点的操作实现 } }; 然后，定义组合类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Composite.h #include \u0026#34;Component.h\u0026#34; #include \u0026lt;vector\u0026gt; class Composite : public Component { private: std::vector\u0026lt;Component*\u0026gt; children; public: void Add(Component* component) { children.push_back(component); } void Remove(Component* component) { children.erase(std::remove(children.begin(), children.end(), component), children.end()); } Component* GetChild(int index) { return children.at(index); } void Operation() override { // 组合对象的操作实现，可能涉及到递归调用子节点的操作 for (Component* child : children) { child-\u0026gt;Operation(); } } }; 最后，客户端代码使用组合模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // main.cpp #include \u0026#34;Leaf.h\u0026#34; #include \u0026#34;Composite.h\u0026#34; int main() { Component* root = new Composite(); Component* leaf1 = new Leaf(); Component* leaf2 = new Leaf(); // 构建组合结构 ((Composite*)root)-\u0026gt;Add(leaf1); ((Composite*)root)-\u0026gt;Add(leaf2); // 客户端使用组合结构 root-\u0026gt;Operation(); // 清理资源 delete root; delete leaf1; delete leaf2; return 0; } 1.3.组合模式的应用场景 文件系统：\n可以使用组合模式模拟文件系统，其中文件和文件夹可以组合成树形结构。 组织结构：\n表示公司的组织结构，员工和部门可以组合成树形结构。 GUI组件：\n在图形界面开发中，可以使用组合模式来构建窗口、菜单、按钮等组件的层次结构。 文档编辑器：\n表示文档编辑器中的文本段落、列表、表格等元素的层次结构。 分布式系统：\n表示分布式系统中的节点和子网络的组合结构。 组合模式提供了一种灵活的方式来管理层次结构中的对象，使得单个对象和组合对象可以统一处理。通过递归地操作子节点，可以在不知道具体对象类型的情况下执行复杂操作。\n2.组合模式优缺点 优点 你可以利用多态和递归机制更方便地使用复杂树结构。 开闭原则。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。 缺点 对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。 3.组合模式应用场景 组合模式（Composite Pattern）在实际开发中有许多应用场景，特别适合用于管理具有层次结构的数据。以下是一些常见的应用实例：\n文件浏览器：\n在文件浏览器中，可以使用组合模式来表示文件系统，其中文件夹和文件可以组合成树状结构。 组织结构管理：\n企业的组织结构通常具有层次性，组合模式可以用来表示员工、团队、部门等元素的层级关系。 权限控制系统：\n在权限控制系统中，可以使用组合模式来管理不同级别的权限，其中权限可以继承自上一级权限。 文档编辑器：\n文档编辑器中的文本段落、标题、列表、表格等可以视为组合模式中的组件，它们可以被统一处理。 图形界面开发：\nGUI开发中的窗口、菜单、按钮、面板等控件可以组合成树状结构，方便管理和操作。 分布式系统设计：\n分布式系统中的节点和子网络可以构成一个层次结构，使用组合模式可以方便地管理这些节点。 报表系统：\n报表系统中的报表项可以组合成复杂的报表结构，如表格、图表、文本等可以作为组合元素。 模型-视图-控制器（MVC）：\n在MVC架构中，视图（View）组件可以采用组合模式来构建，允许有多个层次的视图组件。 工作流引擎：\n工作流中的步骤和流程可以构成一个层次结构，使用组合模式可以灵活地管理和执行工作流。 内容管理系统（CMS）：\nCMS中的页面、文章、媒体等可以组合成树状结构，方便内容的组织和管理。 菜单系统：\n应用程序中的菜单项和子菜单可以构成一个层次结构，使用组合模式可以方便地添加、删除和修改菜单项。 插件架构：\n插件系统中的插件可以具有自己的子插件，形成层次结构，使用组合模式可以方便地管理和扩展插件功能。 电子表格：\n电子表格中的单元格、行、列、工作表等可以视为组合模式中的组件，可以进行统一的操作。 树状数据结构：\n任何需要树状数据结构的场景，如XML/HTML解析、决策树、分类系统等。 组合模式通过将对象组合成树形结构，允许客户端对单个对象和组合对象使用相同的操作，从而简化了客户端代码，并提高了系统的灵活性和可扩展性。\n4.在实现组合模式时，有哪些设计原则或最佳实践需要遵循？ 在实现组合模式时，遵循一些设计原则和最佳实践可以帮助确保代码的清晰性、可维护性和扩展性。以下是一些关键的设计原则和最佳实践：\n保持接口一致性：\n确保叶节点（Leaf）和容器（Composite）对象都实现相同的接口或继承自同一个抽象类。这样，客户端可以统一对待它们。 最小化组件复杂性：\n尽量简化组件的接口，只包含必要的操作。避免在组件接口中引入与组合逻辑无关的方法。 递归设计：\n在容器对象中，对于需要遍历子组件的操作，使用递归来实现。这样可以使客户端代码更加简洁。 避免循环引用：\n在构建组合结构时，注意避免创建循环引用，这可能会导致内存泄漏或其他问题。 考虑线程安全：\n如果组合模式将在多线程环境中使用，确保组合结构的线程安全性，特别是在修改组合结构时。 使用深复制和浅复制：\n根据需要决定是使用深复制还是浅复制来复制组合对象。深复制会复制整个组合结构，而浅复制只复制引用。 管理资源：\n确保正确管理组合对象中的资源，特别是在删除组合对象时，需要递归地释放所有子组件的资源。 定义清晰的添加和删除操作：\n提供清晰的方法来添加和删除子组件，确保组合结构的完整性和一致性。 使用组合模式的适用场景：\n只在确实需要表示部分-整体层次结构时使用组合模式。如果不需要这种层次结构，使用其他模式可能更合适。 避免过度使用组合模式：\n不要仅仅为了使用设计模式而使用组合模式。确保它确实是解决特定问题的最佳选择。 编写单元测试：\n为组合模式的各个组件编写单元测试，确保它们的行为符合预期。 文档和注释：\n为组合模式的接口和实现提供清晰的文档和注释，帮助其他开发者理解和使用。 考虑使用现成的库或框架：\n在某些情况下，可以考虑使用现成的库或框架来实现组合模式，以减少开发工作量。 保持扩展性：\n设计组合模式时，考虑到未来可能的扩展，使得添加新的组件类型或修改现有组件时更加容易。 通过遵循这些设计原则和最佳实践，可以实现一个健壮、灵活且易于维护的组合模式结构。\n5.如何使用组合模式来优化现有的系统架构？ 在实际项目中，组合模式（Composite Pattern）可以用于优化系统架构，特别是在需要处理具有层次结构的数据时。以下是一些应用组合模式来优化现有系统架构的方法：\n树形结构数据管理： 当系统需要处理具有树形结构的数据，如文件系统或组织架构时，组合模式可以简化数据的管理。通过将树中的每个元素视为对象，无论是叶子节点还是分支节点，它们都实现相同的接口，使得遍历和操作树结构变得更加一致和简单 。\nUI组件层次管理： 在图形用户界面（GUI）开发中，可以使用组合模式来管理控件的层次结构。这样，容器控件和单个控件可以统一处理，简化了布局管理和事件处理 。\n中间件和路由系统： 在Web框架或网络应用中，组合模式可以用来设计中间件和路由系统。通过将中间件和路由组织成树形结构，可以灵活地添加和配置中间件，同时保持代码的清晰和可维护性 。\n数据驱动设计： 在数据驱动的设计中，组合模式可以用于构建灵活的数据模型。通过将数据组织成树形结构，可以方便地进行数据的动态加载和修改，从而提高应用程序的可扩展性和灵活性 。\n游戏开发中的组件系统： 在游戏开发中，组合模式可以与组件系统（ECS）结合使用，将游戏对象的行为和数据分离，以实现高效的性能和灵活的扩展 。\n系统集成和扩展： 当需要对现有系统集成新功能或进行扩展时，组合模式可以提供一种灵活的方法来整合新旧系统。通过将新功能作为组合模式中的叶子节点或分支节点添加，可以轻松地扩展系统的功能 。\n文档编辑器： 在文档编辑器中，可以使用组合模式来管理文档的层次结构，如段落、标题、列表等。这样，可以统一地处理文档中的各种元素，无论是单个文本元素还是包含多个子元素的复杂结构 。\n产品目录管理： 在电子商务平台中，产品目录往往具有复杂的层次结构。组合模式可以用于管理这些层次关系，使得添加、删除和查询产品操作更加高效和一致 。\n通过这些方法，组合模式可以帮助开发者构建更加模块化、灵活和易于维护的系统架构。在应用组合模式时，需要注意保持系统的透明性和安全性，同时遵循设计原则，如单一职责原则和开闭原则，以确保系统的可扩展性和可维护性。\n6.组合模式在处理动态添加或删除组合元素时有哪些挑战，如何克服？ 在使用组合模式处理动态添加或删除组合元素时，可能会遇到以下挑战以及相应的解决方案：\n透明性与安全性的平衡： 透明组合模式（所有组件类都有添加和删除方法）可能不安全，因为叶子节点实际上不能包含子节点。安全组合模式通过仅在容器类中实现添加和删除方法来避免这个问题，但这牺牲了一些透明性。\n性能问题： 如果树形结构非常深或宽，递归操作可能会导致性能问题。可以通过优化算法、使用迭代器或缓存结果来提高性能。\n线程安全： 在多线程环境中，动态修改组合结构可能会引发并发问题。确保添加和删除操作是线程安全的，例如通过使用同步机制。\n维护树形结构的完整性： 在添加或删除节点时，需要维护树的层次结构和父子关系。这可能需要在添加或删除操作中进行额外的检查和调整。\n处理复杂约束： 当组合结构中的节点有特定的约束条件时（例如，某些节点不能包含特定类型的子节点），在添加或删除节点时需要进行额外的检查以满足这些约束。\n避免循环引用： 在添加节点时，需要确保不会产生循环引用，这可能会导致内存泄漏或其他问题。可以通过检查新添加的节点是否已经存在于树中来避免这种情况。\n实现灵活性： 组合模式允许客户端代码以统一的方式处理所有类型的节点，但在实现时可能需要更多的设计工作来确保灵活性和可扩展性。\n使用访问者模式： 当需要对组合结构中的元素执行复杂操作时，可以使用访问者模式来分离算法和结构，从而简化客户端代码并提高可维护性。\n使用迭代器模式： 当需要遍历组合结构时，可以使用迭代器模式来提供一种统一的遍历机制，无论组合结构的复杂性如何。\n通过这些策略，可以有效地克服在使用组合模式时遇到的挑战，并确保系统能够在运行时灵活地管理其组件。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-composite-pattern/","title":"design pattern Composite Pattern"},{"content":"设计模式-创建式模式-creational patterns [TOC]\nOverview 1.创建式模式（Creational Patterns） 创建式模式（Creational Patterns）是软件设计模式的一种，主要用于处理对象的创建过程，封装对象的实例化过程，以便更好地控制对象的创建。创建式模式隐藏了对象如何创建、组合和表示的复杂性，而不是直接暴露给客户端代码。以下是五种基本的创建式设计模式：\n单例模式（Singleton Pattern）：\n确保一个类只有一个实例，并提供一个全局访问点。 工厂方法模式（Factory Method Pattern）：\n定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法让类的实例化推迟到子类进行。 抽象工厂模式（Abstract Factory Pattern）：\n创建相关或依赖对象的家族，而不需明确指定具体类。它提供一个接口，用于创建一系列相关或相互依赖的对象，而不需要指定它们具体的类。 生成器模式（Builder Pattern）：\n用于创建一个复杂对象，同时允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。 原型模式（Prototype Pattern）：\n使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 每种创建式模式都有其特定的应用场景和优缺点，以下是它们的一些使用场景：\n单例模式：适用于需要全局只有一个实例的情况，如配置管理器、连接池等。 工厂方法模式：适用于需要根据不同条件创建不同实例的情况，如支付接口的实现。 抽象工厂模式：适用于需要创建产品族的情况，这些产品在结构上相关联，如不同操作系统的GUI组件。 生成器模式：适用于需要构建复杂对象，且对象的构建过程涉及多个步骤的情况，如构建一个包含多个部件的汽车。 原型模式：适用于创建新对象的成本较高，或者对象的创建过程需要高度的灵活性时，如图形界面的复制操作。 选择使用哪种创建式模式，需要根据实际的需求和上下文来决定。创建式模式有助于提高代码的可维护性、可读性和灵活性。\n工厂方法模式 factory_method_mode 抽象工厂模式 abstract_factory 生成器模式 builder_pattern 原型模式 prototype_pattern 单例模式 singleton_pattern 关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-creational-patterns/","title":"design pattern creational patterns"},{"content":"设计模式-装饰模式-decorator_pattern [TOC]\nOverview 装饰模式（Decorator Pattern）是一种结构型设计模式 它允许用户在不修改对象自身的基础上，向一个对象添加新的功能 1.装饰模式（Decorator Pattern） 装饰模式（Decorator Pattern）是一种结构型设计模式，它允许用户在不修改对象自身的基础上，向一个对象添加新的功能。这种模式通过创建一个包装对象，也就是装饰者，来包裹实际对象。装饰者同实际对象有相同的接口，并持有一个指向实际对象的引用，在调用实际对象的方法前后，可以执行额外的功能。\n1.1.装饰模式的主要角色包括 Component（抽象构件）：\n定义了一个接口，描述了可以动态添加的责任。 ConcreteComponent（具体构件）：\n定义了一个具体类，也可以实现抽象构件的角色。 Decorator（抽象装饰者）：\n抽象类，实现与抽象构件相同的接口，并持有一个抽象构件类型的成员变量，用于包装或链接一个构件。 ConcreteDecorator（具体装饰者）：\n具体类，实现抽象装饰者，通过实现接口方法，给构件添加额外的职责。 1.2.C++实现示例 首先，定义抽象构件：\n1 2 3 4 5 6 // Component.h class Component { public: virtual ~Component() {} virtual void Operation() = 0; }; 接着，创建具体构件：\n1 2 3 4 5 6 7 8 9 // ConcreteComponent.h #include \u0026#34;Component.h\u0026#34; class ConcreteComponent : public Component { public: void Operation() override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteComponent Operation\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 然后，定义抽象装饰者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Decorator.h #include \u0026#34;Component.h\u0026#34; class Decorator : public Component { protected: Component* component; public: Decorator(Component* comp) : component(comp) {} ~Decorator() { delete component; } void Operation() override { if (component) { component-\u0026gt;Operation(); } } }; 接下来，创建具体装饰者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // ConcreteDecorator.h #include \u0026#34;Decorator.h\u0026#34; class ConcreteDecorator : public Decorator { public: ConcreteDecorator(Component* comp) : Decorator(comp) {} void Operation() override { Decorator::Operation(); // 调用被装饰者的方法 // 添加额外的行为 std::cout \u0026lt;\u0026lt; \u0026#34;Additional Behavior for ConcreteDecorator\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 最后，客户端代码使用装饰模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // main.cpp #include \u0026#34;ConcreteComponent.h\u0026#34; #include \u0026#34;ConcreteDecorator.h\u0026#34; int main() { Component* component = new ConcreteComponent(); component-\u0026gt;Operation(); Component* decoratedComponent = new ConcreteDecorator(component); decoratedComponent-\u0026gt;Operation(); // 装饰后的行为 delete decoratedComponent; return 0; } 1.3.装饰模式的应用场景 增加职责： 当需要给对象动态地添加职责时，装饰模式提供了一种灵活的解决方案。\n扩展类的功能： 当类的功能需要扩展，但又不想用继承的方式时，可以使用装饰模式。\n动态行为： 如果需要在运行时动态地给对象添加行为，装饰模式可以轻松实现。\n透明性： 装饰模式可以保持对客户端的透明性，即客户端无需知道对象是原始对象还是被装饰过的对象。\n灵活性： 装饰模式可以很容易地通过添加新的装饰者类来扩展系统的功能。\n装饰模式通过使用组合而非继承来扩展对象的功能，这使得系统更加灵活和可扩展。同时，它也遵循了开闭原则，即软件实体应该对扩展开放，对修改关闭。\n2.装饰模式优缺点 优点 你无需创建新子类即可扩展对象的行为。 你可以在运行时添加或删除对象的功能。 你可以用多个装饰封装对象来组合几种行为。 单一职责原则。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。 缺点 在封装器栈中删除特定封装器比较困难。 实现行为不受装饰栈顺序影响的装饰比较困难。 各层的初始化配置代码看上去可能会很糟糕。 3.装饰模式应用场景 装饰模式（Decorator Pattern）在实际开发中的常见应用场景包括但不限于：\nGUI组件功能增强： 在图形用户界面（GUI）编程中，可以为按钮、文本框等组件动态添加如边框、颜色、工具提示等额外功能。\n日志记录和事务处理： 在需要对方法执行进行日志记录或事务处理的场景中，装饰模式可以动态地为方法调用添加日志记录或事务管理功能。\n性能监测： 在应用程序中，可以使用装饰模式为方法添加性能监测功能，以统计方法的执行时间。\n缓存机制： 在需要缓存结果以提高性能的场景中，装饰模式可以为对象添加缓存功能。\n安全性控制： 在需要对资源访问进行权限检查的场景中，装饰模式可以为方法或对象添加安全性控制。\n网络通信： 在网络编程中，装饰模式可以用于添加如压缩、加密、身份验证等网络通信的功能。\n资源管理： 在资源管理场景中，如文件操作或数据库操作，装饰模式可以用于添加资源的打开、关闭以及资源使用监控等功能。\n原型模式的扩展： 与原型模式结合使用，可以创建具有新行为的深拷贝对象。\n实现策略模式的备用方案： 当需要在运行时动态改变对象的行为时，装饰模式可以作为策略模式的替代方案。\n实现开闭原则： 在需要遵循开闭原则（对扩展开放，对修改关闭）的场景中，装饰模式允许在不修改现有代码的基础上扩展功能。\n实现享元模式： 与享元模式结合使用，装饰模式可以用于实现共享对象的特定行为。\n中间件开发： 在开发中间件时，装饰模式可以用于动态地添加或替换中间件组件的功能。\nWeb开发： 在Web开发中，装饰模式可以用于动态地为Web页面元素添加样式、脚本或其他行为。\n游戏开发： 在游戏开发中，装饰模式可以用于为游戏对象添加如动画效果、特殊能力等额外功能。\n装饰模式通过将对象包装在装饰者类中来动态地添加功能，这使得装饰者可以与原始对象无缝集成，同时保持高度的灵活性和可扩展性。\n4.在实际开发中，如何决定何时使用装饰模式而不是其他设计模式？ 在实际开发中，决定何时使用装饰模式（Decorator Pattern）而不是其他设计模式，可以根据以下几个关键点来考虑：\n动态扩展功能：\n如果需要在运行时动态地给对象添加额外的职责或行为，装饰模式是一个合适的选择。 透明性：\n装饰模式可以保持对客户端的透明性，即客户端无需知道对象是原始对象还是被装饰过的对象。如果需要保持接口的一致性，可以考虑使用装饰模式。 灵活性和可扩展性：\n如果系统需要高度的灵活性和可扩展性，装饰模式允许你通过添加新的装饰者类来扩展功能，而不是通过修改现有代码。 避免类爆炸：\n当使用继承来扩展功能时，可能会导致类的数量急剧增加（类爆炸）。装饰模式通过组合来扩展功能，可以减少类的数目。 单一职责原则：\n如果希望遵循单一职责原则，避免在一个类中包含多个功能，可以使用装饰模式将不同的功能分离到不同的装饰者类中。 与继承的比较：\n继承是一种静态的行为扩展方式，而装饰模式提供了一种动态的扩展方式。如果行为扩展是已知的且固定的，继承可能是更好的选择；如果行为扩展是动态的或不确定的，装饰模式更合适。 组合优于继承：\n如果遵循“组合优于继承”的设计原则，装饰模式通过组合来实现功能的扩展，而不是通过继承。 开闭原则：\n如果希望系统对扩展开放，对修改关闭，装饰模式允许在不修改现有代码的基础上扩展功能。 避免多层继承：\n如果使用继承会导致多层继承结构，这可能会使系统难以理解和维护。装饰模式可以避免这种情况，因为它通过组合来实现功能的扩展。 实现策略模式的替代方案：\n当需要在运行时动态改变对象的行为时，装饰模式可以作为策略模式的替代方案。 性能考虑：\n如果性能是一个关键因素，需要考虑装饰模式可能会引入的额外开销。在某些情况下，使用继承或其他模式可能更高效。 团队熟悉度：\n考虑团队对不同设计模式的熟悉度和使用经验，选择团队更熟悉和更易于维护的模式。 在决定使用装饰模式时，需要权衡上述因素，并根据具体的应用场景和设计需求来做出选择。装饰模式特别适合于需要动态、灵活地扩展对象功能的情况。\n5.装饰模式有什么问题？ 装饰模式在实际开发中可能会遇到以下常见问题：\n复杂性增加：\n装饰模式可能会导致系统中存在大量的装饰器类，特别是当有多个层次的装饰时。这可能会使得系统结构变得复杂，难以理解和维护。为了解决这个问题，应该只在确实需要的时候添加装饰器，并且保持装饰器的职责单一。 性能问题：\n装饰模式通过包装对象来添加功能，这可能会导致性能上的开销，尤其是在装饰链很长的情况下。为了减少性能影响，应该优化装饰器的实现，避免不必要的包装，并且在设计时考虑性能。 过度使用：\n如果不加限制地使用装饰模式，可能会导致装饰器类的数量急剧膨胀，这与设计模式的初衷相违背。应该在设计时仔细考虑是否真的需要装饰器来提供额外的功能。 装饰顺序敏感：\n在某些情况下，装饰器的执行顺序可能会影响对象的行为。这可能会导致难以预测的结果。为了解决这个问题，可以通过明确的顺序约定或者在设计时就考虑到执行顺序的影响。 难以管理装饰链：\n在复杂的系统中，维护一个清晰的装饰链可能会很困难。可以通过引入更多的结构化管理或者使用设计模式如工厂模式来创建和管理装饰链。 装饰器的透明性：\n装饰器应该对客户端透明，这意味着客户端代码应该能够在不知道具体装饰器的情况下使用装饰后的对象。如果装饰器的实现不够透明，可能会导致客户端代码需要针对不同的装饰器编写不同的逻辑。 装饰器的复用性：\n装饰器应该具有良好的复用性，以便可以在不同的上下文中重复使用。如果装饰器与特定的组件紧密耦合，可能会降低其复用性。 为了克服这些问题，应该在设计时仔细考虑装饰模式的应用场景，并且在实现时注意保持装饰器的简洁和透明性。同时，也应该考虑到系统的可维护性和性能。在需要动态扩展功能时，装饰模式是一种有效的设计模式，但应该谨慎使用，避免上述问题的出现。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-decorator_pattern/","title":"design pattern decorator_pattern"},{"content":"设计模式-外观模式-Facade Pattern [TOC]\nOverview 外观模式（Facade Pattern）是一种结构型设计模式 它提供了一个统一的接口来访问子系统中的一组接口 外观模式定义了一个高级接口，让子系统更容易使用，同时隐藏了子系统组件之间的复杂性 1.外观模式（Facade Pattern） 外观模式（Facade Pattern）是一种结构型设计模式，它提供了一个统一的接口来访问子系统中的一组接口。外观模式定义了一个高级接口，让子系统更容易使用，同时隐藏了子系统组件之间的复杂性。\n1.1.外观模式的主要角色包括 外观（Facade）：\n提供一个简化的接口，用于访问子系统中的复杂操作。 子系统（Subsystem）：\n一组类或接口，每个类或接口都管理子系统中的一部分功能。 客户端（Client）：\n使用外观来访问子系统的功能，而不是直接与子系统交互。 1.2.C++实现示例 首先，定义子系统接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // SubsystemA.h class SubsystemA { public: void operationA() { std::cout \u0026lt;\u0026lt; \u0026#34;Subsystem A operation\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // SubsystemB.h class SubsystemB { public: void operationB() { std::cout \u0026lt;\u0026lt; \u0026#34;Subsystem B operation\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // SubsystemC.h class SubsystemC { public: void operationC() { std::cout \u0026lt;\u0026lt; \u0026#34;Subsystem C operation\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 然后，定义外观类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Facade.h #include \u0026#34;SubsystemA.h\u0026#34; #include \u0026#34;SubsystemB.h\u0026#34; #include \u0026#34;SubsystemC.h\u0026#34; class Facade { private: SubsystemA* subsystemA; SubsystemB* subsystemB; SubsystemC* subsystemC; public: Facade() : subsystemA(new SubsystemA()), subsystemB(new SubsystemB()), subsystemC(new SubsystemC()) {} ~Facade() { delete subsystemA; delete subsystemB; delete subsystemC; } void operation() { subsystemA-\u0026gt;operationA(); subsystemB-\u0026gt;operationB(); subsystemC-\u0026gt;operationC(); } }; 最后，客户端代码使用外观模式：\n1 2 3 4 5 6 7 8 9 // main.cpp #include \u0026#34;Facade.h\u0026#34; int main() { Facade facade; facade.operation(); return 0; } 1.3.外观模式的应用场景 系统集成：\n当需要将多个子系统集成到一个较大的系统中时，外观模式可以提供一个简单的接口来管理这些子系统。 库的封装：\n当需要提供一个库的简化接口时，外观模式可以隐藏库的复杂性，使得客户端代码更容易使用。 复杂系统的简化：\n当客户端需要与复杂系统交互，但只需要访问系统的一部分功能时，外观模式可以简化客户端的调用。 控制访问：\n当需要控制对子系统的访问，或者需要在子系统操作前后执行额外的逻辑时，外观模式可以提供这样的控制。 外观模式通过提供一个简化的接口，使得客户端代码可以更容易地与复杂的子系统交互，同时隐藏了子系统的实现细节。这有助于提高系统的可维护性和可扩展性。\n2.外观模式优缺点 优点 你可以让自己的代码独立于复杂子系统。 缺点 外观可能成为与程序中所有类都耦合的上帝对象。 3.外观模式在实际项目中如何避免过度设计的问题？ 在实际项目中应用外观模式时，要避免过度设计的问题，可以遵循以下原则和最佳实践：\n关注高层次的设计：在设计初期，专注于系统的高层次结构而不是具体的实现细节。这有助于避免在初期就引入过多的复杂性，从而减少过度设计的风险。\n逐步细化：随着项目的进展，逐步添加更多的细节到类图中。这种方法允许你在更了解需求和上下文的情况下，逐步引入必要的复杂性。\n分离关注点：如果发现某个类承担了太多责任，考虑将其拆分为多个更小、更专注的类。这有助于保持系统的清晰性和可维护性。\n避免过度封装：外观模式应该提供一个简化的接口，但同时也要避免过度封装，以免隐藏过多的细节，导致维护困难。\n适度使用外观模式：并非所有复杂系统都需要外观模式。应根据实际复杂度和维护成本来决定是否应用外观模式。\n利用现代编程语言特性：在C++中，可以利用C++11或更高版本的特性，如智能指针、Lambda表达式等，来简化代码并提高资源管理的安全性。\n持续重构：在开发过程中，持续重构代码以适应新的需求和理解。这有助于避免在项目初期就做出过多的设计决策。\n与客户沟通：与客户或利益相关者进行充分的沟通，确保对需求有准确的理解，避免基于错误假设的设计。\n编写可测试的代码：确保外观模式的实现不会妨碍代码的测试性。这有助于在不影响系统其他部分的情况下，对外观类进行有效的测试。\n遵循设计模式的初衷：设计模式的目的是为了提高代码质量，包括可读性、可扩展性和可维护性。在应用外观模式时，始终考虑这些目标。\n通过上述方法，可以在保持系统简洁性的同时，有效地利用外观模式来简化复杂系统的接口。记住，设计模式是工具，应该根据项目的具体需求和上下文来合理应用。\n4.在实际开发中，如何平衡设计模式的使用和项目的实际需求？ 在实际开发中平衡设计模式的使用和项目的实际需求，可以通过以下方法来实现：\n理解需求：\n在应用任何设计模式之前，首先要确保对项目需求有深入的理解。这包括与客户沟通，了解他们的期望和业务目标。 识别问题：\n确定项目中遇到的具体问题或痛点，这些问题可能是设计模式可以解决的。 选择适当的模式：\n根据识别的问题选择最合适的设计模式。选择那些能够提供明确解决方案的模式，而不是仅仅因为它们看起来很酷。 避免过度设计：\n避免为了使用设计模式而使用。如果一个简单的解决方案已经足够，就不要引入复杂的设计模式。 遵循SOLID原则：\n确保设计遵循SOLID原则，这有助于创建可维护、可扩展和灵活的代码。 保持简单：\n遵循KISS（Keep It Simple, Stupid）原则，尽量保持代码简单直接。 迭代开发：\n采用迭代开发的方法，逐步引入设计模式，每次迭代都关注反馈和改进。 重构：\n在项目进展中不断重构代码，以适应新的需求或改进设计。 性能考虑：\n在选择设计模式时，考虑它们对性能的影响。确保不会引入不必要的性能开销。 文档和沟通：\n记录设计决策，并与团队成员沟通。确保每个人都理解为什么选择特定的设计模式。 原型和实验：\n在实际应用之前，通过原型或实验来测试设计模式的效果。 持续学习和评估：\n持续学习新的设计模式和最佳实践，并定期评估现有设计的有效性。 适应变化：\n软件需求经常变化，设计应该能够适应这些变化。选择那些能够灵活应对变化的设计模式。 权衡利弊：\n对于每个设计模式，都要权衡其带来的长期利益与短期成本。 用户和场景驱动：\n设计应该由用户需求和特定场景驱动，而不是由技术驱动。 通过这些方法，可以确保设计模式的使用是出于解决实际问题的需要，而不是过度设计。这样可以提高项目的成功率，同时保持代码的清晰性和可维护性。\n5.除了C++，外观模式还可以用在哪些编程语言中？ 外观模式（Facade Pattern）是一种常用的结构型设计模式，它为一组复杂的子系统提供一个简化的统一接口。这种模式隐藏了子系统的细节，使得客户端代码可以通过一个简单的接口来访问子系统的功能，从而降低了客户端与复杂子系统之间的耦合度。\n外观模式可以应用于多种编程语言中，不限于C++。它可以在任何支持类和对象的编程语言中实现，例如Java、Python、Ruby、Rust、Swift、TypeScript等。在这些语言中，外观模式的实现方式可能会有所不同，但核心思想是一致的：提供一个高级的接口，简化对子系统的操作。\n在实际项目中，外观模式可以帮助我们管理复杂的系统架构，使得客户端代码更加简洁和易于维护。例如，在Java微服务项目中，外观模式可以用于代码分层，其中Facade作为对外暴露API接口的一层，Controller作为API的实现类，Service为核心业务服务。在Spring框架中，JdbcTemplate类就是一个典型的外观模式应用，它封装了JDBC相关的操作，简化了数据库操作的复杂性。\n外观模式的优势包括简化了客户端与子系统的交互、降低了系统各部分之间的耦合度、提高了系统的可维护性。然而，它也存在一些缺点，如可能会隐藏子系统内部的重要行为，使得客户端无法访问这些行为；如果子系统发生改变，可能需要修改外观类，这可能会影响到客户端代码。\n在应用外观模式时，应该根据项目的具体需求和上下文来决定是否使用，以及如何设计外观类。外观模式是一种强大的工具，可以帮助我们构建更加清晰和易于管理的系统架构。\n6.如何判断一个项目是否适合使用外观模式？ 判断一个项目是否适合使用外观模式，可以考虑以下几个关键因素：\n子系统的复杂性：\n如果项目中有一个复杂的子系统，且这个子系统由多个不同的类或模块组成，这些类或模块之间存在复杂的交互，那么使用外观模式可以提供一个简化的接口。 客户端与子系统的交互：\n如果客户端需要与子系统的多个组件进行交互，而这些交互可以通过一个统一的接口来简化，那么外观模式是一个合适的选择。 需要简化的接口：\n当需要为外部客户端提供一个简化的接口，同时隐藏子系统的复杂性时，可以考虑使用外观模式。 客户端与子系统的耦合：\n如果希望减少客户端与子系统之间的直接依赖关系，降低耦合度，外观模式可以帮助封装子系统的细节。 子系统的稳定性：\n如果子系统相对稳定，不经常变化，而客户端代码需要与这个稳定的子系统交互，外观模式可以提供一层保护，使得子系统的变更不会直接影响到客户端。 系统架构的层次：\n在多层架构的系统中，外观模式可以用来定义每一层的入口点，简化层与层之间的调用。 性能考虑：\n如果子系统的性能不是关键问题，或者外观模式引入的额外间接层不会对性能产生负面影响，那么可以考虑使用外观模式。 开闭原则：\n如果希望子系统的变更不会导致客户端代码的修改，从而遵循开闭原则（对扩展开放，对修改关闭），外观模式可以作为一个中间层来实现这一点。 可维护性和可扩展性：\n如果项目需要易于维护和扩展，外观模式可以通过提供清晰的接口来提高系统的可维护性。 团队的熟悉度：\n如果团队成员对外观模式比较熟悉，并且能够正确地应用它，那么使用外观模式会更加顺利。 项目规模和预期变化：\n对于大型项目或预期会频繁变化的项目，外观模式可以帮助管理复杂性，并为未来的变更提供灵活性。 现有代码的重构：\n如果现有代码库中存在复杂的交互和紧密耦合的问题，外观模式可以用来重构代码，提高代码的清晰度和可维护性。 在考虑使用外观模式时，应该权衡上述因素，并结合项目的具体需求和上下文来决定。外观模式是一个强大的工具，可以帮助简化复杂系统的接口，但也应该谨慎使用，以避免引入不必要的抽象层次。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-facade-pattern/","title":"design pattern Facade Pattern"},{"content":"设计模式-工厂方法模式 [TOC]\nOverview 工厂方法模式是一种创建型设计模式 子类继承，重载，多态基类 具体工厂生产具体产品 看起来内容挺多的，要耐心啊！ 工厂方法模式（Factory Method Pattern）是一种创建型设计模式，用于将对象的创建过程封装在一个函数或方法中，从而将对象的创建和使用分离。这种模式允许系统在不修改已有代码的情况下引入新的产品。\n1.工厂方法模式简介 1.1. 工厂方法模式的关键特点 封装性：对象的创建过程被封装在一个函数或方法中。 扩展性：当需要添加新的产品时，只需添加相应的具体产品类和相应的具体工厂类，无需修改已有代码。 解耦：客户端代码独立于具体产品类，只与抽象产品和工厂类交互。 1.2. 工厂方法模式的结构 产品（Product）：定义了产品的接口。 具体产品（Concrete Product）：实现了产品接口的具体类。 工厂（Factory）：定义了创建产品的方法，通常是一个静态方法或抽象方法。 具体工厂（Concrete Factory）：实现了工厂接口，生成具体产品对象。 1.3. C++ 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; // 产品接口 class Product { public: virtual ~Product() {} virtual void use() = 0; }; // 具体产品 class ConcreteProduct : public Product { public: void use() override { std::cout \u0026lt;\u0026lt; \u0026#34;Using ConcreteProduct\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 工厂接口 class Factory { public: virtual ~Factory() {} virtual Product* createProduct() = 0; }; // 具体工厂 class ConcreteFactory : public Factory { public: Product* createProduct() override { return new ConcreteProduct(); } }; // 客户端代码 int main() { Factory* factory = new ConcreteFactory(); Product* product = factory-\u0026gt;createProduct(); product-\u0026gt;use(); // 使用具体产品 delete product; // 释放资源 delete factory; // 释放资源 return 0; } 1.4. 注意事项 简单工厂：如果创建逻辑简单，可以使用简单工厂模式，将所有创建逻辑放在一个工厂类中。 参数化工厂：如果创建对象需要外部参数，可以在工厂方法中传递这些参数。 工厂方法模式与抽象工厂模式：工厂方法模式用于创建单一产品，而抽象工厂模式用于创建产品族。 性能考虑：工厂方法模式可能会引入额外的性能开销，尤其是在创建对象时。 工厂方法模式适用于当创建对象的逻辑复杂或者需要将创建逻辑与使用逻辑分离的场景。它提高了系统的灵活性和扩展性，使得在不修改现有代码的情况下引入新的产品变得更加容易。\n2.如何用工厂方法模式解决代码中的耦合问题？ 工厂方法模式通过将对象的创建逻辑从使用对象的代码中分离出来，可以有效地解决代码耦合问题。以下是使用工厂方法模式解决耦合问题的步骤和示例：\n2.1. 步骤 定义产品接口：为需要解耦的对象创建一个接口或抽象类。\n实现具体产品：为每种具体的对象类型实现产品接口。\n定义工厂接口：为创建产品定义一个工厂接口或抽象类。\n实现具体工厂：为每种具体产品类型实现一个具体的工厂类。\n客户端使用工厂：客户端代码通过工厂接口请求产品，而不是直接创建具体产品。\n解耦客户端和具体实现：客户端不再依赖于具体产品类的实现，只依赖于产品接口和工厂接口。\n2.2. 示例 假设我们有一个应用程序，它使用不同类型的日志记录器，但我们希望客户端代码不依赖于具体的日志记录器实现。\n2.2.1. 定义日志记录器接口 1 2 3 4 5 class Logger { public: virtual ~Logger() {} virtual void log(const std::string\u0026amp; message) = 0; }; 2.2.2. 实现具体日志记录器 1 2 3 4 5 6 7 8 9 10 11 12 13 class ConsoleLogger : public Logger { public: void log(const std::string\u0026amp; message) override { std::cout \u0026lt;\u0026lt; \u0026#34;Console: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; class FileLogger : public Logger { public: void log(const std::string\u0026amp; message) override { // 将日志消息写入文件 } }; 2.2.3. 定义工厂接口 1 2 3 4 5 class LoggerFactory { public: virtual ~LoggerFactory() {} virtual Logger* createLogger() = 0; }; 2.2.4. 实现具体工厂 1 2 3 4 5 6 7 8 9 10 11 12 13 class ConsoleLoggerFactory : public LoggerFactory { public: Logger* createLogger() override { return new ConsoleLogger(); } }; class FileLoggerFactory : public LoggerFactory { public: Logger* createLogger() override { return new FileLogger(); } }; 2.2.5. 客户端使用工厂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Application { private: LoggerFactory* loggerFactory; public: Application(LoggerFactory* factory) : loggerFactory(factory) {} void setLoggerFactory(LoggerFactory* factory) { loggerFactory = factory; } void log(const std::string\u0026amp; message) { Logger* logger = loggerFactory-\u0026gt;createLogger(); logger-\u0026gt;log(message); delete logger; // 使用完毕后释放资源 } }; int main() { Application app; // 根据配置或环境设置不同的日志记录器 std::string loggerType; std::cout \u0026lt;\u0026lt; \u0026#34;Enter logger type (Console/File): \u0026#34;; std::cin \u0026gt;\u0026gt; loggerType; if (loggerType == \u0026#34;Console\u0026#34;) { app.setLoggerFactory(new ConsoleLoggerFactory()); } else if (loggerType == \u0026#34;File\u0026#34;) { app.setLoggerFactory(new FileLoggerFactory()); } else { std::cerr \u0026lt;\u0026lt; \u0026#34;Invalid logger type\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } app.log(\u0026#34;This is a log message.\u0026#34;); return 0; } 2.3. 解耦的优势 易于扩展：添加新的日志记录器类型时，只需添加新的具体日志记录器类和相应的工厂类。 提高模块化：客户端代码与日志记录器的具体实现解耦，只依赖于接口。 灵活配置：可以在运行时根据配置选择不同的日志记录器，无需修改客户端代码。 通过这种方式，工厂方法模式使得代码更加灵活和可维护，同时降低了各组件之间的依赖性。\n3.应用场景 工厂方法模式在实际开发中有多种应用场景，以下是一些常见的例子：\n数据库连接： 创建不同类型的数据库连接（如 MySQL、PostgreSQL）时，可以使用工厂方法模式根据不同的数据库类型生成相应的数据库连接对象。\n图形用户界面（GUI）组件： 在GUI应用程序中，创建不同类型的按钮、文本框等组件时，可以使用工厂方法模式来封装组件的创建过程。\n日志记录器： 根据不同的日志级别或日志输出目的地（如控制台、文件、网络）创建不同的日志记录器实例。\n配置文件解析器： 针对不同的配置文件格式（如 XML、JSON、YAML）创建相应的解析器对象。\n支付网关集成： 在电子商务应用中，根据不同的支付服务提供商（如 PayPal、Stripe、Alipay）创建支付网关实例。\n对象-关系映射（ORM）： 在ORM框架中，根据数据库表映射创建相应的模型对象。\n图像处理： 根据不同的图像格式（如 JPEG、PNG、GIF）创建相应的图像处理对象。\n协议处理器： 在网络编程中，根据不同的通信协议（如 HTTP、FTP、SMTP）创建对应的协议处理器对象。\n报表生成： 根据不同的报表格式（如 PDF、Excel、HTML）创建相应的报表生成器。\n邮件发送： 根据邮件发送服务（如 SMTP、SendGrid、Amazon SES）创建邮件发送对象。\n硬件设备驱动程序： 为不同类型的硬件设备（如打印机、扫描仪）创建相应的驱动程序实例。\nAPI客户端： 为不同的API服务（如 Twitter API、Facebook API）创建客户端实例。\n依赖注入容器： 在依赖注入框架中，工厂方法模式用于创建依赖项的实例。\n多态性实现： 在需要实现多态性的场景中，工厂方法可以用来根据条件生成继承体系中的特定子类实例。\n游戏开发： 在游戏开发中，根据不同的敌人类型或游戏对象创建相应的对象实例。\n工厂方法模式通过将对象创建的逻辑封装起来，使得代码更加模块化和可维护，同时也提高了扩展性。当系统中存在多种类型的对象需要创建，并且这些对象的创建逻辑可能会变化时，工厂方法模式尤其有用。\n4.用工厂方法模式实现数据库连接类 当然，以下是一个使用工厂方法模式的具体示例，我们将创建一个简单的数据库连接工厂，用于根据不同的数据库类型生成相应的数据库连接对象。\n4.1. 假设我们有以下数据库连接类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // MySQL数据库连接类 class MySQLConnection { public: void connect() { std::cout \u0026lt;\u0026lt; \u0026#34;Connecting to MySQL database...\u0026#34; \u0026lt;\u0026lt; std::endl; // MySQL连接逻辑 } }; // PostgreSQL数据库连接类 class PostgreSQLConnection { public: void connect() { std::cout \u0026lt;\u0026lt; \u0026#34;Connecting to PostgreSQL database...\u0026#34; \u0026lt;\u0026lt; std::endl; // PostgreSQL连接逻辑 } }; 4.2. 定义一个数据库连接的接口 1 2 3 4 5 class DatabaseConnection { public: virtual ~DatabaseConnection() {} virtual void connect() = 0; }; 4.3. 创建一个工厂基类 1 2 3 4 5 class DatabaseConnectionFactory { public: virtual ~DatabaseConnectionFactory() {} virtual DatabaseConnection* createConnection() = 0; }; 4.3. 实现具体的工厂类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // MySQL数据库连接工厂 class MySQLConnectionFactory : public DatabaseConnectionFactory { public: DatabaseConnection* createConnection() override { return new MySQLConnection(); } }; // PostgreSQL数据库连接工厂 class PostgreSQLConnectionFactory : public DatabaseConnectionFactory { public: DatabaseConnection* createConnection() override { return new PostgreSQLConnection(); } }; 4.4. 客户端使用示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int main() { // 客户端代码，根据需要选择数据库类型 std::string dbType; std::cout \u0026lt;\u0026lt; \u0026#34;Enter database type (MySQL/PostgreSQL): \u0026#34;; std::cin \u0026gt;\u0026gt; dbType; DatabaseConnectionFactory* factory; if (dbType == \u0026#34;MySQL\u0026#34;) { factory = new MySQLConnectionFactory(); } else if (dbType == \u0026#34;PostgreSQL\u0026#34;) { factory = new PostgreSQLConnectionFactory(); } else { std::cerr \u0026lt;\u0026lt; \u0026#34;Invalid database type\u0026#34; \u0026lt;\u0026lt; std::endl; return 1; } DatabaseConnection* dbConnection = factory-\u0026gt;createConnection(); dbConnection-\u0026gt;connect(); // 释放资源 delete dbConnection; delete factory; return 0; } 在这个示例中，我们定义了一个DatabaseConnection接口和两个具体的数据库连接类MySQLConnection和PostgreSQLConnection。然后，我们创建了DatabaseConnectionFactory工厂接口和两个具体的工厂类MySQLConnectionFactory与PostgreSQLConnectionFactory。在main函数中，根据用户输入选择相应的数据库类型，并使用相应的工厂来创建和连接数据库。\n这个示例展示了工厂方法模式如何帮助我们封装对象创建的复杂性，并且使得系统更容易扩展。如果需要支持新的数据库类型，我们只需添加新的数据库连接类和相应的工厂类，而无需修改现有的代码。\n5.工厂模式 单元测试 工厂方法模式在实际项目中的单元测试通常涉及以下几个方面：\n测试工厂类创建对象的功能：验证工厂类是否能够根据给定的参数或条件正确创建出预期的对象类型。这通常涉及到检查返回的对象是否是正确的类实例。\n测试对象的正确性：确保通过工厂方法创建的对象具有正确的属性和状态。这可能包括验证对象的字段值、状态或行为是否符合预期。\n测试边界条件和异常处理：检查工厂方法在面对不寻常的输入或错误条件时是否能够妥善处理，例如返回null或抛出异常。\n测试代码覆盖率：确保单元测试覆盖了工厂方法的所有分支和逻辑路径，以验证代码的健壮性。\n测试解耦合性：验证工厂方法模式是否成功地将对象创建的逻辑与使用对象的逻辑分离，从而降低代码之间的耦合度。\n测试可扩展性：通过添加新的产品类和相应的工厂类来测试系统是否能够灵活扩展，而无需修改现有代码。\n使用模拟对象：在测试中使用模拟（mock）对象来模拟依赖关系，确保测试的独立性和可重复性。\n编写清晰的测试用例：每个测试用例应该具有明确的目的和描述，便于理解和维护。\n执行测试并验证结果：运行测试并检查结果是否符合预期，确保所有测试都通过。\n持续集成：将单元测试集成到持续集成流程中，确保代码的每次提交都能自动运行测试，及时发现问题。\n通过这些测试策略，可以确保工厂方法模式的实现是正确、可靠和易于维护的。单元测试不仅帮助开发者验证代码的正确性，还提高了代码质量和项目的可维护性。\n6.工厂方法模式和简单工厂模式有什么区别，它们各自适用于什么情况？ 工厂方法模式（Factory Method Pattern）和简单工厂模式（Simple Factory Pattern）都是创建型设计模式，它们用于封装对象的创建过程。尽管它们的目的相似，但它们在结构和使用场景上有一些关键的区别：\n6.1.简单工厂模式 定义：简单工厂模式使用一个中心工厂类来创建所有类型的对象。这个类负责接收参数并根据参数决定创建哪种类型的对象。 结构：简单工厂模式通常包含一个工厂类和多个具体产品类。 优点： 易于理解和实现。 客户端不需要知道具体的类是如何实现的。 隐藏了对象创建的复杂性。 缺点： 工厂类集中了所有创建逻辑，违反了单一职责原则。 每增加一个产品类别，都需要修改工厂类，违反了开闭原则。 适用场景： 当创建逻辑比较简单，不需要重复编写创建代码时。 当产品种类较少，且新增产品类别的频率较低时。 6.2.工厂方法模式 定义：工厂方法模式定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法让类的实例化推迟到子类。 结构：工厂方法模式包含一个抽象工厂接口、多个具体工厂类和多个具体产品类。 优点： 遵循开闭原则，增加新的产品类不需要修改现有代码。 增加了创建逻辑的扩展性，每个具体工厂类负责创建一种产品。 符合单一职责原则，每个工厂类只负责创建一种具体产品。 缺点： 增加了系统的复杂度，需要为每个产品类创建对应的工厂类。 增加了系统的抽象性和理解难度。 适用场景： 当产品类别较多，且需要根据不同的条件创建不同的产品实例时。 当系统需要扩展性，能够灵活地引入新产品类别而不影响现有代码时。 6.3.区别 扩展性：工厂方法模式更容易扩展，因为它遵循开闭原则，而简单工厂模式在添加新产品时需要修改工厂类。 职责分配：工厂方法模式将创建逻辑分散到各个具体工厂类中，而简单工厂模式将所有创建逻辑集中在一个工厂类中。 抽象程度：工厂方法模式提供了更高层次的抽象，允许系统在运行时动态选择使用哪个工厂类。 在选择使用哪种模式时，需要根据实际项目的需求、系统的复杂度和预期的扩展性来决定。如果预计产品类别会频繁变化或增加，工厂方法模式可能是更好的选择。如果产品类别相对固定且数量较少，简单工厂模式可能更简单直接。\n7.在实际开发中，如何决定使用工厂方法模式还是简单工厂模式？ 在实际开发中，决定使用工厂方法模式还是简单工厂模式，可以根据以下几个关键因素进行考虑：\n扩展性需求：\n如果系统预计会有频繁的产品种类扩展，或者需要在未来添加更多产品类型，工厂方法模式更加合适，因为它遵循开闭原则，易于扩展。 产品种类数量：\n如果系统中的产品种类较少，或者新增产品的需求较低，简单工厂模式可能更加简单和直接。 创建逻辑复杂度：\n如果对象的创建逻辑相对简单，或者创建过程中不需要太多子类特有的逻辑，简单工厂模式可能更合适。 如果对象的创建逻辑较为复杂，或者不同的产品类型需要不同的创建逻辑，工厂方法模式允许将这些逻辑分散到各个具体工厂类中。 系统耦合度：\n如果希望降低系统各部分之间的耦合度，工厂方法模式通过定义抽象工厂接口，使得客户端代码与具体实现解耦。 代码维护性：\n如果系统的可维护性是关键考虑因素，工厂方法模式通常提供更好的维护性，因为它允许在不修改现有代码的基础上引入新的产品类型。 性能考虑：\n如果性能是一个关键因素，并且对象创建不是性能瓶颈，可以选择简单工厂模式，因为它可能更轻量级。 如果对象创建过程可能影响性能，工厂方法模式允许对创建过程进行优化，而不影响其他工厂类。 设计原则遵循：\n如果希望严格遵循设计原则，如单一职责原则和开闭原则，工厂方法模式是更好的选择。 团队熟悉度：\n考虑团队对设计模式的熟悉程度和偏好。如果团队对工厂方法模式更熟悉，选择工厂方法模式可能更有利于项目的顺利进行。 项目规模：\n对于大型项目或企业级应用，工厂方法模式可能更合适，因为它提供了更好的扩展性和灵活性。 对于小型或简单的项目，简单工厂模式可能足够用，且实现起来更快捷。 现有代码基础：\n如果现有系统已经采用了工厂方法模式，新增功能时继续使用工厂方法模式可以保持代码风格的一致性。 如果现有系统较小，且没有使用设计模式，引入简单工厂模式可能更简单。 综合考虑上述因素，可以做出更合适的选择。在一些情况下，两种模式可以结合使用，例如，使用简单工厂模式来处理创建逻辑相对简单的对象，而使用工厂方法模式来处理需要高度扩展性的对象。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-factory-method-pattern/","title":"design pattern Factory Method Pattern"},{"content":"设计模式-享元模式-Flyweight Pattern [TOC]\nOverview 享元模式（Flyweight Pattern）是一种结构型设计模式 它通过共享对象来减少创建大量相似对象时的内存消耗 1.C++中，享元模式 在C++中，享元模式（Flyweight Pattern）是一种用于优化内存使用和提高性能的结构型设计模式。它通过共享对象来有效支持大量细粒度的对象，从而减少内存消耗。享元模式特别适用于需要大量相似对象的情况，这些对象之间共享一些公共状态或数据。\n1.1.关键概念 享元（Flyweight）：享元模式中的对象，这些对象可以共享某些数据以减少内存占用。 享元工厂（Flyweight Factory）：负责管理和维护享元对象的共享。 客户端（Client）：使用享元对象，通常将对象的外部状态传递给享元对象。 1.2.实现步骤 定义享元接口：创建一个接口或抽象类，定义享元对象的公共接口。 创建具体享元类：实现享元接口，并存储内部状态。 创建享元工厂：负责创建和管理享元对象，确保相同内部状态的对象只被创建一次。 客户端使用享元：通过享元工厂获取享元对象，并传递外部状态以完成特定任务。 1.3.示例代码 以下是一个简单的C++代码示例，展示了如何使用享元模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;memory\u0026gt; // 抽象享元接口 class IFlyweight { public: virtual ~IFlyweight() {} virtual void operation(const std::string\u0026amp; extrinsicState) const = 0; }; // 具体享元类 class ConcreteFlyweight : public IFlyweight { private: std::string intrinsicState; // 内部状态 public: ConcreteFlyweight(const std::string\u0026amp; state) : intrinsicState(state) {} void operation(const std::string\u0026amp; extrinsicState) const override { std::cout \u0026lt;\u0026lt; \u0026#34;Concrete Flyweight: Internal State = \u0026#34; \u0026lt;\u0026lt; intrinsicState \u0026lt;\u0026lt; \u0026#34;, Extrinsic State = \u0026#34; \u0026lt;\u0026lt; extrinsicState \u0026lt;\u0026lt; std::endl; } }; // 享元工厂 class FlyweightFactory { private: std::map\u0026lt;std::string, std::shared_ptr\u0026lt;IFlyweight\u0026gt;\u0026gt; flyweights; public: std::shared_ptr\u0026lt;IFlyweight\u0026gt; getFlyweight(const std::string\u0026amp; key) { if (flyweights.count(key) == 0) { flyweights[key] = std::make_shared\u0026lt;ConcreteFlyweight\u0026gt;(key); } return flyweights[key]; } }; int main() { FlyweightFactory factory; std::vector\u0026lt;std::string\u0026gt; extrinsicStates = {\u0026#34;state1\u0026#34;, \u0026#34;state2\u0026#34;, \u0026#34;state2\u0026#34;}; for (const auto\u0026amp; state : extrinsicStates) { auto flyweight = factory.getFlyweight(\u0026#34;sharedState\u0026#34;); flyweight-\u0026gt;operation(state); } return 0; } 1.4.应用场景 大量对象的共享：当系统中需要创建大量相似的对象时，使用享元模式可以有效地减少对象数量，从而降低内存使用和提高性能。 对象的共享和重用：当对象具有大量共享状态并且外部状态不同的情况时，享元模式非常有用。 大量相似对象的场景：例如，文本编辑器中的字符、图形用户界面中的图标、游戏中的敌人等。 对象创建成本高的场景：例如，数据库连接池、线程池等。 需要优化内存使用的场景：例如，缓存系统中的对象、图像处理系统中的图像对象等。 1.5.优点 节省内存：通过共享相同的对象实例，减少了内存的消耗。 提高性能：减少了对象的创建和管理开销，提高了系统性能。 1.6.缺点 实现复杂：需要维护共享对象的管理机制，增加了系统的复杂性。 线程安全：在多线程环境下，享元模式的实现需要考虑线程安全问题，以避免数据的不一致性。 通过合理地使用享元模式，可以有效地降低内存使用，提高系统性能，特别是在处理大量具有相似内部状态的对象时。然而，在实际应用中，需要权衡享元模式带来的优点和引入的复杂性，以确保在合适的场景下使用享元模式，从而发挥其最大优势。\n2.享元模式应用场景 享元模式在实际项目中的应用场景非常广泛，以下是一些常见的例子：\n文本编辑器： 在文本编辑器中，字符是频繁使用的对象。由于许多字符可能会重复出现，使用享元模式可以共享这些字符的相同属性（如字体和大小），从而减少内存消耗。\n图形用户界面： 在GUI开发中，许多控件（如按钮、标签等）可能具有相同的外观和行为。享元模式允许共享这些控件的公共属性，减少创建控件时的资源消耗。\n游戏开发： 游戏中的大量对象（如敌人、子弹、道具等）可能具有相似的属性或行为。通过享元模式，可以共享这些对象的公共资源，如纹理和模型数据。\n数据库连接池： 数据库连接是一种宝贵的资源，享元模式可以用于实现连接池，复用已经创建的连接对象，减少创建和销毁连接的开销。\n缓存系统： 在缓存系统中，享元模式可以用来共享缓存对象，减少内存占用，提高缓存性能。\n网络编程： 在网络编程中，可以使用享元模式管理连接池或线程池，以实现资源的复用。\nJava中的String对象： Java中的字符串常量池就是享元模式的一个例子。字符串常量池中的字符串对象被多个引用共享，避免了相同字符串的重复创建。\n图像处理： 在图像处理软件中，享元模式可以用来共享图像的共同属性，如颜色空间和分辨率，减少内存占用。\n在C++中实现享元模式时，可以通过以下步骤：\n定义享元接口： 创建一个接口或抽象类，定义享元对象的公共接口。\n实现具体享元类： 实现享元接口，并存储享元对象的内部状态。\n创建享元工厂： 实现一个工厂类，负责创建和管理享元对象，确保相同内部状态的对象只被创建一次。\n处理外部状态： 在客户端代码中，传递外部状态给享元对象，以完成特定任务。\n通过这种方式，享元模式可以有效地减少内存消耗，提高系统性能。在实际应用中，享元模式需要仔细设计，以确保内部状态和外部状态的正确分离和管理。\n3.如何确保在多线程环境中，享元模式的正确性和线程安全？ 在多线程环境中使用享元模式时，确保线程安全是一个重要的考虑因素。以下是一些策略和实践，可以帮助确保享元模式的正确性和线程安全：\n使用线程安全的集合： 当享元工厂使用集合来存储和管理享元对象时，应选择线程安全的集合类，如 std::mutex 保护的 std::map 或 std::unordered_map，或者使用 std::shared_timed_mutex 来允许多个线程同时读取，但只有一个线程写入。\n同步访问享元对象： 如果享元对象的状态可以被多个线程修改，需要确保这些修改是同步的。可以使用互斥锁（如 std::mutex）来保护对享元对象状态的访问。\n不可变对象： 设计享元对象为不可变对象，这样它们的状态在创建后就不会改变，从而避免了线程安全问题。不可变对象可以在没有同步的情况下被多个线程安全地共享。\n最小化锁的使用： 尽量减少锁的使用，以避免性能瓶颈。例如，可以使用读写锁（如 std::shared_mutex）来允许多个线程同时读取享元对象，但写入时需要独占访问。\n线程局部存储： 对于外部状态，可以使用线程局部存储（如 thread_local 关键字）来为每个线程存储独立的外部状态，这样每个线程都有自己的状态副本，不需要同步。\n原子操作： 对于简单的状态修改，可以使用原子操作（如 std::atomic 类型）来保证操作的原子性和线程安全。\n避免共享可变状态： 尽可能设计享元模式以避免共享可变状态。如果必须共享，确保所有对共享状态的访问都是线程安全的。\n测试和验证： 在多线程环境中对享元模式进行充分的测试和验证，确保没有死锁、竞态条件或其他线程安全问题。\n文档和代码审查： 在代码中明确文档化线程安全策略，并进行代码审查，确保所有团队成员都理解并遵循这些策略。\n通过上述措施，可以在多线程环境中有效地使用享元模式，同时确保线程安全和性能。在实际应用中，需要根据具体的应用场景和需求来选择合适的策略。\n4.在C++中，享元模式的实现有哪些常见的问题和挑战？ 在C++中实现享元模式时，可能会遇到一些常见的问题和挑战：\n区分内部状态和外部状态：\n享元模式要求将对象的内部状态（可共享）与外部状态（不可共享）明确区分。正确地识别和设计这两部分是实现享元模式的关键。如果区分不当，可能会导致享元对象无法正确共享或使用。 享元工厂的实现：\n享元工厂负责管理享元对象的创建和共享。实现一个高效的享元工厂，确保享元对象可以被正确地共享和重用，是一个挑战。 线程安全：\n在多线程环境中，享元工厂需要确保线程安全，避免在共享享元对象时出现竞态条件。 内存管理：\n享元对象的内存管理需要仔细处理，以避免内存泄漏。在C++中，通常需要考虑对象的生命周期和正确的销毁时机。 享元对象的不可变性：\n为了确保享元对象可以安全共享，享元对象的状态应该是不可变的。任何需要变化的状态都应该作为外部状态处理。 过度共享：\n过度共享可能会导致系统复杂度增加，难以维护。需要根据实际情况判断哪些对象适合共享，哪些不适合。 享元模式与单例模式的区别：\n单例模式确保一个类只有一个实例，而享元模式通过共享多个对象来减少对象的数量。在实际应用中，需要根据需求选择合适的模式。 享元模式的适用性：\n享元模式适用于对象数量庞大且内部状态大部分可以共享的场景。如果对象的创建成本不高，或者对象数量不多，享元模式可能不会带来明显的好处。 享元模式的性能优化：\n在某些情况下，享元模式可能需要与缓存、对象池等技术结合使用，以进一步提高性能。 享元模式的实现复杂性：\n实现享元模式可能会增加代码的复杂性。需要确保代码的清晰性和可维护性。 在实际开发中，应该根据项目的具体需求和上下文来决定是否使用享元模式，并仔细设计内部状态和外部状态的分离，以及享元工厂的管理策略。通过合理的设计和实现，享元模式可以有效地减少内存消耗，提高系统性能。\n5.享元模式在内存管理上有哪些最佳实践？ 在C++中实现享元模式时，为了确保内存管理和性能优化的最佳实践，以下是一些关键点：\n明确内部状态和外部状态：\n内部状态（Intrinsic State）是享元对象共享的状态，通常是不变的。例如，一个字体对象的内部状态可能是字体类型和大小。外部状态（Extrinsic State）是与特定上下文相关的，不能共享，例如文本的位置或颜色。 享元工厂的管理：\n享元工厂（Flyweight Factory）负责创建和管理享元对象，确保相同的内部状态只创建一次享元对象。这通常涉及到一个存储已创建享元对象的集合，如使用std::map或std::unordered_map。 避免内存泄漏：\n在享元模式中，享元对象通常由享元工厂管理，因此需要注意对象的生命周期，避免内存泄漏。使用智能指针（如std::shared_ptr）可以帮助管理对象的生命周期。 线程安全：\n在多线程环境中，享元工厂的访问需要是线程安全的。可以使用互斥锁（如std::mutex）来保护对享元工厂内部集合的访问。 不可变性：\n使享元对象的内部状态不可变可以提高线程安全性，并简化内存管理。这意味着一旦享元对象被创建，它的内部状态就不能改变。 享元对象的共享：\n确保享元对象在不同上下文中可以被共享，同时保持外部状态的独立性。这通常通过将外部状态作为方法参数传递来实现。 享元模式与单例模式结合：\n在某些情况下，可以将享元工厂实现为单例模式，确保整个应用程序中只有一个享元工厂实例。 性能优化：\n享元模式的主要目标是优化性能和内存使用。在实现时，应评估共享带来的性能提升是否值得引入的复杂性。 代码清晰性：\n尽管享元模式可以优化内存使用，但不应牺牲代码的清晰性和可维护性。确保享元模式的实现不会导致系统难以理解和维护。 文档和注释：\n由于享元模式可能增加系统的复杂性，因此需要在代码中提供充分的文档和注释，以帮助其他开发者理解享元模式的实现和使用。 通过遵循这些最佳实践，可以在C++项目中有效地使用享元模式，以提高性能和内存使用效率，同时保持代码的可维护性。\n6.除了内存优化，享元模式在提高系统性能方面还有哪些优势？ 享元模式（Flyweight Pattern）是一种结构型设计模式，它通过共享对象来减少系统中对象的数量，从而降低内存占用和提高系统性能。这种模式特别适用于处理大量相似对象的情况，例如文本编辑器中的字符渲染、图形界面中的图形元素绘制等场景。享元模式的关键在于将对象的状态分为内部状态（Intrinsic State）和外部状态（Extrinsic State）。内部状态是对象共享的部分，而外部状态则是对象特定的、不可共享的部分。\n除了内存优化，享元模式在提高系统性能方面的优势包括：\n提高资源利用率：通过共享对象，减少了创建和销毁对象的开销，提高了系统资源的利用效率。 减少垃圾回收压力：由于减少了对象的创建，相应的也减少了内存分配和释放操作，从而缓解了垃圾回收器的压力，提高了系统的吞吐量。 降低对象间的耦合度：享元模式通过分离内部状态和外部状态，使得对象之间的耦合度降低，因为对象不需要关心其他对象的外部状态。 线程安全：共享的对象可以在多个线程中安全地共享并发访问，不会有线程安全问题。 提高系统的可扩展性：享元模式使得添加新的共享对象变得更加容易，有利于系统的扩展。 增强代码的可维护性：享元模式通过共享技术减少了对象的数量，使得代码更加简洁，易于维护。 然而，享元模式也带来了一些缺点，如增加系统设计的复杂性，需要分离出内部状态和外部状态，这可能会使得设计和实现更加复杂。此外，维护享元池也会增加开销，并且可能增加运行时间，因为需要在客户端和享元对象之间传递外部状态。\n在实际应用中，享元模式可以用于多种场景，如字符串常量池、数据库连接池、图形渲染中的贴图共享等。它通过享元工厂来管理对象的创建和共享，从而实现了对相似对象的高效处理。\n总结来说，享元模式通过共享技术有效地支持大量细粒度对象的复用，适用于对象状态可以外部化，并且剥离出共享部分和特有部分的场景。它能够显著减少内存消耗，提高系统性能和资源利用率，但同时也需要注意对内部状态和外部状态的管理，以及可能引入的线程安全问题。\n7.在图形用户界面设计中，享元模式是如何帮助减少内存消耗的？ 在图形用户界面设计中，享元模式通过共享对象来减少内存消耗，从而提高系统性能。具体来说，享元模式可以将图形元素的内部状态（如图像数据、图标表示等）作为共享状态，这些状态在多个实例之间共享，而每个元素的外部状态（如位置和用户特定的属性）则由客户端代码维护并传递给享元对象。这样，当界面中需要大量重复使用相同图形元素时，就不需要为每个元素创建独立的实例，从而大大减少了内存的使用。\n享元模式的工作原理包括以下几个关键步骤：\n识别共享状态和非共享状态：将对象的内部状态（共享状态）与外部状态（非共享状态）分离。 享元工厂的管理：享元工厂负责创建和管理享元对象，确保相似对象被共享，避免重复创建。 客户端使用享元对象：客户端通过享元工厂获取享元对象，并在需要时设置其外部状态。 在图形用户界面设计中，享元模式的优势包括：\n减少内存消耗：通过共享对象实例，减少了系统中对象的数量，从而降低了内存消耗。 提高性能：避免了频繁的对象创建和销毁操作，提高了系统的运行性能。 简化系统设计：享元模式有助于将对象的共享部分和变化部分分离开来，使系统设计更加清晰和灵活。 此外，享元模式还可以与其他设计模式如工厂模式、单例模式等协同工作，以实现更复杂的功能和更优的性能。例如，在UIKit中，UIColor、UIFont和UITableViewCell都是使用享元模式的类，它们通过共享来减少内存使用，提高性能。在游戏开发中，享元模式可以用于管理游戏实体，如子弹、粒子或纹理，其中共享属性如图像或行为在实例间共享，而位置、速度和其他状态信息则是特定于每个实例的。\n总结来说，享元模式在图形用户界面设计中的应用可以显著减少内存消耗和提高系统性能，特别是在处理大量相似图形元素时。通过合理地管理内部状态和外部状态，享元模式为图形界面设计提供了一种有效的内存优化策略。\n8.享元模式在数据库连接池中是如何具体实现的？ 享元模式在数据库连接池中的应用是一个典型的例子，它通过共享技术有效地支持大量细粒度的对象，从而减少创建对象的数量和提高系统性能。在数据库连接池中，享元模式的实现通常涉及以下几个关键步骤：\n定义连接接口：首先定义一个连接接口（如 Connection），它包含连接的基本操作，如提交（commit）、回滚（rollback）和关闭（close）。\n实现具体连接：创建一个具体连接类（如 DefaultConnection），实现连接接口。在关闭连接时，会将连接对象回收到连接池中，以便再次使用。\n定义数据源接口：定义一个数据源接口（如 DataSource），它负责提供获取连接的方法。\n实现池化的数据源：创建一个有池化功能的实现类（如 PooledDatasource），它包含活跃连接池列表和空闲连接池列表。当获取连接时，首先检查空闲连接池是否有可用连接，如果有，则直接提供给用户；如果没有，则创建新的连接并放入活跃连接池。\n连接回收：当连接不再使用时，通过 close 方法将连接从活跃连接池移除，并放入空闲连接池，以便后续再次使用。\n数据源工厂：定义一个数据源工厂（如 DatasourceFactory），它负责创建和管理数据源实例，确保连接池的正确初始化和配置。\n通过这种方式，数据库连接池可以显著减少创建和销毁数据库连接的开销，提高资源利用率，并减少系统的整体内存消耗。这种模式在高并发场景下尤为重要，因为它可以避免频繁地创建和销毁连接，从而提高系统的性能和稳定性。\n9.在享元模式中，如何确保连接池中的连接对象是线程安全的？ 在数据库连接池中，享元模式的线程安全性是一个关键考虑因素。以下是一些确保线程安全的方法：\n线程安全的享元工厂：享元工厂负责创建和管理连接对象，需要确保在多线程环境下，工厂的创建和获取连接对象的操作是线程安全的。可以通过使用同步机制（例如 synchronized 关键字）或者并发集合（例如 ConcurrentHashMap）来实现线程安全的享元工厂。\n使用不可变对象：如果连接对象是不可变的，那么就不需要担心线程安全问题，因为不可变对象的内部状态在创建后不会改变，自然不存在并发修改的问题。\n连接对象的状态管理：连接对象的状态（如是否被某个线程使用）需要通过线程安全的方式进行管理。可以通过原子变量（如 AtomicBoolean）来标识连接的状态，确保状态的改变是原子操作。\n等待/通知机制：当连接池中的连接都被占用时，请求连接的线程可能需要等待。可以使用 Object 类的 wait() 和 notify() 或者 Condition 接口来实现线程间的等待/通知机制，确保线程在合适的时机被唤醒。\n合理配置连接池参数：数据库连接池通常提供了大量的参数可以配置，例如最大连接数、最小空闲连接数等。合理配置这些参数，可以避免线程因争夺连接而产生过多的竞争，从而减少线程安全问题。\n使用现有的线程安全连接池实现：许多现有的数据库连接池实现（如 HikariCP、Apache DBCP、C3P0 等）已经考虑了线程安全问题，直接使用这些成熟的连接池实现可以避免自己处理线程安全问题。\n通过上述措施，可以在数据库连接池中实现享元模式的线程安全，确保在高并发环境下连接池的稳定性和性能。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-flyweight-pattern/","title":"design pattern Flyweight Pattern"},{"content":"设计模式-解释器模式-Interpreter Pattern [TOC]\nOverview 解释器模式（Interpreter Pattern）是一种行为设计模式 它主要用于定义如何评估语言的语法或表达式，是一种用于解释执行语言的模式 这种模式涉及到创建一个表达式接口，该接口能够解释一个特定的上下文 解释器模式通常用于解析和执行语言的语法规则，如计算表达式、解析文本文件等 1.解释器模式（Interpreter Pattern） 解释器模式（Interpreter Pattern）是一种行为设计模式，它主要用于定义如何评估语言的语法或表达式，是一种用于解释执行语言的模式。这种模式涉及到创建一个表达式接口，该接口能够解释一个特定的上下文。解释器模式通常用于解析和执行语言的语法规则，如计算表达式、解析文本文件等。\n1.1.组成要素 抽象表达式（AbstractExpression）：\n定义解释器的接口，通常包含一个 interpret() 方法，用于解释或执行表达式。 终结符表达式（TerminalExpression）：\n实现抽象表达式接口，代表语法中的终结符。终结符是最简单的表达式，没有子表达式。 非终结符表达式（NonterminalExpression）：\n也实现抽象表达式接口，代表语法中的非终结符。非终结符可以包含子表达式。 上下文（Context）：\n通常包含解释器之外的环境信息，这些信息对于解释器是必要的。 客户端（Client）：\n构建或配置具体的表达式，并使用解释器来解释或执行表达式。 1.2.适用场景 需要解释一种语言：\n当你需要解释一种语言（如简单的编程语言、查询语言等）时，可以使用解释器模式。 语法或表达式树的需求：\n当你需要处理复杂的语法或表达式树时，解释器模式可以提供一种结构化的方法。 易于改变的语法规则：\n当语法规则经常变化，且你希望在不修改现有代码的情况下轻松添加新的语法规则时。 1.3.优点 易于扩展：\n新的解释表达式可以很容易地加入到系统中，无需修改现有代码。 分离语法和语义：\n可以将语法分析和语义解释分离，使得系统更加模块化。 易于实现简单语法：\n对于简单的语法，实现起来相对简单直观。 1.4.缺点 性能问题：\n对于复杂的文法，解释器模式可能导致性能问题。 难以维护：\n当语法规则非常复杂时，解释器模式可能导致系统难以维护。 难以优化：\n优化解释器模式的性能可能比较困难。 1.5.示例代码（C++） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; // 抽象表达式 class Expression { public: virtual int interpret(std::map\u0026lt;char, int\u0026gt;\u0026amp; context) = 0; virtual ~Expression() {} }; // 终结符表达式 class TerminalExpression : public Expression { private: char symbol; public: TerminalExpression(char symbol) : symbol(symbol) {} int interpret(std::map\u0026lt;char, int\u0026gt;\u0026amp; context) override { return context[symbol]; } }; // 非终结符表达式 class NonterminalExpression : public Expression { private: std::unique_ptr\u0026lt;Expression\u0026gt; expr; public: NonterminalExpression(std::unique_ptr\u0026lt;Expression\u0026gt; expr) : expr(std::move(expr)) {} int interpret(std::map\u0026lt;char, int\u0026gt;\u0026amp; context) override { return expr-\u0026gt;interpret(context); } }; // 客户端代码 int main() { std::map\u0026lt;char, int\u0026gt; context = {{\u0026#39;a\u0026#39;, 1}, {\u0026#39;b\u0026#39;, 2}}; std::unique_ptr\u0026lt;Expression\u0026gt; expr = std::make_unique\u0026lt;TerminalExpression\u0026gt;(\u0026#39;a\u0026#39;); std::cout \u0026lt;\u0026lt; \u0026#34;Interpretation: \u0026#34; \u0026lt;\u0026lt; expr-\u0026gt;interpret(context) \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，Expression 是抽象表达式接口，TerminalExpression 是终结符表达式，它直接解释上下文中的值。NonterminalExpression 是非终结符表达式，它可以包含其他表达式。客户端代码创建了一个表达式并解释了上下文中的一个值。\n解释器模式在实际应用中可以用于构建表达式求值器、语法解析器、解释执行特定领域的语言等。\n2.解释器模式优缺点 解释器模式（Interpreter Pattern）的优缺点如下：\n2.1.优点 易于扩展：\n新的操作和文法可以很容易地添加到解释器中，而不需要修改已有的代码，这符合开闭原则。 分离性：\n将文法规则的定义与文法的解释逻辑分离，使得文法规则的变化或扩展不会影响到解释器的实现。 可定制性：\n用户可以定制自己的文法规则，并且可以创建自己的解释器来解释特定的语言。 易于实现简单文法：\n对于简单的文法，实现起来相对简单直观。 提高复用性：\n可以将重复的解释逻辑封装在解释器中，提高代码的复用性。 易于维护和修改：\n由于文法规则和解释逻辑的分离，使得维护和修改变得更加容易。 2.2.缺点 性能问题：\n解释器模式通常使用大量的循环和递归调用来解释和执行语句，这可能导致性能问题，特别是在复杂或者大量的文法规则时。 会引起类膨胀：\n每条规则至少需要定义一个类，当文法规则很多时，会导致系统中存在大量的类，这会增加系统的复杂性。 可应用场景有限：\n解释器模式通常只适用于问题可以清晰定义文法规则的情况，对于不适合定义文法的问题，使用解释器模式可能并不合适。 难以处理复杂的文法：\n当文法非常复杂时，使用解释器模式可能会导致系统难以管理和维护。 调试困难：\n解释器模式的逻辑可能非常复杂，尤其是当涉及到递归和大量的条件判断时，这使得调试变得困难。 可能导致重复代码：\n在某些情况下，为了实现特定的文法规则，可能会在不同的表达式类中编写相似的代码，导致代码重复。 难以优化：\n由于解释器模式的动态解释特性，对于性能的优化可能比较困难，尤其是当需要对解释执行的结果进行优化时。 总的来说，解释器模式在处理语言或表达式解析这类问题时非常有用，但需要权衡其可能带来的性能和复杂性问题。在实际应用中，如果问题域适合使用解释器模式，并且能够接受其潜在的缺点，那么它是一个强大的工具。\n3.解释器模式在实际开发中有哪些常见的应用场景？ 解释器模式是一种行为设计模式，它适用于以下类型的编程问题：\n需要解释一种语言：当你需要解释一种语言（如简单的编程语言、查询语言等）时，可以使用解释器模式。\n语法或表达式树的需求：当你需要处理复杂的语法或表达式树时，解释器模式可以提供一种结构化的方法。\n易于改变的语法规则：当你希望在不修改现有代码的情况下轻松添加新的语法规则时。\n日志处理：在处理日志时，如果有很多服务会产生大量的日志，并且需要对日志进行解析和生成报表，可以使用解释器模式。\n表达式求值器：在处理复杂的数学表达式或逻辑表达式时，解释器模式非常有用。\n配置文件解析：当应用程序需要从配置文件中读取参数和设置时，解释器模式可以用来解析配置文件的内容。\n编译器设计：解释器模式在编译器设计中非常常见，用于将源代码转换为机器代码。\n数据库查询语言：在数据库系统中，解释器模式用于解释和执行查询语言，如 SQL。\n正则表达式：解释器模式可以用于解析和执行正则表达式。\n模板引擎：在Web开发中，模板引擎可能会使用解释器模式来解释模板中的表达式。\n自然语言处理：在聊天机器人或虚拟助手中，解释器模式可以用于理解和处理用户的自然语言输入。\n领域特定语言（DSL）：在特定领域中，如金融交易系统，可能会开发自己的DSL来描述交易策略，解释器模式可以用来实现这些DSL。\n在实际开发中，使用解释器模式时需要考虑其优缺点。它提供了良好的扩展性和灵活性，但可能会导致性能问题、系统复杂度增加以及难以维护。因此，它通常适用于语法简单、执行效率不是关键问题、以及问题重复出现且可以用简单语言表达的场景。\n在实现解释器模式时，通常会构建一个抽象表达式接口，定义终结符和非终结符表达式类，以及一个上下文环境类，客户端代码则负责构建表达式并调用解释器进行解释。\n4.如何优化解释器模式以提高其性能？ 为了优化解释器模式以提高其性能，可以采取以下几种策略：\n缓存计算结果：对于重复使用的表达式节点，可以通过缓存其计算结果来避免重复计算，这样可以显著提高解释器的执行效率 。\n使用编译器技术：将解释器的解析和执行过程分为两个阶段，首先将源代码解析为中间表示形式（如字节码或机器码），然后通过编译器技术对中间表示进行优化和执行，这种方式可以将解释器转化为即时编译器，从而提高性能 。\n优化抽象语法树（AST）：通过优化AST的结构和遍历算法，减少不必要的计算和内存消耗。例如，可以使用尾递归优化、剪枝策略等技术，简化和优化AST的构建和遍历过程 。\n避免重复解析：如果需要多次处理相同的输入数据，可以考虑预解析所有可能的输入数据并将结果保存起来，这样在后续处理过程中，无需再次解析输入数据，只需查找预解析的结果即可 。\n并行解析：如果解释器需要处理大量输入数据，可以考虑将解析过程并行化，以利用多核处理器的计算能力 。\n延迟解析：在某些情况下，输入数据的某些部分可能并不需要立即解析。例如，当解释器用于处理配置文件时，可以只解析当前需要的配置项，而将其他配置项的解析推迟到实际需要时 。\n优化解析算法：使用更高效的算法来解析输入数据，以减少解析过程中的时间开销。例如，可以使用词法分析器和语法分析器生成器（如Flex和Bison）来构建解析器，这些工具可以生成高效的解析代码，从而提高解析性能 。\n部分解析缓存：在某些情况下，输入数据可能包含许多重复的子结构。为了避免重复解析这些子结构，可以将它们的解析结果存储在缓存中。当遇到相同的子结构时，直接从缓存中获取解析结果，从而提高解析速度 。\n表达式求值缓存：在解释器模式中，不同的表达式对象可能需要执行相似的计算过程。为了避免重复进行这些计算，可以在表达式对象中添加一个缓存层，用于存储计算结果。当需要执行相同的计算时，可以直接从缓存中获取结果，从而提高表达式求值的性能 。\n通过这些优化策略，可以在保持解释器模式带来的好处的同时，减少其可能引入的性能问题。在实际应用中，需要根据具体情况灵活选择和调整这些策略。\n5.使用编译器技术将解释器转化为即时编译器有哪些潜在的优势和挑战？ 使用编译器技术将解释器转化为即时编译器（JIT，Just-In-Time compilation）的潜在优势和挑战如下：\n5.1.优势 性能提升：即时编译器在运行时将热点代码编译成优化的机器码，可以显著提高程序的执行速度，尤其是在循环和频繁调用的方法上 。\n优化的代码：JIT编译器可以根据程序的实际运行情况来进行优化，如方法内联、逃逸分析、循环展开等，这些优化可以减少内存消耗和提高执行效率 。\n动态优化：即时编译器可以在程序运行过程中根据收集到的统计信息进行动态优化，适应程序的行为变化，这是静态编译器无法做到的 。\n资源利用：JIT编译器可以选择性地编译热点代码，避免了对不常执行的代码进行编译，从而节省了编译资源和内存空间 。\n跨平台性：即时编译器保留了Java的跨平台特性，同时提供了接近本地编译语言的性能 。\n5.2.挑战 启动延迟：即时编译器需要在程序运行时进行编译，这可能会导致程序启动速度变慢，尤其是在代码量较大时 。\n内存消耗：即时编译器生成的机器码需要存储在内存中，这可能会增加内存的消耗，尤其是在代码缓存（codeCache）较小的环境下 。\n编译器复杂性：实现一个高效的即时编译器需要复杂的编译技术，包括中间表示（IR）、优化算法和代码生成等，这增加了编译器的复杂性 。\n稳定性问题：由于即时编译器在运行时进行编译，如果编译过程中出现问题，可能会影响程序的稳定性 。\n调试难度：即时编译器生成的机器码可能会使得调试变得更加困难，因为源代码和执行的机器码之间没有直接的映射关系 。\n资源竞争：在高并发环境下，即时编译器可能会与应用程序的其他部分竞争CPU资源，这可能会影响整体性能 。\n总的来说，即时编译器通过在运行时优化代码，可以显著提高程序的性能，但同时也带来了一些挑战，如启动延迟、内存消耗和编译器复杂性等。开发者需要根据具体的应用场景和性能要求来权衡是否使用即时编译器技术。\n6.如何实现缓存计算结果以提高解释器模式的性能？ 在解释器模式中实现缓存计算结果以提高性能，通常涉及到以下几个步骤：\n确定可缓存的操作：\n识别出解释器模式中重复执行且开销较大的操作，这些操作的计算结果可以在一段时间内被复用。 使用缓存机制：\n设计一个缓存机制，可以是一个简单的哈希表，也可以是一个更复杂的缓存库，用于存储计算结果。 实现缓存逻辑：\n在解释器的 interpret() 方法中，添加逻辑来检查所需结果是否已经在缓存中。 如果结果在缓存中，直接返回缓存的结果，而不执行实际的计算。 如果结果不在缓存中，执行计算，然后将结果存储在缓存中，再返回结果。 考虑缓存失效策略：\n确定缓存数据的有效期，以及何时应该更新或删除缓存中的数据。 实现缓存失效策略，比如最近最少使用（LRU）算法，以确保缓存数据的有效性。 线程安全：\n如果在多线程环境中使用缓存，确保缓存的访问是线程安全的，避免并发问题。 监控和调优：\n监控缓存命中率和性能，根据实际使用情况调整缓存大小和失效策略。 6.1.示例代码（C++） 以下是一个简单的示例，演示了如何在解释器模式中实现缓存计算结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;memory\u0026gt; // 抽象表达式 class Expression { public: virtual int interpret() = 0; virtual ~Expression() {} }; // 具体表达式 class TerminalExpression : public Expression { private: int value; public: TerminalExpression(int value) : value(value) {} int interpret() override { std::cout \u0026lt;\u0026lt; \u0026#34;Calculating terminal expression...\u0026#34; \u0026lt;\u0026lt; std::endl; return value; } }; // 复杂表达式 class ComplexExpression : public Expression { private: std::unique_ptr\u0026lt;Expression\u0026gt; left; std::unique_ptr\u0026lt;Expression\u0026gt; right; char operation; public: ComplexExpression(std::unique_ptr\u0026lt;Expression\u0026gt; left, std::unique_ptr\u0026lt;Expression\u0026gt; right, char operation) : left(std::move(left)), right(std::move(right)), operation(operation) {} int interpret() override { std::cout \u0026lt;\u0026lt; \u0026#34;Calculating complex expression...\u0026#34; \u0026lt;\u0026lt; std::endl; int leftResult = left-\u0026gt;interpret(); int rightResult = right-\u0026gt;interpret(); if (operation == \u0026#39;+\u0026#39;) { return leftResult + rightResult; } else if (operation == \u0026#39;-\u0026#39;) { return leftResult - rightResult; } return 0; } }; // 缓存装饰器 class CachedExpression : public Expression { private: std::unique_ptr\u0026lt;Expression\u0026gt; expr; std::unordered_map\u0026lt;std::string, int\u0026gt; cache; public: CachedExpression(std::unique_ptr\u0026lt;Expression\u0026gt; expr) : expr(std::move(expr)) {} int interpret() override { std::string key = \u0026#34;CachedExpression\u0026#34;; if (cache.find(key) != cache.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Using cached result...\u0026#34; \u0026lt;\u0026lt; std::endl; return cache[key]; } int result = expr-\u0026gt;interpret(); cache[key] = result; return result; } }; int main() { auto terminal = std::make_unique\u0026lt;TerminalExpression\u0026gt;(5); auto complexExpr = std::make_unique\u0026lt;ComplexExpression\u0026gt;(std::move(terminal), std::make_unique\u0026lt;TerminalExpression\u0026gt;(3), \u0026#39;+\u0026#39;); auto cachedExpr = std::make_unique\u0026lt;CachedExpression\u0026gt;(std::move(complexExpr)); // 第一次计算，会执行并缓存结果 std::cout \u0026lt;\u0026lt; \u0026#34;First interpretation: \u0026#34; \u0026lt;\u0026lt; cachedExpr-\u0026gt;interpret() \u0026lt;\u0026lt; std::endl; // 第二次计算，会使用缓存的结果 std::cout \u0026lt;\u0026lt; \u0026#34;Second interpretation: \u0026#34; \u0026lt;\u0026lt; cachedExpr-\u0026gt;interpret() \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，CachedExpression 是一个装饰器，它包装了实际的表达式，并实现了缓存逻辑。当 interpret() 方法被调用时，它会检查缓存中是否存在结果，如果存在，则直接返回缓存的结果；如果不存在，则执行计算，并将结果存储在缓存中。\n通过这种方式，可以显著减少重复计算，提高解释器模式的性能。\n7.在多线程环境下，如何确保缓存的线程安全？ 在多线程环境下，确保缓存的线程安全通常涉及以下几个策略：\n使用同步机制：\n可以通过在缓存访问代码块中添加同步锁（如 synchronized 关键字）来确保同一时间只有一个线程可以修改缓存。这种方式简单但可能会影响性能，因为它限制了并发访问。 使用并发数据结构：\n利用 java.util.concurrent 包中提供的线程安全的数据结构，如 ConcurrentHashMap，可以减少锁的需要，提供更好的并发性能。 使用原子操作：\n对于简单的缓存操作，可以使用原子类（如 AtomicInteger），这些类提供了无锁的线程安全操作。 使用锁分段技术：\n锁分段是一种减少锁竞争的技术，通过将数据结构分成多个段，每段使用一个锁，从而允许多个线程同时操作不同段的数据。 使用无锁编程技术：\n利用 Compare-and-Swap（CAS）等原子操作来实现无锁的数据结构，这通常比传统的锁机制有更高的并发性能。 使用现代缓存框架：\n现代缓存框架如 Caffeine 已经内置了线程安全的支持。Caffeine 使用细粒度的锁定机制来保护共享资源，确保并发访问的正确性和一致性。它还提供了丰富的配置选项，如自动刷新、过期策略等，这些都是在保证线程安全的前提下进行的。 避免缓存污染：\n确保缓存中的数据不会被不正确的并发操作污染。例如，使用 volatile 关键字或者锁来确保缓存的可见性和有序性。 内存屏障：\n在某些情况下，可能需要使用内存屏障来确保操作的顺序性和内存的可见性。 减少缓存的共享：\n尽可能减少多个线程对同一缓存数据的共享，可以通过将缓存数据复制到线程私有的存储中来避免共享。 监控和调优：\n使用缓存框架提供的监控工具来观察缓存的性能和线程安全问题，根据实际情况进行调优。 通过上述策略，可以在多线程环境中有效地确保缓存的线程安全，同时保持良好的性能。在实际应用中，可能需要根据具体的业务场景和性能要求来选择和组合这些策略。\n8.在优化抽象语法树（AST）时，有哪些常见的优化技术？ 在优化抽象语法树（AST）时，以下是一些常见的优化技术：\n节点匹配优化：\n改进AST节点匹配算法，确保在比较两个AST时能够更准确地识别出相同的节点，减少不必要的编辑操作。 编辑脚本简化：\n通过合并相似的编辑操作（如连续的插入或删除）来简化生成的编辑脚本，从而减少编辑操作的数量。 启发式算法：\n使用启发式算法来优化节点的移动和更新操作，减少不必要的节点操作，提高AST编辑脚本的质量。 超参数优化：\n根据特定的AST特性和差异，调整AST比较算法中的超参数，如相似度阈值、节点大小限制等，以提高差异计算的准确性。 算法配置优化：\n通过全局或局部的超参数优化，找到最佳的算法配置，以适应不同的编程语言或AST元模型。 数据驱动的方法：\n使用数据驱动的方法，如DAT（Diff Auto Tuning），来自动调整AST比较算法的参数，以优化编辑脚本的长度和质量。 统计验证：\n通过统计验证和交叉验证来评估AST优化技术的有效性，确保优化方法在不同场景下都能保持一致的性能提升。 算法比较：\n比较不同的AST比较算法，选择或组合最有效的算法来处理特定的AST结构。 性能评估：\n对AST优化技术进行性能评估，包括执行时间、内存消耗和编辑脚本的质量，以找到最佳的优化策略。 自动化工具：\n开发自动化工具来支持AST优化过程，包括自动调整参数、自动评估优化效果和自动应用优化策略。 这些优化技术可以帮助提高AST处理的性能，减少不必要的计算，提高AST编辑脚本的质量和可读性。在实际应用中，可能需要根据具体的AST结构和差异计算需求来选择合适的优化策略。\n9.能否提供一些具体的AST优化案例，以便我更好地理解这些技术是如何应用的？ 在优化抽象语法树（AST）时，以下是一些具体的优化技术：\n常量折叠：在编译时计算常量表达式的值，而不是在运行时计算。这可以减少运行时的计算负担，并可能消除不必要的计算。\n死代码消除：移除那些不会被执行或者对程序输出没有影响的代码部分。这可以通过分析AST来识别未使用的变量和代码路径。\n循环优化：对循环结构进行优化，例如循环展开、循环融合、循环拆分等，以减少循环开销和提高缓存利用率。\n表达式简化：通过简化复杂的表达式来减少运行时的计算量。例如，将复杂的算术表达式分解为简单的步骤。\n内存访问优化：优化数据结构的布局，以减少内存访问延迟和提高数据的局部性。\n指令重排：在不影响程序语义的前提下，重新排列指令的顺序，以提高指令流水线的效率。\n代码内联：将函数调用的代码直接插入到调用点，以减少函数调用的开销。\n条件编译：在编译时根据条件删除或添加代码段，以适应不同的编译环境或配置。\n消除冗余代码：通过分析AST来识别并删除重复的代码块，减少代码的冗余。\n优化数据类型：在AST中识别并优化数据类型，例如使用更小的数据类型来减少内存使用。\n控制流分析：通过分析AST中的控制流，识别并优化条件判断、循环和分支结构。\n代码生成优化：在代码生成阶段，根据目标平台的特点优化生成的机器码。\n这些优化技术可以单独使用，也可以组合使用，以实现最佳的性能提升。在实际应用中，需要根据具体的程序特性和运行环境来选择最合适的优化策略。\n10.在进行AST优化时，如何确定哪些优化技术是必要的？ 在进行AST优化时，确定哪些优化技术是必要的，通常需要考虑以下几个方面：\n代码复杂度：如果代码中包含复杂的表达式或深层嵌套的结构，可能需要应用优化技术如常量折叠、表达式简化或循环优化。\n性能瓶颈：通过性能分析工具识别出程序的性能瓶颈，针对这些瓶颈应用优化技术，如循环展开、指令重排或内存访问优化。\n运行时特性：考虑代码的运行时特性，如热点代码识别，对频繁执行的代码段进行优化。\n目标平台：不同的目标平台可能对某些优化技术有更好的支持，根据目标平台的特点选择合适的优化技术。\n代码可读性：在不牺牲代码可读性的前提下进行优化，确保优化后的代码仍然易于理解和维护。\n开发和维护成本：权衡优化带来的性能提升和所需的开发及维护成本，选择性价比最高的优化技术。\n特定场景需求：根据特定的应用场景，如前端框架的模板优化、数据库查询优化等，选择适合的优化技术。\n社区和工具支持：利用现有的工具和社区资源，如Babel插件、代码分析工具等，来辅助确定和实施优化。\n通过综合考虑上述因素，可以更有针对性地选择和应用AST优化技术，以提高程序的性能和可维护性。在实际开发中，可能需要多次迭代和测试，以找到最佳的优化策略。\n11.在进行AST优化时，如何确定哪些优化技术最适合我的项目需求？ 在进行AST优化时，确定哪些优化技术最适合项目需求，可以通过以下几个步骤进行：\n性能分析：首先，使用性能分析工具来识别代码中的瓶颈和热点。这将帮助你了解哪些部分的代码最需要优化。\n代码复杂度评估：分析代码的复杂度，确定是否存在复杂的表达式或深层嵌套的结构，这些可能是优化的目标。\n项目需求分析：根据项目的具体需求，确定哪些优化技术能够带来最大的性能提升。例如，如果项目需要快速响应，那么循环优化可能是重点。\n目标平台特性：考虑目标平台的特性，选择能够在该平台上发挥最大效能的优化技术。\n开发和维护成本：评估不同优化技术的开发和维护成本，选择性价比最高的技术。\n社区和工具支持：利用现有的工具和社区资源，如Babel插件、代码分析工具等，来辅助确定和实施优化。\n测试和验证：对选定的优化技术进行测试和验证，确保它们能够达到预期的效果，并且不会引入新的问题。\n持续迭代：优化是一个持续的过程，需要不断地评估和调整优化策略，以适应项目的发展和变化。\n通过上述步骤，你可以更有针对性地选择和应用AST优化技术，以提高程序的性能和可维护性。在实际开发中，可能需要多次迭代和测试，以找到最佳的优化策略。\n12.能否提供一些关于如何分析AST以识别优化机会的指导？ 在进行AST优化时，确定哪些优化技术最适合项目需求，可以通过以下几个步骤进行：\n性能分析：首先，使用性能分析工具来识别代码中的瓶颈和热点。这将帮助你了解哪些部分的代码最需要优化。\n代码复杂度评估：分析代码的复杂度，确定是否存在复杂的表达式或深层嵌套的结构，这些可能是优化的目标。\n项目需求分析：根据项目的具体需求，确定哪些优化技术能够带来最大的性能提升。例如，如果项目需要快速响应，那么循环优化可能是重点。\n目标平台特性：考虑目标平台的特性，选择能够在该平台上发挥最大效能的优化技术。\n开发和维护成本：评估不同优化技术的开发和维护成本，选择性价比最高的技术。\n社区和工具支持：利用现有的工具和社区资源，如Babel插件、代码分析工具等，来辅助确定和实施优化。\n测试和验证：对选定的优化技术进行测试和验证，确保它们能够达到预期的效果，并且不会引入新的问题。\n持续迭代：优化是一个持续的过程，需要不断地评估和调整优化策略，以适应项目的发展和变化。\n通过上述步骤，你可以更有针对性地选择和应用AST优化技术，以提高程序的性能和可维护性。在实际开发中，可能需要多次迭代和测试，以找到最佳的优化策略。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-interpreter-pattern/","title":"design pattern Interpreter Pattern"},{"content":"设计模式-迭代器模式-Iterator Pattern [TOC]\nOverview 迭代器模式（Iterator Pattern）是一种行为型设计模式 它提供一种方法来访问聚合对象中各个元素，同时不暴露其内部的细节 迭代器模式的目的是将访问数据的逻辑与数据结构本身分离，从而可以在不同的数据结构上使用相同的访问逻辑 1.迭代器模式（Iterator Pattern） 迭代器模式（Iterator Pattern）是一种行为型设计模式，它提供一种方法来访问聚合对象中各个元素，同时不暴露其内部的细节。迭代器模式的目的是将访问数据的逻辑与数据结构本身分离，从而可以在不同的数据结构上使用相同的访问逻辑。\n在C++中实现迭代器模式通常涉及到以下几个组件：\n迭代器（Iterator）：定义访问和遍历元素的接口。 具体迭代器（Concrete Iterator）：实现迭代器接口的具体类，记录遍历过程中的当前位置。 容器（Container）：定义创建相应迭代器对象的接口。 具体容器（Concrete Container）：实现创建相应迭代器的接口，存储数据元素。 下面是一个简单的迭代器模式的C++实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 迭代器接口 class Iterator { public: virtual ~Iterator() {} virtual bool hasNext() const = 0; virtual int next() = 0; }; // 具体迭代器 class ConcreteIterator : public Iterator { private: std::vector\u0026lt;int\u0026gt;\u0026amp; container; size_t index; public: ConcreteIterator(std::vector\u0026lt;int\u0026gt;\u0026amp; container) : container(container), index(0) {} virtual bool hasNext() const override { return index \u0026lt; container.size(); } virtual int next() override { if (hasNext()) { return container[index++]; } throw std::out_of_range(\u0026#34;No more elements\u0026#34;); } }; // 容器接口 class Container { public: virtual ~Container() {} virtual Iterator* createIterator() = 0; }; // 具体容器 class ConcreteContainer : public Container { private: std::vector\u0026lt;int\u0026gt; data; public: ConcreteContainer(const std::vector\u0026lt;int\u0026gt;\u0026amp; data) : data(data) {} virtual Iterator* createIterator() override { return new ConcreteIterator(data); } }; int main() { std::vector\u0026lt;int\u0026gt; data = {1, 2, 3, 4, 5}; ConcreteContainer container(data); Iterator* iterator = container.createIterator(); while (iterator-\u0026gt;hasNext()) { std::cout \u0026lt;\u0026lt; iterator-\u0026gt;next() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } delete iterator; return 0; } 在这个例子中，ConcreteIterator 是具体迭代器，它实现了 Iterator 接口，并记录了遍历过程中的当前位置。ConcreteContainer 是具体容器，它实现了 Container 接口，并创建了一个 ConcreteIterator 实例来遍历其内部的数据。\nmain 函数中创建了一个 ConcreteContainer 实例，并使用它来创建一个迭代器，然后通过迭代器遍历容器中的所有元素。\n请注意，这个例子中使用了动态内存分配（new 关键字）来创建迭代器，因此在结束时需要手动释放内存（delete 关键字）。在实际的C++项目中，你可能会使用智能指针来自动管理内存，或者使用C++11及以上版本的范围基迭代器来简化代码。\n2.迭代器模式优缺点 优点 单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。 开闭原则。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。 你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。 相似的， 你可以暂停遍历并在需要时继续。 缺点 如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。 对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。 迭代器模式（Iterator Pattern）是一种常用的设计模式，它在软件开发中用于顺序访问一个聚合对象中的各个元素，而不需要暴露其内部的表现。以下是迭代器模式的一些优缺点：\n2.1.优点 访问聚合对象内容而无需了解其内部结构：迭代器提供了一种统一的接口来访问不同的数据结构，使得客户端代码可以通用地遍历各种类型的数据集合。\n支持多种遍历：可以实现多种类型的迭代器，例如正向迭代器、反向迭代器等，以支持不同的遍历需求。\n增加新的聚合类型和迭代器类型：可以独立地增加新的聚合类和迭代器类，而不需要修改现有的代码，这符合开闭原则。\n减少系统的耦合度：迭代器模式将聚合对象和客户端代码解耦，客户端代码不需要知道数据结构的细节，只需要通过迭代器来访问数据。\n支持多种遍历算法：可以设计多种迭代器来实现不同的遍历算法，使得算法独立于数据结构。\n提高代码的可复用性：迭代器模式使得遍历算法和数据结构分离，提高了代码的复用性。\n2.2.缺点 增加系统的复杂性：对于简单的数据结构，使用迭代器模式可能会增加系统的复杂性，因为需要额外实现迭代器类。\n迭代器的开销：迭代器的实现可能会引入额外的内存和时间开销，尤其是在迭代器需要存储遍历状态的情况下。\n可能不支持所有操作：某些数据结构可能不支持所有类型的迭代器，例如，某些数据结构可能不支持反向迭代器。\n迭代器的同步问题：在多线程环境中，迭代器可能会遇到同步问题，需要额外的机制来确保线程安全。\n迭代器失效问题：在迭代过程中，如果聚合对象的结构发生变化（如添加或删除元素），可能会导致迭代器失效，需要额外的机制来处理这种情况。\n迭代器的通用性限制：迭代器模式通常适用于线性结构，对于树形结构或图形结构，可能需要特殊的迭代器实现。\n总的来说，迭代器模式是一种强大的设计模式，它提供了一种统一的方式来遍历不同的数据结构。然而，它也有其局限性，特别是在处理复杂数据结构或需要高效遍历的情况下。在决定使用迭代器模式时，应该权衡其优缺点，以确保它适合特定的应用场景。\n3.迭代器模式在实际开发中有哪些常见的应用场景？ 迭代器模式在软件开发中有着广泛的应用，特别是在需要遍历或访问聚合对象元素时。以下是一些常见的应用场景：\n集合框架：在许多编程语言的标准库中，集合框架（如 Java 的 java.util 包或 C++ 的 STL）广泛使用了迭代器模式，以提供统一的接口来遍历集合中的元素。\n数据访问：在数据库应用中，迭代器可以用来遍历查询结果集，而不需要关心数据是如何存储和检索的。\n文件系统遍历：在文件管理软件中，迭代器可以用来遍历文件系统中的目录和文件，提供一种统一的方式来访问文件和目录。\n树结构遍历：在需要遍历树结构（如 DOM 树、语法树等）时，迭代器模式可以用来提供前序、中序、后序等不同的遍历方式。\n图形用户界面：在图形用户界面（GUI）开发中，迭代器可以用来遍历界面组件，如窗口、按钮、列表项等。\n网络爬虫：在网络爬虫设计中，迭代器可以用来遍历网页中的链接或元素，实现对网页内容的访问和提取。\n游戏开发：在游戏开发中，迭代器可以用来遍历游戏世界中的所有对象，如角色、道具、敌人等。\n数据流处理：在数据流处理系统中，迭代器可以用来遍历数据流中的记录或事件。\n缓存系统：在缓存系统中，迭代器可以用来遍历缓存中的条目，实现对缓存内容的访问和更新。\n算法实现：在实现某些算法（如排序、搜索等）时，迭代器可以用来提供对数据集合的访问，而不需要关心数据的具体存储结构。\n多维数组遍历：在处理多维数组或矩阵时，迭代器可以用来简化元素的访问和遍历。\n复合数据结构：在处理复合数据结构（如链表、队列、栈等）时，迭代器可以用来提供统一的遍历接口。\n迭代器模式的应用场景非常广泛，它的核心价值在于提供了一种抽象和解耦的方式，使得客户端代码可以独立于数据结构的具体实现，从而提高了代码的灵活性和可维护性。\n4.在实际开发中，如何确保迭代器模式的正确使用和性能优化？ 在实际开发中，确保迭代器模式的正确使用和性能优化，可以遵循以下建议：\n理解迭代器模式的适用场景：使用迭代器模式来访问集合对象的内容而无需暴露其内部结构，为不同类型的集合结构提供统一的遍历接口。\n正确实现迭代器和容器：确保迭代器实现了必要的方法，如 hasNext(), next(), remove() 等，并确保容器能够创建适当的迭代器实例。\n避免在迭代过程中修改容器：在迭代过程中直接修改容器（如添加或删除元素）可能会导致迭代器失效。如果需要修改，应该重新获取迭代器。\n使用适合的迭代器类型：根据需要选择正向迭代器、反向迭代器或同时支持两者。对于复杂的数据结构，可能需要实现特殊的迭代器来支持特定的遍历策略。\n性能优化：尽量减少不必要的方法调用，如在循环中只调用一次 hasNext()。考虑使用缓存来存储已经访问过的元素，以避免重复计算。\n处理异常和错误：妥善处理可能的并发修改异常和其他错误，确保迭代器能够在容器内容变化时正确响应。\n利用现有的迭代器：在可能的情况下，利用语言标准库提供的迭代器，如 Java 的 java.util.Iterator 或 C++ 的 STL 迭代器，这些迭代器已经经过优化，能够提供良好的性能和稳定性。\n代码重构和设计模式结合：在需要时，可以使用设计模式如策略模式来实现不同的迭代策略，或者使用装饰者模式来增强迭代器的功能。\n测试和验证：确保通过测试来验证迭代器的正确性和性能，特别是在多线程环境下的线程安全性和性能表现。\n通过遵循这些最佳实践，可以确保迭代器模式在实际开发中的有效使用，并优化其性能。\n5.在C++中，如何使用迭代器来遍历STL容器中的元素？ 在C++中，标准模板库（STL）提供了多种容器，如 vector、list、map 等，每种容器都支持迭代器来遍历其元素。STL迭代器遵循迭代器模式，提供了一种访问容器元素的统一方式。\n以下是使用迭代器遍历STL容器元素的一些常见方法：\n1.使用传统的迭代器 对于序列容器（如 vector、deque、list）和关联容器（如 set、map），你可以使用以下方式遍历：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 使用迭代器遍历 for (std::vector\u0026lt;int\u0026gt;::iterator it = vec.begin(); it != vec.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 2.使用常量迭代器 如果你不需要修改容器中的元素，可以使用常量迭代器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { const std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 使用常量迭代器遍历 for (std::vector\u0026lt;int\u0026gt;::const_iterator it = vec.begin(); it != vec.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 3.使用基于范围的for循环（C++11及以上） C++11引入了基于范围的for循环，它使得遍历容器更加简洁：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 基于范围的for循环 for (int num : vec) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 4.使用反向迭代器 STL容器也支持反向迭代器，用于从后向前遍历容器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 使用反向迭代器遍历 for (std::vector\u0026lt;int\u0026gt;::reverse_iterator it = vec.rbegin(); it != vec.rend(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 5.使用C++11的迭代器 C++11还引入了自动类型推导，使得迭代器的使用更加方便：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; // 使用auto关键字简化迭代器的声明 for (auto it = vec.begin(); it != vec.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 这些方法提供了灵活的方式来遍历STL容器中的元素，选择哪种方法取决于你的具体需求和C++版本。\n6.选代器模式在多线程环境下使用时需要注意哪些问题？ 在多线程环境下使用迭代器模式时，需要注意以下几个问题：\n线程安全：迭代器通常不是线程安全的。如果在迭代过程中，其他线程修改了集合，可能会导致迭代器抛出ConcurrentModificationException。为了避免这种情况，可以使用线程安全的集合类，如CopyOnWriteArrayList，或者在迭代期间对集合加锁。\n避免共享迭代器：不要在多个线程之间共享同一个迭代器实例。每个线程应该使用独立的迭代器实例来遍历集合。\n使用迭代器的remove方法：如果需要在迭代过程中删除元素，应该使用迭代器提供的remove方法，而不是直接调用集合的remove方法，这样可以避免ConcurrentModificationException。\n迭代器失效问题：在迭代过程中，如果集合结构发生变化（例如，添加或删除元素），可能会导致迭代器失效。需要确保在迭代期间不会修改集合，或者使用支持修改的迭代器实现。\n性能考虑：在多线程环境中，对集合的同步访问可能会影响性能。需要权衡线程安全和性能之间的关系，选择合适的并发控制机制。\n并发容器：Java 5及以上版本提供了并发容器，如ConcurrentHashMap和CopyOnWriteArrayList，它们内部实现了更好的并发控制机制，可以在多线程环境中安全地使用。\n迭代器的fail-fast机制：许多Java集合的迭代器使用fail-fast机制，这意味着如果检测到集合在迭代过程中被修改，迭代器会立即抛出异常。这是为了防止不确定的行为和潜在的错误。\n克隆集合：作为一种替代方法，可以在迭代之前克隆集合的副本，然后在副本上进行迭代。这样可以避免在迭代期间对原始集合的修改，但可能会引入显著的性能开销。\n在实际开发中，应该根据具体的应用场景和性能要求来选择合适的迭代器和并发控制策略。\n7.选代器模式在多线程环境下使用示例 cpp 在C++中，迭代器模式的多线程使用示例需要考虑线程安全问题。以下是一个简单的示例，展示如何在多线程环境下安全地使用迭代器来遍历一个线程安全的容器。\n首先，我们需要一个线程安全的容器。C++标准库中的std::vector不是线程安全的，所以我们需要自己实现一个线程安全的容器，或者使用互斥锁来保护对容器的访问。这里，我们使用std::mutex来保护一个std::vector的访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;iterator\u0026gt; class ThreadSafeVector { private: std::vector\u0026lt;int\u0026gt; data; mutable std::mutex mutex; public: void push_back(int value) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); data.push_back(value); } std::vector\u0026lt;int\u0026gt;::iterator begin() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); return data.begin(); } std::vector\u0026lt;int\u0026gt;::iterator end() { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); return data.end(); } }; void print_elements(ThreadSafeVector\u0026amp; vec) { for (auto it = vec.begin(); it != vec.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } int main() { ThreadSafeVector vec; // 启动多个线程来打印向量内容 std::thread t1(print_elements, std::ref(vec)); std::thread t2(print_elements, std::ref(vec)); // 启动一个线程来修改向量内容 std::thread modifier([\u0026amp;vec]() { for (int i = 0; i \u0026lt; 10; ++i) { vec.push_back(i); } }); t1.join(); t2.join(); modifier.join(); return 0; } 在这个示例中，ThreadSafeVector类封装了一个std::vector和一个互斥锁std::mutex。任何对向量的访问（通过begin和end方法）都需要获取互斥锁，以确保线程安全。\nprint_elements函数接受一个ThreadSafeVector的引用，并使用迭代器遍历并打印容器中的所有元素。\n在main函数中，我们创建了三个线程：两个线程调用print_elements函数来打印向量的内容，另一个线程作为修改器，向向量中添加元素。由于我们使用了互斥锁，所以即使在多线程环境下，迭代器的使用也是安全的。\n请注意，这个示例仅用于演示目的。在实际应用中，可能需要更复杂的线程同步机制，以确保高性能和正确的线程间通信。此外，C++标准库中的并发数据结构（如std::shared_mutex和std::unique_lock）可以提供更细粒度的锁和更好的性能。\n8.在多线程环境下，如何确保迭代器模式的线程安全？ 在多线程环境下确保迭代器模式的线程安全，可以采取以下几种策略：\n使用互斥锁（Mutex）：\n在容器的每个操作方法中使用互斥锁来同步访问。 确保在迭代器的next()、hasNext()等方法中也使用相同的互斥锁。 使用读写锁（Read-Write Lock）：\n当多个线程需要同时读取数据时，可以使用读写锁来允许多个读操作并行，但在写操作执行时互斥。 复制数据：\n在迭代开始前复制容器的数据，迭代器遍历的是数据的副本，而原始数据可以被修改。 使用不可变集合：\n创建容器的不可变副本供迭代器遍历，这样原始容器可以自由修改而不影响迭代器。 使用并发集合：\n使用专门为并发设计的集合类，如Java中的ConcurrentHashMap或C++中的某些线程安全集合。 迭代器失效策略：\n实现“快速失败”（fail-fast）的迭代器，当检测到并发修改时抛出异常。 需要在文档中明确迭代器的这一行为，提醒用户在迭代过程中不要修改容器。 避免在迭代过程中修改容器：\n设计迭代器时，禁止在迭代过程中通过迭代器修改容器，或者确保修改操作是线程安全的。 使用条件变量：\n当迭代器需要等待容器的修改完成时，可以使用条件变量来同步线程。 使用原子操作：\n对于简单的数据结构，可以使用原子操作来保证迭代过程中的数据一致性。 使用无锁编程技术：\n在某些情况下，可以使用无锁编程技术来避免使用互斥锁，但这通常更复杂且容易出错。 以下是一个简单的C++示例，展示如何使用互斥锁来确保迭代器模式的线程安全：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;iterator\u0026gt; template \u0026lt;typename T\u0026gt; class ThreadSafeContainer { private: std::vector\u0026lt;T\u0026gt; data; mutable std::mutex mutex; public: void add(T value) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); data.push_back(value); } class Iterator { private: std::vector\u0026lt;T\u0026gt; data; size_t current; std::mutex\u0026amp; mutex; public: Iterator(std::mutex\u0026amp; mutex) : mutex(mutex), current(0) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); data = data; } bool hasNext() const { return current \u0026lt; data.size(); } T next() { if (!hasNext()) throw std::runtime_error(\u0026#34;No more elements\u0026#34;); return data[current++]; } }; Iterator getIterator() { return Iterator(mutex); } }; int main() { ThreadSafeContainer\u0026lt;int\u0026gt; container; // 线程添加元素 std::thread t1([\u0026amp;container]() { for (int i = 0; i \u0026lt; 10; ++i) { container.add(i); } }); // 线程遍历元素 std::thread t2([\u0026amp;container]() { auto it = container.getIterator(); while (it.hasNext()) { std::cout \u0026lt;\u0026lt; it.next() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; }); t1.join(); t2.join(); return 0; } 在这个示例中，ThreadSafeContainer 类使用一个互斥锁来保护对内部数据的访问。迭代器在构造时复制了容器的数据，并持有一个互斥锁的引用，以确保在迭代过程中数据不会被修改。这样可以确保在多线程环境下迭代器的线程安全。\n9.除了使用互斥锁，还有哪些方法可以保证迭代器模式的线程安全？ 除了使用互斥锁，以下是一些其他方法来保证迭代器模式的线程安全：\n不可变集合：\n创建容器的不可变副本供迭代器遍历。由于副本是不变的，原始容器可以自由修改而不影响迭代器。 并发集合：\n使用专门为并发设计的集合类，这些集合通常内部实现了优化的锁策略或其他同步机制。 锁分离：\n对容器的不同部分使用不同的锁，这样可以在多个线程之间提供更高的并行度。 读写锁：\n使用读写锁允许多个读线程同时访问容器，但写线程在修改容器时会阻塞所有其他线程。 乐观锁：\n使用乐观锁（如CAS操作）来实现无锁的并发控制，这通常适用于写操作较少的场景。 顺序控制：\n通过软件事务内存（STM）或其他顺序控制技术来确保在迭代过程中对容器的修改不会影响迭代器。 原子操作：\n对于简单的数据结构，可以使用原子操作来保证迭代过程中的数据一致性。 条件变量：\n当迭代器需要等待容器的修改完成时，可以使用条件变量来同步线程。 屏障（Barriers）：\n使用屏障来同步多个线程，确保它们在某个点上达到一致的状态。 无锁编程技术：\n在某些情况下，可以使用无锁编程技术来避免使用互斥锁，但这通常更复杂且容易出错。 版本控制：\n对容器的每个版本进行编号，迭代器记住它开始迭代时的版本号，检查在迭代过程中版本号是否改变。 阻塞队列：\n对于生产者-消费者场景，可以使用阻塞队列等并发数据结构，它们通常内部实现了线程安全的机制。 分区锁：\n将容器分成多个区段，每个区段使用单独的锁，这样可以在多个区段之间提供并行性。 软件事务内存（STM）：\n使用STM来管理事务，确保在迭代和修改容器时的一致性和隔离性。 选择哪种方法取决于具体的应用场景、性能要求和并发级别。在设计线程安全的迭代器时，应该权衡不同方法的复杂性、性能开销和易用性。\n10.在C++中，如何使用std：shared_mutex来实现线程安全的迭代器操作？ 在C++中，std::shared_mutex是一种提供共享所有权（shared ownership）的互斥量，它允许多个线程同时获取共享锁（shared lock），进行读操作，或者独占锁（unique lock），进行写操作。这使得std::shared_mutex非常适合读多写少的场景。\n以下是使用std::shared_mutex来实现线程安全的迭代器操作的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;shared_mutex\u0026gt; #include \u0026lt;thread\u0026gt; class ThreadSafeVector { private: std::vector\u0026lt;int\u0026gt; data; std::shared_mutex shared_mutex; public: // 写操作：添加元素 void add(int value) { std::unique_lock\u0026lt;std::shared_mutex\u0026gt; lock(shared_mutex); data.push_back(value); } // 读操作：迭代器 class Iterator { private: std::shared_lock\u0026lt;std::shared_mutex\u0026gt; lock; std::vector\u0026lt;int\u0026gt; const* data_ptr; size_t index; public: Iterator(std::vector\u0026lt;int\u0026gt; const* data_ptr) : data_ptr(data_ptr), index(0) { // 获取共享锁 lock = std::shared_lock\u0026lt;std::shared_mutex\u0026gt;(data_ptr-\u0026gt;getMutex()); } ~Iterator() { // 释放共享锁 lock.unlock(); } bool hasNext() const { return index \u0026lt; (*data_ptr).size(); } int next() { if (!hasNext()) throw std::runtime_error(\u0026#34;No more elements\u0026#34;); return (*data_ptr)[index++]; } }; // 获取迭代器 Iterator getIterator() const { return Iterator(\u0026amp;data); } // 获取互斥量，用于迭代器的构造 std::shared_mutex\u0026amp; getMutex() const { return shared_mutex; } }; int main() { ThreadSafeVector vec; // 启动多个线程来添加元素 std::thread writer1([\u0026amp;vec]() { for (int i = 0; i \u0026lt; 10; ++i) { vec.add(i); } }); std::thread writer2([\u0026amp;vec]() { for (int i = 10; i \u0026lt; 20; ++i) { vec.add(i); } }); // 启动一个线程来迭代元素 std::thread reader([\u0026amp;vec]() { ThreadSafeVector::Iterator it = vec.getIterator(); while (it.hasNext()) { std::cout \u0026lt;\u0026lt; it.next() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; }); writer1.join(); writer2.join(); reader.join(); return 0; } 在这个示例中，ThreadSafeVector类使用std::shared_mutex来保护对内部数据std::vector\u0026lt;int\u0026gt;的访问。写操作（add方法）需要获取独占锁，而迭代器的构造函数需要获取共享锁。\n迭代器类Iterator在构造时获取共享锁，并在析构时释放锁。这样可以确保在迭代过程中，多个线程可以同时读取容器，而写操作则需要等待所有读操作完成。\n请注意，这个示例仅用于演示目的。在实际应用中，可能需要更复杂的线程同步机制，以确保高性能和正确的线程间通信。此外，std::shared_mutex在C++17中引入，因此需要C++17支持的编译器。\n11.std::shared_mutex在多线程环境下的性能如何，有没有可能成为瓶颈？ std::shared_mutex 在多线程环境下的性能表现取决于具体的使用场景。它提供了读写锁机制，允许多个线程同时进行读操作，而写操作则需要独占访问。这种机制在读取操作远多于写入操作的场景中特别有用，因为它可以减少线程间的等待时间，提高并发性能。\n根据搜索结果中的性能对比测试 ，当存在多个只读线程和一个写线程的情况下，std::shared_mutex 比 std::mutex 快一倍。这是因为 std::shared_mutex 允许多个线程同时获取共享锁进行读操作，而 std::mutex 则在任何时候只允许一个线程获取锁。因此，在高并发读取的场景下，std::shared_mutex 可以显著提高性能。\n然而，std::shared_mutex 也可能成为性能瓶颈，尤其是在写操作频繁的场景中。因为写操作需要获取独占锁，这会阻塞所有其他读写操作，直到写操作完成。此外，std::shared_mutex 的内部实现可能比 std::mutex 更复杂，这也可能影响其性能。\n在实际使用中，应该根据应用的具体需求来选择是否使用 std::shared_mutex。如果读操作远多于写操作，并且希望提高读取的并发性能，那么 std::shared_mutex 是一个很好的选择。如果写操作比较频繁，或者对实时性要求较高，可能需要考虑其他同步机制，或者对 std::shared_mutex 的使用进行精细的控制，以避免成为性能瓶颈。\n总的来说，std::shared_mutex 是一个强大的工具，但它的性能优势需要在适当的场景下才能发挥出来。在设计多线程程序时，应该根据实际的工作负载和性能要求来选择最合适的同步策略。\n12.除了 std::shared_mutex，还有哪些同步机制可以提高多线程程序的性能？ 在C++中，除了使用std::shared_mutex来提高多线程程序的性能外，还有多种同步机制可以使用。以下是一些其他的同步机制：\n互斥锁（Mutex）：互斥锁是最常用的同步机制，它确保在任何时刻只有一个线程可以访问受保护的资源。std::mutex是C++11引入的，它比传统的Windows互斥对象或POSIX互斥锁有更好的性能，尤其是在高并发环境下。\n条件变量（Condition Variables）：条件变量用于线程间的协调，允许线程在某些条件成立之前挂起（等待），直到其他线程改变这些条件并通知等待中的线程。\n原子操作（Atomic Operations）：原子操作提供了一种无锁的同步机制，适用于简单的数据操作，如对基本数据类型的操作。std::atomic是C++11引入的，它通过保证操作的原子性来避免数据竞争。\n信号量（Semaphore）：信号量用于控制对有限资源的访问，它允许一定数量的线程同时访问资源。信号量可以用于实现线程池、限制并发线程的数量等。\n自旋锁（Spinlock）：自旋锁是一种忙等待的锁机制，适用于锁持有时间非常短的情况。自旋锁通过循环检查锁的状态来实现，避免了线程的上下文切换，但可能会增加CPU的负担。\n读写锁（Read-Write Lock）：读写锁允许多个读线程同时访问资源，但写线程在修改资源时需要独占访问。这在读取操作远多于写入操作的场景中可以提高性能。\n无锁编程：无锁编程是一种避免使用常规锁机制的并发编程方法，它依赖于原子操作和复杂的算法来保证数据的一致性。\n异步操作：基于std::future和std::promise的异步编程模型，允许线程在不阻塞的情况下并行执行任务。\nC++20 新增同步机制：C++20引入了更多的同步机制，如std::latch、std::barrier和std::semaphore，这些新的同步工具为解决并发编程问题提供了更多角度和方法。\n内存顺序（Memory Order）：在C++11中引入的原子操作中，可以通过指定不同的内存顺序来优化性能，减少不必要的内存屏障，从而提高并发程序的性能。\n选择哪种同步机制取决于具体的应用场景、性能要求和并发级别。在设计多线程程序时，应该根据实际的工作负载和性能要求来选择最合适的同步策略。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-iterator-pattern/","title":"design pattern Iterator Pattern"},{"content":"设计模式-中介者模式-Mediator Pattern [TOC]\nOverview 中介者模式（Mediator Pattern）是一种行为型设计模式 它通过引入一个中介者对象来封装一系列的对象交互，使得对象之间不需要显式地相互引用，从而使得其耦合松散，而且可以独立地改变它们之间的交互 1.中介者模式（Mediator Pattern） 中介者模式（Mediator Pattern）是一种行为型设计模式，它通过引入一个中介者对象来封装一系列的对象交互，使得对象之间不需要显式地相互引用，从而使得其耦合松散，而且可以独立地改变它们之间的交互。这种模式在C++中的实现通常涉及以下几个关键组件：\n抽象中介者（Mediator）：定义了一个接口，该接口提供了同事对象注册和转发同事对象信息的方法。\n具体中介者（ConcreteMediator）：实现中介者接口，协调各个同事角色之间的交互关系。\n抽象同事类（Colleague）：定义同事类的接口，保存中介者对象的引用，并提供同事对象交互的抽象方法。\n具体同事类（Concrete Colleague）：实现抽象同事类，当需要与其他同事对象通信时，通过中介者进行。\n在C++中实现中介者模式的一个简单示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; // 抽象中介者 class Mediator { public: virtual void Send(const std::string\u0026amp; message, Colleague* colleague) = 0; }; // 具体中介者 class ConcreteMediator : public Mediator { private: std::vector\u0026lt;Colleague*\u0026gt; colleagues; public: void Register(Colleague* colleague) { colleagues.push_back(colleague); } void Send(const std::string\u0026amp; message, Colleague* colleague) override { for (auto* c : colleagues) { if (c != colleague) { c-\u0026gt;Notify(message); } } } }; // 抽象同事类 class Colleague { protected: Mediator* mediator; public: Colleague(Mediator* m) : mediator(m) {} virtual void Send(const std::string\u0026amp; message) = 0; virtual void Notify(const std::string\u0026amp; message) = 0; }; // 具体同事类A class ColleagueA : public Colleague { public: ColleagueA(Mediator* m) : Colleague(m) {} void Send(const std::string\u0026amp; message) override { mediator-\u0026gt;Send(message, this); } void Notify(const std::string\u0026amp; message) override { std::cout \u0026lt;\u0026lt; \u0026#34;ColleagueA received: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; // 具体同事类B class ColleagueB : public Colleague { public: ColleagueB(Mediator* m) : Colleague(m) {} void Send(const std::string\u0026amp; message) override { mediator-\u0026gt;Send(message, this); } void Notify(const std::string\u0026amp; message) override { std::cout \u0026lt;\u0026lt; \u0026#34;ColleagueB received: \u0026#34; \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; int main() { std::unique_ptr\u0026lt;Mediator\u0026gt; mediator(new ConcreteMediator()); ColleagueA a(mediator.get()); ColleagueB b(mediator.get()); mediator-\u0026gt;Register(\u0026amp;a); mediator-\u0026gt;Register(\u0026amp;b); a.Send(\u0026#34;Hi ColleagueB!\u0026#34;); b.Send(\u0026#34;Hello ColleagueA!\u0026#34;); return 0; } 在这个示例中，ConcreteMediator 管理着所有同事对象，并负责在它们之间转发消息。ColleagueA 和 ColleagueB 是具体的同事类，它们通过中介者来发送和接收消息。这种方式使得同事类之间的耦合度降低，增加了代码的可维护性和可扩展性。\n中介者模式的优点包括降低系统的耦合度、提高模块间的独立性以及提高了系统的可扩展性。然而，它也可能导致中介者对象变得复杂且难以维护，特别是当系统中的同事类数量很多时。因此，在设计时需要权衡中介者模式的利弊。\n2.中介者模式优缺点 优点 单一职责原则。 你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护。 开闭原则。 你无需修改实际组件就能增加新的中介者。 你可以减轻应用中多个组件间的耦合情况。 你可以更方便地复用各个组件。 缺点 一段时间后， 中介者可能会演化成为上帝对象。 中介者模式（Mediator Pattern）的优缺点如下：\n2.1.优点 降低耦合度：中介者模式可以减少类之间的直接通信，使得各个类之间的耦合度降低，只需要与中介者通信即可。\n提高模块化：通过使用中介者模式，可以将对象间的交互逻辑从对象本身抽离出来，使得系统更加模块化，易于理解和维护。\n易于扩展：新的组件可以很容易地加入到系统中，只需与中介者通信即可，无需修改其他组件的代码，符合开闭原则。\n集中控制：中介者可以控制组件之间的交互逻辑，使得交互逻辑集中管理，便于控制和优化。\n减少子类数量：中介者模式可以减少系统中的子类数量，因为交互逻辑被集中管理，不需要为每个组件创建子类来处理交互。\n可维护性：当需要修改组件之间的交互逻辑时，只需修改中介者即可，不需要修改组件本身，提高了系统的可维护性。\n2.2.缺点 中介者复杂性：随着系统的发展，中介者可能会变得越来越复杂，因为它需要处理所有组件之间的交互逻辑。\n性能问题：如果中介者变得过于复杂，可能会成为系统的性能瓶颈，因为所有的交互都需要通过中介者来完成。\n单一中介者风险：如果整个系统的组件都通过一个中介者来通信，那么这个中介者可能会成为系统的单点故障点。\n可测试性：由于组件之间的交互被中介者封装，可能会使得组件的独立测试变得困难，需要为中介者编写额外的测试代码。\n过度使用：在一些简单的系统中，或者组件之间的交互本身就不多的情况下，使用中介者模式可能会过度设计，增加不必要的复杂性。\n中介者职责过重：如果中介者承担了过多的职责，可能会导致其变得庞大且难以维护，形成“上帝对象”（God Object）。\n在使用中介者模式时，需要权衡这些优缺点，确保它适合解决系统面临的具体问题，并且不会引入新的问题。\n3.中介者模式在实际项目中有哪些常见的应用场景？ 中介者模式在实际项目中的应用场景非常广泛，以下是一些常见的例子：\n聊天室系统：在聊天室系统中，用户之间的消息传递通过中介者模式来管理，这样可以避免用户之间的直接通信，简化了用户类之间的耦合，并使得通信策略的修改更加方便。\n图形用户界面（GUI）：在GUI开发中，中介者模式常用于管理组件之间的交互，例如按钮、文本框和其他控件之间的通信。中介者可以是某个窗体或控制器，它负责协调各个组件的行为。\n网络游戏：在网络游戏中，中介者模式可以用来管理玩家之间的交互，例如聊天、交易等。服务器作为中介者，处理玩家之间的请求和响应。\n企业信息系统：在企业信息系统中，中介者模式可以用来协调不同业务模块之间的通信，例如订单处理、库存管理和客户服务等。\n硬件设备协调：在智能家居或工业控制系统中，中介者模式可以用来协调各种设备之间的交互，例如灯光、温度控制、安全系统等。\n网络协议栈：在网络通信中，中介者模式可以用来管理不同层次之间的数据传输和协议转换。\n框架和库：在某些框架和库的设计中，中介者模式可以用来提供组件之间的通信机制，例如MVC模式中的控制器（C）就充当了中介者的角色。\n代码示例：在C++中实现中介者模式通常涉及定义一个中介者接口和多个同事类，中介者负责协调同事类之间的交互。具体的中介者类实现了中介者接口，并包含了同事类之间的协调逻辑。\n中介者模式的优点包括减少了组件之间的耦合，使得组件可以独立地变化和重用，同时也简化了组件之间的通信逻辑。然而，过度使用中介者模式可能会导致中介者本身变得复杂且难以维护，因此需要在设计时权衡其利弊。\n4.如何判断一个系统是否适合使用中介者模式？ 判断一个系统是否适合使用中介者模式，可以考虑以下几个关键点：\n组件之间的耦合度高：如果系统中的多个组件相互依赖，形成了复杂的网状结构，这通常意味着它们之间存在过多的直接交互。使用中介者模式可以减少这种直接依赖，降低耦合度。\n需要集中控制：当你需要对组件之间的交互进行集中控制和协调时，中介者模式非常有用。中介者可以控制消息的流向，以及何时、如何响应特定的事件。\n通信逻辑复杂：如果组件之间的通信逻辑非常复杂，或者经常变化，将这些逻辑集中到中介者中可以简化组件的设计，使得组件不需要了解其他组件的内部实现。\n系统需要良好的可扩展性：如果你希望系统能够容易地扩展新功能，中介者模式可以帮助你通过引入新的中介者或修改现有中介者来实现，而不需要对现有组件进行大量修改。\n存在多对多的交互：在系统中，如果多个组件之间存在多对多的交互关系，这种复杂的交互关系难以管理和维护，使用中介者模式可以简化这些关系。\n需要重用组件：如果你希望在不同的上下文中重用组件，而这些组件在不同的环境中需要与其他不同的组件交互，中介者模式可以提供一种灵活的方式来适应不同的交互需求。\n需要解耦组件：如果你需要解耦组件之间的交互，以便单独开发和测试，中介者模式可以将交互逻辑从组件中分离出来，使得组件更加独立。\n存在跨组件的业务逻辑：有时候，某些业务逻辑跨越了多个组件，这些逻辑不适合放在任何一个组件内部。这时，中介者可以作为一个合适的地点来实现这些跨组件的业务逻辑。\n需要统一的接口：当需要为一组组件提供统一的交互接口时，中介者模式可以定义一个中介者接口，组件通过这个接口与中介者交互，而不是直接与其他组件交互。\n系统重构：在系统重构过程中，如果发现组件之间的交互导致了代码的重复或难以维护，引入中介者模式可以帮助清理这些交互，提高系统的可维护性。\n总的来说，如果你的系统存在上述情况之一或多个，那么使用中介者模式可能会带来好处。然而，也要注意不要过度使用中介者模式，因为一个过于复杂的中介者可能会成为系统中的瓶颈，导致新的维护问题。\n5.中介者模式在设计时有哪些常见的问题和挑战？ 在设计中介者模式时，可能会遇到以下常见问题和挑战：\n中介者职责过重：随着系统的扩展，中介者可能会包含过多的逻辑，导致它变得复杂和难以管理。这可能违反单一职责原则，使得中介者本身成为系统中的瓶颈。\n难以维护和扩展：中介者模式可能会导致中介者类变得庞大，难以维护。当需要添加新的行为或功能时，可能需要对中介者进行大量的修改，这增加了系统的脆弱性。\n性能问题：中介者模式可能会引入额外的间接层，这可能会影响系统的性能。在高性能要求的场景中，这可能是一个考虑因素。\n过度使用：在一些简单的系统中，或者组件之间的交互本身就不多的情况下，使用中介者模式可能会过度设计，增加不必要的复杂性。\n中介者与同事类的耦合：虽然中介者模式旨在减少耦合，但中介者与同事类之间仍然存在一定的耦合。中介者需要知道所有同事类的引用，这可能会限制中介者的通用性。\n同事类之间的通信：在某些情况下，同事类之间可能需要直接通信，而不是通过中介者。这种直接通信可能会绕过中介者，从而破坏了中介者模式的设计原则。\n中介者模式与其他模式的冲突：在某些情况下，中介者模式可能与其他设计模式（如观察者模式）存在冲突。需要仔细考虑如何在系统中整合不同的模式。\n中介者模式的适用性：在一些场景下，使用其他模式（如命令模式、策略模式）可能比中介者模式更合适。需要根据具体的业务需求和系统结构来选择合适的设计模式。\n为了解决这些问题和挑战，可以采取以下措施：\n确保中介者保持简洁，只包含必要的逻辑。 将中介者的责任划分为更小的单元，可能通过引入多个中介者来实现。 优化中介者的设计，确保它不会成为性能瓶颈。 仔细评估是否需要使用中介者模式，避免在不适当的情况下使用。 设计中介者和同事类的接口，确保它们之间的耦合最小化。 明确同事类之间的通信规则，确保所有通信都通过中介者进行。 在设计初期就考虑可能的扩展和维护需求，使系统更易于未来的修改。 通过这些方法，可以在设计中介者模式时避免常见的问题和挑战，从而创建一个更加健壮和可维护的系统。\n6.中介者模式示例 cpp 下面是一个使用C++实现的中介者模式示例。这个例子模拟了一个简单的聊天系统，其中ChatMediator是中介者，User是同事类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;algorithm\u0026gt; // 抽象中介者 class ChatMediator { public: virtual void sendMessage(const std::string\u0026amp; msg, User* user) = 0; virtual void addUser(User* user) = 0; virtual void removeUser(User* user) = 0; }; // 具体中介者 class ChatRoom : public ChatMediator { private: std::list\u0026lt;User*\u0026gt; users; public: void sendMessage(const std::string\u0026amp; msg, User* user) override { for (auto* u : users) { if (u != user) { u-\u0026gt;receive(msg); } } } void addUser(User* user) override { users.push_back(user); } void removeUser(User* user) override { users.remove(user); } }; // 抽象同事类 class User { protected: std::string name; ChatMediator* mediator; public: User(const std::string\u0026amp; name, ChatMediator* mediator) : name(name), mediator(mediator) {} virtual void send(const std::string\u0026amp; msg) = 0; virtual void receive(const std::string\u0026amp; msg) = 0; }; // 具体同事类 class UserImpl : public User { public: UserImpl(const std::string\u0026amp; name, ChatMediator* mediator) : User(name, mediator) {} void send(const std::string\u0026amp; msg) override { mediator-\u0026gt;sendMessage(msg, this); } void receive(const std::string\u0026amp; msg) override { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; received: \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; } }; int main() { ChatRoom chatRoom; UserImpl* user1 = new UserImpl(\u0026#34;Alice\u0026#34;, \u0026amp;chatRoom); UserImpl* user2 = new UserImpl(\u0026#34;Bob\u0026#34;, \u0026amp;chatRoom); chatRoom.addUser(user1); chatRoom.addUser(user2); user1-\u0026gt;send(\u0026#34;Hi Bob, how are you?\u0026#34;); user2-\u0026gt;send(\u0026#34;Hi Alice, I\u0026#39;m good!\u0026#34;); chatRoom.removeUser(user1); delete user1; delete user2; return 0; } 在这个例子中，ChatMediator是一个抽象类，定义了发送消息的方法。ChatRoom是ChatMediator的具体实现，它管理一个用户列表，并负责将消息从一个用户转发给其他用户。\nUser是一个抽象类，定义了发送和接收消息的接口。UserImpl是User的具体实现，它通过中介者发送消息，并接收来自其他用户的消息。\n在main函数中，我们创建了一个ChatRoom实例和两个UserImpl实例，并将用户添加到聊天室中。然后，每个用户通过中介者发送消息。最后，我们移除了一个用户。\n这个例子展示了中介者模式如何帮助减少类之间的耦合，使得系统的各部分更加模块化和易于维护。\n7.在C++中，有哪些工具或库可以帮助我更好地实现和测试设计模式？ 在C++中，实现和测试设计模式时，有几个工具和库可以帮助你更高效地进行开发和测试：\nVisual Studio：如果你使用的是Visual Studio，它提供了对C++单元测试的支持，包括Microsoft 单元测试框架、Google Test、Boost.Test和CTest。这些框架都可以帮助你在实现设计模式时编写和运行单元测试。Visual Studio还支持测试适配器，可以将单元测试与“测试资源管理器”窗口集成，方便管理和查看测试结果 。\nGoogle Test：Google Test是一个由Google开发的C++单元测试框架，它提供了丰富的断言和测试组织机制，可以帮助你编写可读性好、易于维护的测试代码。\nBoost.Test：Boost.Test是Boost库的一部分，它是一个跨平台的测试框架，提供了丰富的测试工具和测试组织方式。\nCMock：CMock是一个轻量级的C/C++单元测试框架，它特别适合用于模拟对象和依赖注入，有助于在测试设计模式时进行解耦。\nLoki：Loki是一个C++库，它提供了对一些设计模式的实现，如单例模式、工厂模式等。使用Loki库可以帮助你更容易地实现这些设计模式，并且它使用了大量的模板技巧，可以提高你的代码复用性 。\ngmock：gmock是一个由Google开发的C++模拟框架，它可以与Google Test一起使用，为测试提供模拟对象和依赖注入功能，有助于在测试设计模式时进行解耦和模拟复杂的行为 。\nC++标准库：C++标准库提供了许多有用的组件，如智能指针、容器和算法，它们可以帮助你实现设计模式时减少代码的复杂性。\n版本控制系统：如Git，可以帮助你管理代码变更，特别是在多人协作和代码重构时。\n集成开发环境（IDE）：如CLion、Eclipse CDT等，它们提供了代码提示、静态分析和调试工具，有助于提高代码质量和开发效率。\n使用这些工具和库，你可以更容易地实现和测试设计模式，确保代码的质量和可维护性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-mediator-pattern/","title":"design pattern Mediator Pattern"},{"content":"设计模式-备忘录模式-Memento Pattern [TOC]\nOverview 备忘录模式（Memento Pattern）是一种行为型设计模式 它允许在不破坏对象封装性的前提下，捕获并保存一个对象的内部状态，以便在需要时可以恢复到之前的状态 这种模式通常用于实现撤销（Undo）和重做（Redo）功能 1.备忘录模式（Memento Pattern） 备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在不破坏对象封装性的前提下，捕获并保存一个对象的内部状态，以便在需要时可以恢复到之前的状态。这种模式通常用于实现撤销（Undo）和重做（Redo）功能。\n在C++中实现备忘录模式，通常涉及三个主要角色：\n备忘录（Memento）：负责存储发起人对象的内部状态，并保护这些状态不被外界直接访问。 发起人（Originator）：创建一个备忘录，用以记录当前时刻它的内部状态，并能够使用备忘录恢复内部状态。 管理者（Caretaker）：负责保存备忘录，但不会对备忘录的内容进行操作或检查。 一个简单的C++实现示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; // 备忘录类 class Memento { private: std::string state; // 只有Originator可以访问 friend class Originator; public: Memento(const std::string\u0026amp; state) : state(state) {} std::string getState() const { return state; } }; // 发起人类 class Originator { private: std::string state; public: void setState(const std::string\u0026amp; state) { this-\u0026gt;state = state; } std::string getState() const { return state; } Memento* createMemento() { return new Memento(state); } void restore(Memento* memento) { state = memento-\u0026gt;getState(); } }; // 管理者类 class Caretaker { private: std::vector\u0026lt;Memento*\u0026gt; mementos; public: void addMemento(Memento* memento) { mementos.push_back(memento); } Memento* getMemento(int index) { if (index \u0026lt; mementos.size()) { return mementos[index]; } return nullptr; } }; int main() { Originator originator; originator.setState(\u0026#34;State 1\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;Current State: \u0026#34; \u0026lt;\u0026lt; originator.getState() \u0026lt;\u0026lt; std::endl; Caretaker caretaker; // 保存状态 Memento* memento = originator.createMemento(); caretaker.addMemento(memento); // 改变状态 originator.setState(\u0026#34;State 2\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;New State: \u0026#34; \u0026lt;\u0026lt; originator.getState() \u0026lt;\u0026lt; std::endl; // 恢复状态 originator.restore(caretaker.getMemento(0)); std::cout \u0026lt;\u0026lt; \u0026#34;Restored State: \u0026#34; \u0026lt;\u0026lt; originator.getState() \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，Originator对象的状态可以通过Caretaker对象保存和恢复。Memento对象存储了Originator的状态，并且只能被Originator访问和修改。\n备忘录模式的优点包括提供了一种可以恢复状态的机制，实现了内部状态的封装，并且简化了发起人类的设计。然而，它的缺点是可能会消耗较多的资源，尤其是当保存的内部状态信息过多或者特别频繁时。\n在实际应用中，备忘录模式可以用于实现游戏存档、软件设置恢复、文本编辑器的撤销和重做功能等场景。开发者可以根据具体需求选择合适的设计模式，以提高代码的可维护性和可扩展性。\n2.备忘录模式优缺点 优点 你可以在不破坏对象封装情况的前提下创建对象状态快照。 你可以通过让负责人维护原发器状态历史记录来简化原发器代码。 缺点 如果客户端过于频繁地创建备忘录， 程序将消耗大量内存。 负责人必须完整跟踪原发器的生命周期， 这样才能销毁弃用的备忘录。 绝大部分动态编程语言 （例如 PHP、 Python 和 JavaScript） 不能确保备忘录中的状态不被修改。 备忘录模式（Memento Pattern）是一种行为型设计模式，它允许在不破坏对象封装性的前提下，捕获并保存一个对象的内部状态，以便在需要时可以恢复到之前的状态。以下是备忘录模式的优缺点：\n2.1.优点 撤销功能的实现：备忘录模式提供了一种简单而有效的撤销和恢复机制，使得用户可以轻松地回退到对象的某个历史状态。\n封装性的保护：通过备忘录模式，对象的内部状态可以被外部保存和恢复，而不需要暴露对象的内部细节，这有助于保护对象的封装性。\n状态的完整性：备忘录模式可以保存对象的完整状态，而不仅仅是部分状态，这有助于在需要时恢复对象的完整状态。\n解耦性：备忘录模式可以将状态的保存和恢复逻辑从业务逻辑中分离出来，使得业务逻辑更加清晰，同时也便于状态管理。\n灵活性：可以灵活地选择保存哪些状态，以及何时保存和恢复状态，这为应用程序提供了更多的灵活性。\n2.2.缺点 资源消耗：如果频繁地保存状态，或者保存的状态信息较多，可能会占用较多的内存资源。\n复杂性增加：引入备忘录模式可能会增加系统的复杂性，需要额外的类和对象来管理状态的保存和恢复。\n管理难度：随着备忘录对象数量的增加，管理和维护这些对象可能会变得复杂，尤其是需要考虑如何有效地存储和检索这些对象。\n可能的滥用：如果不当使用备忘录模式，可能会导致系统中存在大量的状态快照，这可能会对性能产生负面影响。\n线程安全问题：在多线程环境中，如果多个线程同时操作同一个对象的状态，可能会引入线程安全问题。\n状态泄露：如果备忘录对象没有被正确管理，可能会导致状态信息泄露，或者在不适当的时候被修改。\n恢复的局限性：备忘录模式通常只能实现线性的撤销和恢复，即只能按照保存状态的顺序进行撤销和恢复，这在某些复杂的应用场景中可能不够灵活。\n在使用备忘录模式时，应该权衡这些优缺点，并根据具体的应用场景和需求来决定是否采用这种模式。\n3.备忘录模式在实际开发中有哪些常见的应用场景？ 备忘录模式在实际开发中有多种应用场景，以下是一些常见的例子：\n文本编辑器中的撤销/重做功能：在文本编辑器中，每次用户进行编辑操作时，系统可以创建一个包含当前文档状态的备忘录对象。如果用户想要撤销操作，系统可以使用最近的备忘录对象恢复到之前的状态。这种场景下，文档编辑器是发起人（Originator），编辑操作产生的状态快照是备忘录（Memento），而管理这些快照的历史列表则是管理者（Caretaker）。\n游戏存档和回档：在游戏开发中，备忘录模式可以用来保存玩家的游戏状态，包括角色位置、生命值、拥有的物品等。这样，玩家可以随时加载之前的存档，继续游戏。\n数据库事务管理：在数据库系统中，可以利用备忘录模式来实现事务的回滚和恢复。每次事务开始前，系统可以创建一个包含数据库当前状态的快照。如果事务失败或用户取消操作，系统可以使用这个快照恢复数据库到事务开始前的状态。\n软件版本控制：在版本控制系统（如Git）中，每次提交可以看作是一个备忘录，记录了代码在特定时刻的状态。开发者可以根据需要回退到任何历史提交，或者在不同分支之间切换。\n图形界面的撤销操作：在图形设计软件或图像编辑软件中，用户的操作（如移动图层、改变颜色等）可以被记录下来，形成一系列的备忘录。用户可以通过撤销功能回到之前的编辑状态。\n配置管理：在系统配置管理中，每次配置更改都可以创建一个备忘录，以便在出现问题时能够快速恢复到更改之前的状态。\n备忘录模式的优点包括提供了一种可以恢复状态的机制，实现了内部状态的封装，并且简化了发起人类的设计。然而，它的缺点是可能会消耗较多的资源，尤其是当保存的内部状态信息过多或者特别频繁时。\n在设计备忘录模式时，需要考虑如何有效地管理备忘录对象的生命周期，以避免内存泄漏，并且确保系统的资源消耗在可接受的范围内。同时，还需要确保备忘录对象的封装性，避免暴露发起人对象的内部实现细节。\n4.如何优化备忘录模式以减少资源消耗？ 要优化备忘录模式以减少资源消耗，可以考虑以下几种策略：\n只备份必要的状态信息：而不是备份整个对象的状态。这样可以减少存储空间的需求。例如，在文本编辑器中，可以只存储文本的增量更改，而不是整个文档的副本。\n使用原型模式：结合使用原型模式可以避免为每个状态创建全新的备忘录对象。如果对象的状态大部分是相同的，可以通过克隆来复制大部分状态，然后只记录变化的部分。\n增量备份：而不是每次都进行全量备份。增量备份只记录自上次备份以来发生变化的部分，这样可以大大减少所需的存储空间和时间。\n限制备忘录的数量：例如，只保存最近的一定数量的备忘录对象，或者在达到最大数量时覆盖旧的备忘录。\n使用更高效的数据结构：例如，使用链表而不是数组来存储备忘录对象，这样可以减少内存的占用和提高访问效率。\n压缩技术：对备忘录对象进行压缩存储，当需要恢复时再进行解压。\n合理设置备忘录的过期时间：对于某些应用场景，可以为备忘录设置一个过期时间，过期后自动删除，以节省空间。\n考虑使用数据库事务：对于需要持久化状态的场景，可以使用数据库事务来管理状态的保存和恢复，这样可以利用数据库的优化和存储机制。\n事件溯源：对于需要详细历史记录的系统，事件溯源模式可以记录所有状态变化，允许重放和撤销操作，而不是保存每个状态的快照。\n通过这些方法，可以在保持备忘录模式优点的同时，减少对系统资源的消耗。\n5.备忘录模式在多线程环境下如何保证线程安全？ 在多线程环境下，确保备忘录模式的线程安全是一个重要的考虑因素。以下是一些策略来实现线程安全的备忘录模式：\n使用同步机制：在备忘录的创建和恢复过程中，可以使用互斥锁（如std::mutex）来确保只有一个线程可以修改或访问备忘录的状态。这样可以防止多个线程同时对同一个备忘录对象进行操作，从而避免竞态条件。\n线程局部存储：可以使用线程局部存储（Thread-Local Storage，TLS）来存储备忘录对象，这样每个线程都有自己的备忘录副本，从而避免了线程间的直接交互和数据竞争。\n不可变备忘录对象：设计备忘录对象为不可变对象，一旦创建就不允许修改。这样，即使多个线程访问同一个备忘录对象，也不会引起线程安全问题，因为状态不可变。\n使用原子操作：对于简单的状态信息，可以使用原子操作来确保状态的保存和恢复是原子性的，从而避免在多线程环境下的同步问题。\n限制备忘录的共享：尽量减少备忘录对象在多个线程之间的共享。如果必须共享，确保访问控制得当，例如通过读写锁（std::shared_mutex）来允许多个线程同时读取，但写入时需要独占访问。\n状态的快照和恢复：在多线程环境中，当需要保存或恢复状态时，确保状态的快照和恢复操作是原子的，或者在操作期间禁止其他线程的访问。\n避免状态泄露：在多线程环境中，确保备忘录模式的使用不会导致一个线程的状态被另一个线程错误地访问或修改。\n资源管理：合理管理备忘录对象的生命周期，确保在不再需要时及时释放资源，避免内存泄漏。\n通过上述策略，可以在多线程环境中有效地使用备忘录模式，同时确保线程安全和数据一致性。在实际应用中，应根据具体的应用场景和性能要求来选择合适的同步策略。\n6.在多线程环境下，如何避免备忘录模式中的死锁问题？ 在多线程环境下，避免备忘录模式中的死锁问题可以采取以下措施：\n锁顺序：确保所有线程在获取多个锁时都按照相同的顺序进行，这样可以避免循环等待条件，这是死锁的四个必要条件之一 。\n锁超时：在尝试获取锁时使用超时机制，如果在指定的时间内无法获取锁，则释放已持有的锁并重试，这有助于避免死锁 。\n最小化锁持有时间：尽量减少持有锁的时间，例如，在持有锁的代码块中只执行必要的操作，这样可以减少锁竞争的机会 。\n避免在持有锁时调用外部代码：因为外部代码可能会尝试获取其他锁，这可能导致死锁 。\n使用更高级的同步机制：例如，使用std::atomic操作来避免锁的使用，或者使用条件变量和信号量等，这些机制可以提供更细粒度的控制 。\n死锁检测和恢复：实现死锁检测算法，如资源分配图或等待图，定期检查是否存在死锁，并采取恢复措施，如终止线程或资源抢占 。\n使用不可变备忘录：如果备忘录对象是不可变的，那么它们不需要同步，因为它们的状态在创建后不会改变，这可以减少锁的需求 。\n使用线程局部存储：对于备忘录对象，可以使用线程局部存储来确保每个线程都有其自己的副本，从而避免线程间的共享和竞争 。\n通过这些策略，可以在多线程环境中有效地使用备忘录模式，同时避免死锁问题。\n7.如何实现备忘录模式的增量备份，以减少存储空间的占用？ 要实现备忘录模式的增量备份以减少存储空间的占用，可以采取以下策略：\n只备份变化的状态：而不是每次备份整个对象的状态。这样可以减少存储空间的需求。例如，如果是一个文档编辑器，只需记录自上次备份以来更改的部分，而不是整个文档的内容。\n使用差异算法：在备份时，可以使用差异算法来确定自上次备份以来数据的变化，并仅存储这些差异。\n分层存储：结合使用全量备份和增量备份。全量备份可以在较长的时间间隔内进行一次，而增量备份则频繁进行，只记录自上次备份以来的变化。\n数据压缩：对备份的数据进行压缩，以减少存储空间的占用。可以选择无损压缩算法来确保数据可以完全恢复。\n去重技术：如果系统中存在大量重复数据，可以使用数据去重技术来减少存储空间的占用。\n时间戳和版本控制：为每个备份添加时间戳，并实现版本控制，这样可以根据需要恢复到特定的版本。\n智能备份策略：根据数据的重要性和访问频率来决定备份的频率和详细程度，对于不常访问的数据可以使用更粗粒度的备份策略。\n归档旧状态：对于不再需要频繁访问的历史状态，可以将其归档到成本更低的存储介质上。\n通过上述方法，可以有效地减少备忘录模式在实现状态备份和恢复功能时对存储空间的占用。这些策略的选择和实施应根据具体的应用场景和系统要求来决定。\n8.在实施备忘录模式的增量备份时，有哪些常见的技术挑战？ 在实施备忘录模式的增量备份时，可能会遇到以下技术挑战：\n确定增量数据：需要准确识别自上次备份以来发生变化的数据，这可能涉及到复杂的状态跟踪和变更检测机制。\n处理大量数据：对于大型对象或系统，增量备份可能会产生大量的数据，需要有效的数据压缩和存储策略来优化性能和存储空间。\n保持数据一致性：在备份过程中，需要确保数据的一致性，避免在备份过程中数据发生变化导致备份信息不准确。\n管理备份历史：随着时间的推移，备份历史会不断增长，需要有效的策略来管理这些历史记录，包括存储、检索和删除旧的备份。\n并发控制：在多线程或多用户环境中，需要确保备份过程不会受到并发修改的影响，可能需要使用锁或其他同步机制。\n恢复机制：实现一个可靠的恢复机制，以便可以从增量备份中恢复到任意状态，这可能涉及到合并多个增量备份以及与全量备份的结合。\n资源消耗：备份过程可能会占用大量的系统资源，如CPU、内存和I/O，需要优化备份算法以减少对系统性能的影响。\n错误处理：在备份和恢复过程中，需要有健壮的错误处理机制，以应对可能出现的故障和异常情况。\n安全性：备份数据可能包含敏感信息，需要确保备份数据的安全性，防止未授权访问和数据泄露。\n跨平台和环境的兼容性：在不同的系统和平台之间进行备份和恢复时，需要确保备份数据的兼容性和一致性。\n为了应对这些挑战，开发者可能需要结合多种技术和策略，如使用事件驱动的方法来捕捉变更、采用高效的数据序列化和压缩算法、实现智能的备份历史管理策略等。同时，也需要对系统进行充分的测试，以确保备份和恢复功能的可靠性和有效性。\n9.如何优化备忘录模式的增量备份算法以减少资源消耗？ 在实施备忘录模式的增量备份时，要减少资源消耗，可以采取以下优化策略：\n增量备份而非全量备份：仅备份自上次备份以来发生变化的数据，而不是每次都备份整个对象的状态。这大大减少了需要备份的数据量，从而显著提升了备份的速度，并减少了存储资源的消耗。\n数据压缩：对备份的数据进行压缩，以减少存储空间的占用。可以选择无损压缩算法来确保数据可以完全恢复，同时减少存储和传输数据所需的资源。\n智能缓冲区管理：使用缓冲区来暂存需要插入或更新的数据，等待缓冲区的数据量较多时，再进行批量插入或批量更新，这样可以提高效率。\n避免频繁的状态保存：设计一个合理的触发备份的策略，例如，只有当对象状态发生显著变化时才创建新的备忘录，而不是对每次微小变化都进行备份。\n使用哈希摘要：在备份之前，对数据进行哈希摘要，只有当哈希值发生变化时才进行备份，这样可以避免不必要的备份操作。\n利用多线程或异步处理：在备份过程中，利用多线程或异步处理来并行处理数据，这样可以提高备份的速度，减少等待时间。\n备份数据去重：在备份前对数据进行去重处理，确保备份集中没有重复的数据块，这样可以减少存储空间的占用。\n定期清理旧的备忘录：定期清理不再需要的备忘录对象，释放资源，避免无谓的资源占用。\n选择合适的备份工具和技术：根据具体的应用场景和需求，选择最合适的备份工具和技术，以确保备份的效率和资源的合理利用。\n通过上述策略，可以在保证数据安全的同时，有效地减少备忘录模式在实现增量备份时对资源的消耗。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-memento-pattern/","title":"design pattern Memento Pattern"},{"content":"设计模式-观察者模式-Observer Pattern [TOC]\nOverview 观察者模式（Observer Pattern）是一种行为型设计模式 它定义了对象之间的一对多依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都会得到通知并自动更新 1.观察者模式（Observer Pattern） 观察者模式（Observer Pattern）是一种行为型设计模式，它定义了对象之间的一对多依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。这种模式通常用于实现分布式事件处理系统。\n在C++中实现观察者模式，通常需要定义观察者（Observer）和被观察者（Subject）的接口。以下是观察者模式的一个简单实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;algorithm\u0026gt; // 观察者基类 class Observer { public: virtual ~Observer() {} virtual void update(int state) = 0; }; // 被观察者基类 class Subject { public: virtual ~Subject() {} virtual void attach(Observer* observer) { observers.push_back(observer); } virtual void detach(Observer* observer) { observers.remove(observer); } virtual void notify() { for (auto* observer : observers) { observer-\u0026gt;update(state); } } protected: std::list\u0026lt;Observer*\u0026gt; observers; int state; }; // 具体观察者 class ConcreteObserver : public Observer { public: void update(int state) override { std::cout \u0026lt;\u0026lt; \u0026#34;Observer: Subject\u0026#39;s state changed to \u0026#34; \u0026lt;\u0026lt; state \u0026lt;\u0026lt; std::endl; } }; // 具体被观察者 class ConcreteSubject : public Subject { public: void setState(int newState) { state = newState; notify(); } }; int main() { ConcreteSubject subject; ConcreteObserver observerA; ConcreteObserver observerB; subject.attach(\u0026amp;observerA); subject.attach(\u0026amp;observerB); subject.setState(1); // 通知所有观察者 subject.detach(\u0026amp;observerA); subject.setState(2); // 通知所有观察者 return 0; } 在这个例子中，Subject 类维护了一个观察者列表，并提供了 attach 和 detach 方法来添加或移除观察者。当被观察者的状态发生变化时，通过 notify 方法通知所有观察者。\nConcreteSubject 是具体的被观察者，它继承自 Subject 类，并实现了 setState 方法来改变状态，并通知观察者。\nObserver 是观察者的基类，它定义了一个 update 方法，该方法将被所有具体观察者实现。\nConcreteObserver 是具体的观察者，它实现了 update 方法，以响应被观察者状态的变化。\n在 main 函数中，我们创建了一个 ConcreteSubject 对象和两个 ConcreteObserver 对象，并将观察者附加到被观察者上。然后，我们改变了被观察者的状态，这导致所有观察者都得到了通知。之后，我们从被观察者中移除了一个观察者，并再次改变了状态，以演示观察者列表的更新。\n观察者模式的优点包括实现了观察者和被观察者之间的解耦，增加了程序的可扩展性，并且可以动态地添加或移除观察者。缺点是如果观察者非常多，通知的开销可能会很大，而且如果被观察者的状态变化非常频繁，可能会导致性能问题。\n2.观察者模式优缺点 优点 开闭原则。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。 你可以在运行时建立对象之间的联系。 缺点 订阅者的通知顺序是随机的。 观察者模式（Observer Pattern）的优缺点如下：\n2.1.优点 解耦：观察者模式能够将被观察者（Subject）和观察者（Observer）解耦，使得被观察者的改变不会直接影响到观察者，两者之间的依赖关系降低。\n扩展性：新的观察者可以在不修改被观察者代码的情况下被添加到系统中，提高了系统的可扩展性。\n灵活性：观察者模式允许观察者对象对被观察者的状态变化做出反应，这使得系统可以灵活地响应状态变化。\n广播通信：观察者模式支持广播通信，即被观察者可以同时通知多个观察者对象。\n可定制响应：不同的观察者可以对相同的事件做出不同的响应，增加了系统的灵活性。\n松散关联：观察者和被观察者之间的松散关联关系使得在系统中添加新的观察者或被观察者变得容易，而不需要修改现有的代码。\n2.2.缺点 循环依赖：在实现观察者模式时，如果不当心，可能会导致循环依赖的问题，特别是当观察者和被观察者相互持有对方的引用时。\n内存泄漏：如果观察者和被观察者之间的引用关系没有正确管理，可能会导致内存泄漏。例如，如果被观察者持有观察者的强引用，而观察者又没有正确地从被观察者列表中移除自己，可能会导致无法释放内存。\n性能开销：当有大量的观察者时，通知所有观察者可能会带来性能开销，尤其是在被观察者状态变化频繁的情况下。\n顺序依赖：在某些情况下，观察者的更新顺序可能会影响系统的正确性，这需要在设计时仔细考虑。\n过度使用：在一些简单的场景中，过度使用观察者模式可能会增加不必要的复杂性。\n错误处理：在观察者模式中，如果一个观察者在更新时发生错误，可能会影响到其他观察者的更新，这需要在设计时考虑错误处理机制。\n通知的一致性：确保所有观察者都能接收到通知，并且按照预期的顺序接收通知，可能是一个挑战。\n在使用观察者模式时，应该权衡这些优缺点，并根据具体的应用场景和需求来决定是否采用这种模式。\n3.观察者模式在实际开发中有哪些常见的应用场景？ 观察者模式在实际开发中有许多应用场景，它主要用于实现事件处理和通知机制。以下是一些典型的应用实例：\n事件处理系统：在图形用户界面（GUI）编程中，观察者模式用于处理用户的行为，如点击、滚动、按键等事件。当用户执行这些操作时，系统会通知所有注册的观察者（如按钮、文本框等）。\n游戏开发：在游戏开发中，观察者模式可以用来实现游戏状态的监听和响应。例如，当玩家的分数发生变化时，游戏可以通知得分牌、排行榜等观察者对象。\n模型-视图-控制器（MVC）框架：在MVC架构中，观察者模式用于实现视图（View）和控制器（Controller）对模型（Model）的依赖关系。当模型数据发生变化时，自动更新视图。\n软件架构中的发布-订阅系统：在大型软件系统中，观察者模式可以实现跨组件的通信。组件可以注册为观察者，订阅感兴趣的事件，当事件发生时，系统会通知所有订阅者。\n数据绑定：在现代编程框架中，观察者模式用于实现数据绑定。当数据模型发生变化时，自动更新界面元素，如输入框、列表等。\n通知系统：在需要实现通知和消息传递的系统中，观察者模式可以用来通知用户或系统组件关于状态变化的信息，如电子邮件客户端中的新邮件通知。\n股票价格监控：在金融应用中，观察者模式可以用来监控股票价格的变化。当股票价格达到特定阈值时，系统可以通知投资者或执行自动交易。\n缓存系统：在缓存系统中，观察者模式可以用来监听数据的变更，当数据更新时，缓存可以同步更新或失效。\n实时协作编辑：在多人协作编辑文档的应用程序中，观察者模式可以用来同步不同用户对文档的更改。\n硬件驱动程序：在操作系统中，观察者模式可以用来监听硬件状态的变化，如电池电量、网络连接状态等，并在状态变化时通知应用程序。\n观察者模式的优点在于它提供了一种松耦合的方式来实现组件之间的通信，使得系统更加灵活和可维护。然而，它也可能导致系统复杂度增加，特别是在有大量观察者和事件时，管理和维护这些关系可能会变得复杂。\n3.在实现观察者模式时，如何确保被观察者和观察者之间的通信是线程安全的？ 在实现观察者模式时，确保线程安全是至关重要的，特别是在多线程环境中。以下是一些确保线程安全的策略：\n使用同步方法：在被观察者（Subject）中，添加、删除观察者（Observer）和通知观察者的方法可以使用synchronized关键字或在C++中使用互斥锁（如std::mutex）来同步，确保同一时间只有一个线程可以执行这些操作。这种方法简单易行，但在高并发环境下可能会成为性能瓶颈。\n使用读写锁：如果读操作远多于写操作，可以使用读写锁（如C++中的std::shared_mutex）来允许多个线程同时读取观察者列表，但在修改观察者列表时需要独占访问。这样可以在读多写少的场景下提高性能。\n使用线程安全容器：一些编程语言提供了线程安全的容器，如Java的ConcurrentHashMap或C++的std::vector（通过适当的同步机制）。使用这些容器来存储观察者列表可以减少自己管理同步的复杂性。\n避免在通知过程中修改观察者列表：在通知观察者的过程中，避免添加或删除观察者，因为这可能会导致死锁或不一致的状态。可以在通知之前创建观察者列表的副本，然后对副本进行迭代。\n使用条件变量：在某些情况下，可以使用条件变量（如C++中的std::condition_variable）来协调观察者和被观察者之间的线程。例如，当被观察者状态发生变化时，可以使用条件变量来通知等待的观察者。\n使用不可变对象：如果可能，使观察者传递的状态不可变，这样即使在多线程环境中，也不需要额外的同步措施来保护状态。\n使用锁分离技术：对于复杂的数据结构，可以使用锁分离技术，为数据结构的不同部分使用不同的锁，以减少锁竞争。\n使用原子操作：对于简单的状态更新，可以使用原子操作来确保操作的原子性，而不需要使用重量级的锁。\n每种方法都有其适用场景和潜在的性能影响。在实际应用中，应根据具体的并发需求和性能目标来选择合适的线程安全策略。\n4.在实现观察者模式时，如何确保被观察者和观察者之间的通信是线程安全的？ 在实现观察者模式时，确保线程安全是至关重要的，特别是在多线程环境中。以下是一些确保线程安全的策略：\n使用同步方法：在被观察者（Subject）中，添加、删除观察者（Observer）和通知观察者的方法可以使用synchronized关键字或在C++中使用互斥锁（如std::mutex）来同步，确保同一时间只有一个线程可以执行这些操作。这种方法简单易行，但在高并发环境下可能会成为性能瓶颈。\n使用读写锁：如果读操作远多于写操作，可以使用读写锁（如C++中的std::shared_mutex）来允许多个线程同时读取观察者列表，但在修改观察者列表时需要独占访问。这样可以在读多写少的场景下提高性能。\n使用线程安全容器：一些编程语言提供了线程安全的容器，如Java的ConcurrentHashMap或C++的std::vector（通过适当的同步机制）。使用这些容器来存储观察者列表可以减少自己管理同步的复杂性。\n避免在通知过程中修改观察者列表：在通知观察者的过程中，避免添加或删除观察者，因为这可能会导致死锁或不一致的状态。可以在通知之前创建观察者列表的副本，然后对副本进行迭代。\n使用条件变量：在某些情况下，可以使用条件变量（如C++中的std::condition_variable）来协调观察者和被观察者之间的线程。例如，当被观察者状态发生变化时，可以使用条件变量来通知等待的观察者。\n使用不可变对象：如果可能，使观察者传递的状态不可变，这样即使在多线程环境中，也不需要额外的同步措施来保护状态。\n使用锁分离技术：对于复杂的数据结构，可以使用锁分离技术，为数据结构的不同部分使用不同的锁，以减少锁竞争。\n使用原子操作：对于简单的状态更新，可以使用原子操作来确保操作的原子性，而不需要使用重量级的锁。\n每种方法都有其适用场景和潜在的性能影响。在实际应用中，应根据具体的并发需求和性能目标来选择合适的线程安全策略。\n5.在多线程环境下，如何避免观察者模式中的死锁问题？ 在多线程环境下实现观察者模式时，要避免死锁问题，可以采取以下措施：\n锁顺序：确保所有线程在获取多个锁时都按照相同的顺序进行，这样可以避免循环等待条件，这是死锁的四个必要条件之一 。\n锁超时：在尝试获取锁时使用超时机制，如果在指定的时间内无法获取锁，则释放已持有的锁并重试，这有助于避免死锁 。\n最小化锁持有时间：尽量减少持有锁的时间，例如，在持有锁的代码块中只执行必要的操作，这样可以减少锁竞争的机会 。\n避免在持有锁时调用外部代码：因为外部代码可能会尝试获取其他锁，这可能导致死锁 。\n使用不可变备忘录：如果备忘录对象是不可变的，那么它们不需要同步，因为它们的状态在创建后不会改变，这可以减少锁的需求 。\n使用线程局部存储：对于备忘录对象，可以使用线程局部存储来确保每个线程都有其自己的副本，从而避免线程间的共享和竞争 。\n使用条件变量：在某些情况下，可以使用条件变量（如C++中的std::condition_variable）来协调观察者和被观察者之间的线程 。\n避免死锁的策略：包括一次性分配所有资源、可剥夺资源、资源有序分配法等，这些策略可以破坏死锁产生的四个必要条件中的一个或多个 。\n使用死锁检测和解除机制：在系统中实现死锁检测算法，如资源分配图或等待图，定期检查是否存在死锁，并采取恢复措施，如终止线程或资源抢占 。\n避免嵌套锁：尽量避免在持有一个锁的情况下去请求另一个锁，因为这种情况很容易导致死锁 。\n通过上述措施，可以在多线程环境中有效地使用观察者模式，同时避免死锁问题，从而提高系统的稳定性和可维护性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-observer-pattern/","title":"design pattern Observer Pattern"},{"content":"设计模式-原型模式 Prototype Pattern [TOC]\nOverview 原型模式（Prototype Pattern）是一种创建型设计模式 它允许你通过复制现有的对象来创建新的实例，而不是通过新建的方式来构造 这种模式特别适用于那些创建过程复杂、资源消耗大或者创建后需要快速复制的场景 1.原型模式 Prototype Pattern 原型模式（Prototype Pattern）是一种创建型设计模式，它允许你通过复制现有的对象来创建新的实例，而不是通过新建的方式来构造。这种模式特别适用于那些创建过程复杂、资源消耗大或者创建后需要快速复制的场景。\n1.1.原型模式的主要角色包括 原型接口（Prototype Interface）：\n声明一个克隆自己的操作，通常是一个Clone方法。 具体原型类（Concrete Prototype）：\n实现原型接口，提供具体的Clone方法来返回对象的副本。 客户端（Client）：\n创建和操作具体原型对象，通过调用Clone方法来复制对象。 1.2.C++实现示例 首先，定义原型接口：\n1 2 3 4 5 6 // Prototype.h class Prototype { public: virtual ~Prototype() {} virtual Prototype* Clone() const = 0; }; 接着，创建具体的原型类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ConcretePrototype.h #include \u0026#34;Prototype.h\u0026#34; class ConcretePrototype : public Prototype { private: std::string value; public: ConcretePrototype(const std::string\u0026amp; val) : value(val) {} ConcretePrototype(const ConcretePrototype\u0026amp; other) : value(other.value) {} Prototype* Clone() const override { return new ConcretePrototype(*this); } // 其他方法... }; 然后，客户端代码使用原型模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // main.cpp #include \u0026#34;ConcretePrototype.h\u0026#34; int main() { ConcretePrototype* original = new ConcretePrototype(\u0026#34;Original Object\u0026#34;); // 复制对象 ConcretePrototype* copy = original-\u0026gt;Clone(); // 使用复制的对象... // ... delete original; // 清理原始对象 delete copy; // 清理复制的对象 return 0; } 1.3.原型模式的应用场景 创建成本高：\n当对象的构造成本很高时，使用原型模式可以通过复制现有对象来降低创建成本。 创建过程复杂：\n如果创建对象的过程非常复杂，涉及多个步骤或者依赖多个外部条件，使用原型模式可以简化创建过程。 对象的初始状态是固定的：\n当需要创建的对象具有固定的初始状态，并且后续需要在此基础上进行修改时，原型模式可以快速提供初始状态。 对象状态容易改变：\n如果对象的状态容易改变，并且需要保存和恢复状态，原型模式可以方便地保存对象的状态快照。 实现对象的动态加载和卸载：\n在需要根据需求动态加载和卸载对象的场景下，原型模式可以快速复制对象，实现对象的动态管理。 实现对象的版本控制：\n当对象有多个版本，并且需要在不同版本之间切换时，原型模式可以方便地复制和维护不同版本的实例。 1.4.注意事项 原型模式要求所有克隆的对象都是可复制的，这可能会限制对象所包含的成员类型（如不能包含指针或引用类型的成员）。 深拷贝和浅拷贝：默认情况下，C++的拷贝构造函数执行的是浅拷贝。如果对象包含指针等需要特殊处理的成员，可能需要实现深拷贝逻辑。 使用原型模式可能会增加内存的消耗，因为需要存储多个对象副本。 2.原型模式优缺点 2.1.优点 你可以克隆对象， 而无需与它们所属的具体类相耦合。 你可以克隆预生成原型， 避免反复运行初始化代码。 你可以更方便地生成复杂对象。 你可以用继承以外的方式来处理复杂对象的不同配置。 2.2.缺点 克隆包含循环引用的复杂对象可能会非常麻烦。 3.原型模式在实际开发中有哪些常见的应用场景？ 原型模式（Prototype Pattern）在实际开发中有许多应用场景，尤其适用于需要快速复制或克隆对象的情况。以下是一些常见的应用实例：\n配置信息的复制：\n在应用程序中，如果存在多个配置实例，它们之间只有少量差异，可以使用原型模式快速复制一个基础配置，然后进行少量修改。 UI元素的复制：\n在图形界面开发中，如果需要创建多个相似的控件或组件，可以使用原型模式复制一个已有的控件，然后进行个性化调整。 对象的快速加载：\n当对象的创建过程非常耗时或占用大量资源时，可以使用原型模式预先创建好对象，然后通过复制来快速提供对象实例。 数据备份：\n在需要对数据进行备份的场景中，可以使用原型模式来复制对象，快速生成数据的副本。 游戏开发中的角色克隆：\n在游戏开发中，如果存在多个相似的角色或敌人，可以使用原型模式来复制一个基础角色，然后根据需要进行调整。 Web开发中的页面元素复制：\n在Web开发中，如果需要在页面上复制多个相似的DOM元素，可以使用原型模式的思想来实现。 报表工具中的数据系列复制：\n在报表工具中，如果用户需要复制一个数据系列并对其进行修改，可以使用原型模式快速复制数据系列。 办公软件中的文档模板：\n在办公软件中，如果提供了多种文档模板，用户可以复制一个模板来创建新文档，然后进行个性化编辑。 数据库中的记录复制：\n在数据库应用中，如果需要复制具有相似属性的记录，可以使用原型模式快速复制记录。 实现对象的版本控制：\n在需要对对象进行版本控制的场景中，可以使用原型模式来复制对象的不同版本。 实现对象的深克隆：\n当对象需要进行深克隆，即完全复制包括对象内部所有引用对象的副本时，可以使用原型模式。 实现对象的池模式：\n在对象池模式中，可以使用原型模式来快速复制对象，实现对象的复用。 实现软件的插件架构：\n在插件架构中，可以使用原型模式来复制插件实例，以支持多个插件的相同行为。 实现算法的参数设置：\n在算法实现中，如果算法参数对象较为复杂，可以使用原型模式复制参数对象，方便算法的多次调用。 使用原型模式可以提高对象创建的效率，降低系统的资源消耗，并有助于实现对象的快速复制和灵活管理。然而，需要注意的是，原型模式可能会增加内存消耗，并且在处理包含引用类型成员的对象时需要特别小心，以避免浅拷贝导致的问题。\n4.在实际开发中，如何决定何时使用原型模式而不是其他模式，比如单例模式？ 在实际开发中，选择使用原型模式（Prototype Pattern）而不是其他模式，如单例模式（Singleton Pattern），取决于具体的应用场景和设计需求。以下是一些考虑因素，可以帮助你决定何时使用原型模式：\n对象创建的复杂性：\n如果对象的创建过程非常复杂或资源消耗大，原型模式可以通过复制现有对象来简化创建过程。单例模式则用于确保一个类只有一个实例，并提供一个全局访问点。 对象的可变性：\n如果对象的状态或属性需要频繁变化，并且这些变化不会影响到其他对象，原型模式可以提供灵活性，允许快速复制并修改对象。而单例模式通常用于提供不变且唯一的实例。 对象的多样性：\n当需要创建多个相似但又不完全相同的对象时，原型模式可以通过复制一个基础对象并进行小的调整来实现。单例模式不适用于需要多个实例的情况。 性能考虑：\n如果对象创建的性能是关键考虑因素，原型模式可以提供快速的对象创建。单例模式在首次创建实例时可能需要一些初始化工作，但之后提供全局访问点的速度很快。 对象的共享性：\n单例模式的核心是提供一个全局访问点，确保所有访问都使用相同的实例。如果需要的对象是可变的，并且需要在不同地方共享相同的状态，单例模式可能更合适。 对象的独立性：\n如果需要的对象是独立的，并且不需要与其他对象共享状态，原型模式可以提供这种独立性。单例模式则强调共享同一实例。 对象的配置：\n如果对象需要根据不同的配置创建多个变体，原型模式可以方便地复制一个基础配置并进行调整。单例模式通常不适用于需要多个配置实例的情况。 对象的生命周期：\n单例模式的对象通常在应用程序的整个生命周期内都存在。如果对象的生命周期需要更加灵活，例如需要根据需求创建和销毁，原型模式可能更合适。 线程安全：\n单例模式需要考虑线程安全问题，确保在多线程环境中只创建一个实例。原型模式在复制对象时也需要考虑线程安全，尤其是在对象包含可变共享资源时。 设计意图：\n考虑设计模式的设计意图。单例模式的意图是控制实例数量，而原型模式的意图是通过复制来创建新实例。 可扩展性：\n如果系统未来可能需要支持更多类型的实例，原型模式提供了更好的可扩展性，允许通过继承和组合来创建新的对象类型。 资源管理：\n如果对象包含需要特殊管理的资源，如文件句柄或数据库连接，单例模式可以确保这些资源被适当地管理和重用。原型模式则需要确保复制的对象不会共享这些资源，除非这是预期的行为。 在决定使用原型模式还是单例模式时，需要根据实际的需求和上下文来权衡。通常，如果需要快速复制对象并且对象的创建成本较高，或者需要创建多个相似但不完全相同的对象，原型模式是一个更好的选择。如果目标是控制实例的数量并提供一个全局访问点，单例模式可能更合适。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-prototype-pattern/","title":"design pattern Prototype Pattern"},{"content":"设计模式-代理模式-Proxy Pattern [TOC]\nOverview 代理模式（Proxy Pattern）是一种结构型设计模式 核心思想是通过引入一个代理对象来间接访问实际对象，从而在不改变实际对象代码的前提下，增加额外的功能操作，如访问控制、延迟初始化、日志记录等 代理模式使得客户端代码可以透明地与代理对象进行交互，而无需直接与实际对象通信。 了解该模式,看前4章节就够了，其他科普为主 1.代理模式（Proxy Pattern） 代理模式（Proxy Pattern）是一种结构型设计模式，其核心思想是通过引入一个代理对象来间接访问实际对象，从而在不改变实际对象代码的前提下，增加额外的功能操作，如访问控制、延迟初始化、日志记录等。代理模式使得客户端代码可以透明地与代理对象进行交互，而无需直接与实际对象通信。\n代理模式通常分为几种类型：\n静态代理：在代码编译时就已经确定代理类和目标类的关系。代理类通常会实现与目标类相同的接口，并在内部持有目标类的引用，从而在调用目标对象的方法前后进行额外的操作。\n动态代理：在程序运行时，通过反射机制动态创建代理类。在Java中，可以使用java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口来实现动态代理。\n虚拟代理：当有一个操作需要创建一个资源消耗较大的对象时，可以先使用一个较小的代理对象来代表真实对象。真实对象只有在需要时才会被实际创建。\n保护代理：控制对原始对象的访问权限，根据不同的访问权限提供不同的访问策略。\n智能引用代理：在访问对象时执行额外的动作，如引用计数、加载持久对象到内存等。\n远程代理：为位于不同地址空间的对象提供局部代表，隐藏对象存在于不同地址空间的事实。\n代理模式的应用场景包括：\n当需要对目标对象的访问进行控制时。 当需要为远程对象提供局部代表时。 当需要对目标对象的创建进行延迟时。 当需要给目标对象添加额外的功能操作时。 代理模式的优点包括：\n能够在不修改目标对象的前提下，通过引入代理对象来扩展功能。 能够控制对目标对象的访问，增加额外的安全或者日志记录等操作。 能够隐藏对象的实现细节，提供远程访问或者延迟初始化等功能。 代理模式的缺点包括：\n可能会引入额外的复杂性，因为需要维护代理对象和目标对象之间的通信。 对于简单的操作，可能会增加不必要的性能开销。 在使用代理模式时，需要根据实际需求选择合适的代理类型，并设计好代理对象和目标对象之间的交互方式。\n2.C++中 代理模式 在C++中实现代理模式，可以通过创建一个代理类来代表实际对象（也称为主题）。代理类会包含实际对象的引用或指针，并在调用实际对象的方法前后添加额外的功能。以下是代理模式在C++中的一个简单示例：\n首先，定义一个接口（通常是一个抽象类或纯虚函数类），这样代理类和实际对象都可以继承这个接口：\n1 2 3 4 5 class ISubject { public: virtual void Request() = 0; // 纯虚函数，定义接口 virtual ~ISubject() {} // 虚析构函数，确保派生类对象能够正确销毁 }; 接下来，创建实际对象的类，它实现了上述接口：\n1 2 3 4 5 6 class RealSubject : public ISubject { public: void Request() override { std::cout \u0026lt;\u0026lt; \u0026#34;RealSubject: Handling request.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 然后，创建代理类，它也实现了同样的接口，并包含对实际对象的引用或指针：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Proxy : public ISubject { private: RealSubject* realSubject; bool active; // 用于控制代理是否应该代理真实对象 public: Proxy() : realSubject(nullptr), active(false) {} void Request() override { if (!active) { std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: The real subject is not available.\u0026#34; \u0026lt;\u0026lt; std::endl; ActivateRealSubject(); active = true; } if (realSubject != nullptr) { realSubject-\u0026gt;Request(); } } void ActivateRealSubject() { std::cout \u0026lt;\u0026lt; \u0026#34;Proxy: Activating real subject.\u0026#34; \u0026lt;\u0026lt; std::endl; realSubject = new RealSubject(); } ~Proxy() { delete realSubject; // 清理资源 } }; 最后，客户端代码可以通过代理类来访问实际对象：\n1 2 3 4 5 6 7 8 9 int main() { Proxy proxy; proxy.Request(); // 此时会激活实际对象 // 后续调用可以继续通过代理来访问实际对象 proxy.Request(); return 0; } 在这个例子中，Proxy 类在第一次接收到请求时会创建一个 RealSubject 对象。之后的请求都会直接委托给这个已经创建的 RealSubject 对象。这就是一个简单的虚拟代理模式的实现，它延迟了实际对象的创建。\n代理模式可以扩展到其他类型，如远程代理、保护代理等，具体实现会根据需要添加的额外功能而有所不同。在C++中，代理模式的实现通常涉及到指针或引用的使用，以及可能的动态内存管理。\n3.代理模式的优缺点 优点 你可以在客户端毫无察觉的情况下控制服务对象。 如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。 即使服务对象还未准备好或不存在， 代理也可以正常工作。 开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。 缺点 代码可能会变得复杂， 因为需要新建许多类。 服务响应可能会延迟。 4.代理模式在实际开发中有哪些常见的应用场景？ 代理模式在实际开发中有多种应用场景，以下是一些常见的例子：\n远程代理：\n在分布式系统中，远程代理用于为远程对象提供本地接口，使得客户端可以像访问本地对象一样访问远程对象。 虚拟代理：\n在需要延迟加载资源的场景中，如加载大型图像或文档，可以先使用一个较小的代理对象，直到需要完整内容时才加载真实对象。 保护代理：\n控制对原始对象的访问权限，例如在系统中实现权限检查，确保只有具备相应权限的用户才能访问特定的对象或方法。 智能引用代理：\n在对象访问时执行额外操作，如引用计数、日志记录、事务管理等。这在资源管理、性能监控和调试中非常有用。 缓存代理：\n为对象的访问结果提供缓存，避免重复计算或重复访问数据库，提高系统性能。 日志代理：\n在调用对象方法前后添加日志记录，用于监控或者调试，帮助开发者追踪系统的执行流程。 同步代理：\n在多线程环境中，确保对象的方法在同一时间内只能由一个线程执行，防止数据竞争和不一致性问题。 防火墙代理：\n在网络安全中，防火墙代理可以控制对某些资源的访问，提供安全检查和过滤。 延迟初始化代理：\n延迟对象的初始化直到真正需要时才进行，优化启动时间，提高系统响应速度。 单例代理：\n确保一个类只有一个实例，并提供一个全局访问点，同时可以在访问实例时添加额外的逻辑。 线程安全代理：\n在多线程环境中，确保对象的线程安全性，例如通过代理对象来控制对共享资源的同步访问。 限流代理：\n控制对某些资源的访问频率，例如API调用的限流，防止系统过载。 装饰代理：\n在不修改原有对象的基础上，通过代理添加额外的功能，类似于装饰器模式，但更侧重于控制访问。 认证代理：\n在访问需要认证的服务时，代理可以处理认证过程，如OAuth、JWT等。 数据访问对象（DAO）代理：\n在数据访问层中，代理可以处理数据库连接的获取和释放，以及事务的管理。 代理模式的关键在于它能够在不改变原有对象的基础上，通过引入代理对象来扩展功能，同时保持了客户端代码的透明性。在设计模式的选择上，代理模式提供了一种灵活且强大的解决方案。\n5.在分布式系统中，远程代理模式是如何工作的？ 在分布式系统中，远程代理模式允许客户端通过一个本地代理对象间接访问远程服务器上的对象。这种方式隐藏了对象存在于不同地址空间的事实，使得客户端可以像访问本地对象一样透明地访问远程对象。远程代理在客户端和远程对象之间起到一个中间层的作用，它可以处理网络通信的细节，如连接的建立、数据的传输和断开连接等。\n远程代理的工作原理通常包括以下几个步骤：\n客户端向本地代理对象发送请求。 本地代理对象将请求转发到远程服务器上的真实对象。 远程服务器上的真实对象执行请求并返回结果。 本地代理对象将结果返回给客户端。 远程代理模式的优点包括：\n简化客户端代码：客户端不需要知道远程对象的具体位置和访问细节。 提高性能：代理可以缓存远程对象的信息，减少网络通信的次数。 增强安全性：代理可以添加安全控制，如认证和加密，以保护远程访问。 灵活性：可以在不改变客户端代码的情况下更换或更新远程对象的实现。 在实际应用中，远程代理模式可以用于各种分布式系统和服务，如Web服务、分布式数据库访问、云服务等。例如，在Java的RMI（Remote Method Invocation）机制中，就使用了远程代理来允许Java程序调用运行在不同JVM上的远程对象的方法。\n远程代理模式在设计时需要考虑的关键因素包括：\n网络延迟和带宽：远程代理需要优化数据传输以减少网络延迟和带宽消耗。 连接管理：代理需要有效地管理与远程服务器的连接，包括连接的创建、复用和关闭。 错误处理：代理需要处理网络错误和远程对象调用失败的情况。 安全性：代理需要确保数据在传输过程中的安全，包括使用加密和认证机制。 总的来说，远程代理模式是分布式系统中常用的一种设计模式，它为客户端提供了一种透明和简洁的方式来访问远程资源。\n6.分布式系统中远程代理模式有哪些常见的安全风险，如何防范？ 在分布式系统中，远程代理模式的安全风险主要包括数据泄露、恶意软件传播、身份盗用、拒绝服务攻击（DoS）、中间人攻击、注入攻击、跨站脚本攻击（XSS）以及未经授权访问等。为了防范这些风险，可以采取以下措施：\n选择可靠的代理服务器：选择信誉良好、口碑可靠的代理服务器提供商，避免使用来路不明的代理服务器，并定期更换代理服务器以降低数据泄露风险。\n配置加密连接：使用SSL/TLS等加密技术确保数据在传输过程中的安全性，防止数据在传输过程中被窃取或篡改。\n定期更新和升级：及时更新代理服务器的系统和软件，修补安全漏洞，升级软件以防止黑客利用漏洞进行攻击。\n限制访问权限：严格控制对代理服务器的访问权限，确保只有授权用户才能访问和使用代理服务器。\n提高自我保护意识：用户需要提高自我保护意识，注意保护个人信息和登录凭证，避免使用过于简单的密码，并定期更换密码。\n使用防火墙和入侵检测系统：监控网络流量，阻止恶意请求，并警告管理员潜在的攻击。\n安全编码实践：遵循最佳编程实践，避免引入已知的安全漏洞。\n持续集成和持续部署（CI/CD）：自动化测试和部署过程，确保快速发现和修复安全问题。\n定期审计和渗透测试：评估系统的安全状况，发现潜在的漏洞，并进行修复。\n安全意识培训：提高员工对安全问题的认识，减少内部威胁。\n数据加密：对敏感数据进行加密存储，以防止未经授权的访问。\n身份验证与授权：实施身份验证和基于角色的访问控制（RBAC）来限制对敏感资源的访问。\n访问控制与审计：实施访问控制机制并进行系统活动的监控和记录。\n分布式安全架构：构建安全的通信协议、部署防火墙和入侵检测系统，以及实施统一的安全管理策略。\n通过实施这些安全措施，可以有效地降低远程代理模式在分布式系统中的安全风险。同时，也需要保持对网络安全动态的关注和了解，以便及时应对新的安全威胁和挑战。\n7.分布式系统中的远程代理模式有哪些常见的安全漏洞，如何进行有效的安全审计？ 在分布式系统中，远程代理模式的安全漏洞主要包括服务器端请求伪造（SSRF）、远程代码执行、未授权访问、数据泄露、DDoS攻击等。以下是一些常见的安全漏洞及其防范措施：\n服务器端请求伪造（SSRF）：攻击者通过代理服务器发起请求，可以访问和操作内部系统。防范措施包括限制代理服务器可以访问的地址，对请求进行严格的验证和过滤。\n远程代码执行：攻击者通过注入恶意代码，利用远程代理执行代码。防范措施包括对所有输入进行严格的验证和过滤，使用安全的编码实践，及时更新和修补系统漏洞。\n未授权访问：攻击者可能尝试未经授权访问系统资源。防范措施包括实施强大的认证和访问控制机制，使用多因素认证，限制对敏感资源的访问。\n数据泄露：敏感数据可能在传输或存储过程中被截获。防范措施包括使用加密技术保护数据，实施数据备份和恢复策略，定期进行安全审计。\nDDoS攻击：攻击者通过大量请求使代理服务器过载，导致服务不可用。防范措施包括使用DDoS防护服务，实施速率限制和流量监控，使用负载均衡分散流量。\n跨站脚本攻击（XSS）：攻击者在Web应用程序中注入恶意脚本。防范措施包括对用户输入进行转义和编码，使用内容安全策略限制可加载的资源。\n为了进行有效的安全审计，可以采取以下措施：\n定期进行系统和网络的安全扫描，识别潜在的安全漏洞。 实施日志记录和监控，以便跟踪和分析系统活动。 进行渗透测试和模拟攻击，评估系统的防御能力。 制定和执行安全策略和程序，包括密码管理、数据保护和访问控制。 培训员工，提高他们对网络安全威胁的认识和防范能力。 通过这些措施，可以提高分布式系统中远程代理模式的安全性，减少安全风险。\n8.智能引用代理模式在性能监控中具体是如何实现的？ 智能引用代理模式在性能监控中的应用主要是通过在代理对象中添加额外的逻辑来实现的。这种代理可以在每次访问对象时执行一些附加操作，比如记录日志、监控性能、引用计数等，而无需修改实际对象的代码。以下是智能引用代理在性能监控中的具体实现步骤：\n定义接口：首先定义一个接口，这个接口包含所有代理类和实际对象需要实现的方法。\n实现实际对象：创建一个实际对象类，实现上述接口，并包含实际的业务逻辑。\n创建代理类：实现一个代理类，同样实现该接口，并在代理类中持有实际对象的引用。在代理类的方法中，可以在调用实际对象的方法前后添加性能监控的代码，如记录方法调用时间、计算执行时长等。\n代理对象的额外逻辑：在代理类的方法中，添加额外的性能监控逻辑。例如，在方法调用前记录开始时间，调用后记录结束时间，并计算耗时。这些数据可以用于后续的性能分析和优化。\n客户端使用代理：客户端代码通过代理对象来访问实际对象，这样所有对实际对象的调用都会经过代理，代理对象可以收集性能数据并进行监控。\n性能数据分析：收集到的性能数据可以用于分析系统的性能瓶颈，帮助开发者进行系统优化。\n安全性和灵活性：代理模式可以提高系统的安全性和灵活性，因为它允许在不修改实际对象的情况下添加额外的安全检查和控制逻辑。\n通过这种方式，智能引用代理模式可以在不改变原有业务逻辑的前提下，为系统提供额外的性能监控和分析功能，帮助开发者更好地理解和优化系统性能。\n9.智能引用代理模式在其他领域，比如内存管理或数据库操作中，有哪些应用案例？ 智能引用代理模式在内存管理和数据库操作等领域的应用案例如下：\n内存管理：\n在内存管理中，智能引用代理可以用于实现引用计数。例如，C++中的std::shared_ptr是一个典型的智能引用代理，它通过代理对象来管理对象的生命周期，当引用计数归零时自动释放对象占用的内存，从而避免内存泄漏。这种代理模式的应用可以确保资源在不再使用时被正确地释放，优化内存的使用。 数据库操作：\n在数据库操作中，代理模式可以用于实现数据库连接池。代理对象管理数据库连接的生命周期，当应用程序请求数据库连接时，代理对象提供一个现有的连接或者创建一个新的连接。使用完毕后，连接不是被关闭，而是归还到连接池中，以便再次使用。这样可以减少频繁打开和关闭数据库连接的开销，提高数据库操作的效率。 代理模式还可以用于实现延迟加载，即在真正需要数据时才从数据库加载。这可以提高应用的响应速度和性能，尤其是在处理大量数据时。 其他应用：\n在分布式系统中，远程代理模式允许客户端通过一个本地代理对象间接访问远程服务器上的对象。这种方式隐藏了对象存在于不同地址空间的事实，使得客户端可以像访问本地对象一样透明地访问远程对象。 在需要权限控制的场景中，保护代理模式可以控制对原始对象的访问权限，确保只有具备相应权限的用户才能访问特定的对象或方法。 通过这些应用案例，我们可以看到代理模式在实际开发中的灵活性和强大功能，它能够在不改变原有业务逻辑的前提下，为系统提供额外的控制和管理功能。\n10.在内存管理中，除了引用计数，还有哪些方法可以避免内存泄漏？ 在内存管理中，除了引用计数，避免内存泄漏的方法还包括：\n及时释放资源：在使用完图片、数据库连接等资源后，及时调用相关方法释放，例如在C++中使用delete或在Java中调用对象的close方法。\n使用智能指针：在C++中，可以使用std::unique_ptr或std::shared_ptr来自动管理内存的生命周期，减少手动管理内存的错误。\n避免循环引用：在对象间存在循环引用时，如果没有正确的引用计数或垃圾回收机制，可能导致内存泄漏。可以通过弱引用（WeakReference）或软引用（SoftReference）来避免。\n资源泄露的检查：除了内存泄漏外，还有其他类型的资源泄露，如文件句柄、数据库连接、网络套接字等。这些资源在使用完毕后如果没有被正确关闭或释放，也会导致资源泄露。\n使用RAII技术：RAII（Resource Acquisition Is Initialization）是一种编程习惯，通过在对象的构造函数中获取资源，在析构函数中释放资源，确保资源的正确释放。\n内存分析工具的使用：定期使用内存分析工具检测应用内存使用情况，及时发现并修复内存泄漏，如Valgrind、AddressSanitizer等。\n代码审查和测试：通过代码审查和测试来确保代码中没有内存泄漏问题，包括单元测试、集成测试和系统测试。\n避免滥用全局变量：全局变量的生命周期与应用程序相同，容易导致内存泄漏。尽可能使用局部变量或传递参数代替全局变量。\n单例模式的谨慎使用：单例模式会保持对象在整个应用程序的生命周期内存在，若单例对象持有大量数据或资源，可能会导致内存泄漏。确保单例对象只持有必要的引用。\n异常安全：在C++中，如果程序抛出异常，需要确保在异常处理过程中正确释放已分配的内存。使用try-catch块来捕获异常并在适当的位置释放内存。\n通过上述措施，可以有效地减少内存泄漏的风险，提高程序的稳定性和性能。\n11.数据库操作中，代理模式如何实现延迟加载的具体技术细节是什么？ 在数据库操作中，代理模式实现延迟加载的技术细节主要涉及以下几个方面：\n代理对象的创建：在MyBatis等ORM框架中，延迟加载通常是通过动态代理实现的。当框架需要加载一个实体的关联对象时，不是立即从数据库查询，而是先创建一个代理对象。这个代理对象在第一次被访问时，才会触发实际的数据库查询操作。\n拦截方法调用：代理对象会拦截对关联对象属性的访问。例如，如果一个User实体有一个延迟加载的Address属性，当调用getUser().getAddress()时，代理对象会检查Address是否已经加载。如果没有，则代理对象会执行数据库查询来加载Address，并将结果设置到User实体的Address属性中。\n配置延迟加载：在MyBatis中，可以通过在mybatis-config.xml配置文件中设置lazyLoadingEnabled为true来启用延迟加载。此外，还可以通过fetchType属性在具体的映射文件中为每个关联属性指定加载策略。\n处理循环引用：在某些情况下，实体间的关联可能导致循环引用的问题。代理模式需要能够妥善处理这种情况，避免无限递归查询。\n性能考虑：虽然延迟加载可以减少初始加载的数据量，提高应用的响应速度，但也可能引发额外的数据库查询，影响性能。因此，需要合理配置和使用延迟加载，以平衡性能和资源使用。\n代理模式的应用：代理模式在数据库操作中的应用不仅限于延迟加载，还可以用于实现事务管理、缓存、权限控制等功能。\n在实际应用中，代理模式的延迟加载技术细节通常是由ORM框架内部实现的，开发者只需要通过配置来启用和控制延迟加载的行为。例如，在MyBatis中，可以通过配置文件和映射文件中的相关设置来实现延迟加载，而具体的代理对象创建和方法拦截逻辑则由框架自动处理。\n12.在分布式系统中，远程代理模式是如何保证数据一致性和安全性的？ 在分布式系统中，远程代理模式通过以下方式来保证数据一致性和安全性：\n数据一致性保证：\n使用一致性协议：远程代理可以通过实现如Paxos或Raft这样的分布式一致性协议来确保所有节点上的数据保持一致。这些协议通过日志复制和领导者选举机制来保证数据在多个节点间的一致性。 版本控制和MVCC：多版本并发控制（MVCC）允许系统在处理并发操作时，通过版本号来管理数据的不同版本，从而避免更新冲突并保持数据一致性。 同步和异步复制：远程代理可以采用同步或异步数据复制策略，确保数据在多个节点上的副本保持一致。同步复制确保写操作在所有副本上完成后才算成功，而异步复制则允许系统在写操作后逐步同步数据。 安全性保证：\n权限控制：远程代理可以实施细粒度的访问控制，确保只有授权的用户或服务能够访问特定的数据或执行特定的操作。 加密通信：代理模式可以利用SSL/TLS等加密技术来保护客户端和服务器之间的通信，防止数据在传输过程中被截获或篡改。 认证和授权：远程代理可以集成认证机制，如OAuth或JWT，来验证用户的身份，并根据用户的角色和权限来授权访问。 其他技术细节：\n代理对象的创建：远程代理对象在客户端请求时创建，它封装了与远程服务的通信细节，包括网络连接的建立、数据的序列化和反序列化等。 请求转发：代理对象接收客户端的请求，并将其转发到远程服务。在转发过程中，代理可以添加额外的安全检查或数据验证逻辑。 错误处理：远程代理需要能够妥善处理网络错误和远程服务不可用的情况，确保系统的健壮性和可靠性。 通过上述机制，远程代理模式在分布式系统中有效地保证了数据的一致性和安全性，同时也提高了系统的可扩展性和可维护性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-proxy-pattern/","title":"design pattern Proxy Pattern"},{"content":"设计模式-单例模式 [TOC]\nOverview 单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。\n初次接触，直接说懒汉式和饿汉式，容易把人搞懵掉，先认识一下吧！\n1.单例模式中懒汉式和饿汉式区别 单例模式中的懒汉式和饿汉式是两种不同的实现策略，它们在实例化单例对象的时机和线程安全性方面有所不同。以下是懒汉式和饿汉式单例模式的主要区别：\n1.1.懒汉式（Lazy Initialization） 实例化时机：懒汉式单例在第一次被使用时才会创建实例，即延迟初始化。\n线程安全性：标准的懒汉式实现不是线程安全的。需要引入锁机制（如双重检查锁定）来保证线程安全。\n资源利用率：由于延迟初始化，懒汉式可能在某些情况下减少资源占用，但这也取决于具体实现和使用场景。\n性能开销：在多线程环境下，可能因为锁机制引入额外的性能开销。\n实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class LazySingleton { private: static LazySingleton* instance; static std::mutex mutex; LazySingleton() {} // 私有构造函数 public: static LazySingleton* getInstance() { if (instance == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); if (instance == nullptr) { instance = new LazySingleton(); } } return instance; } }; LazySingleton* LazySingleton::instance = nullptr; std::mutex LazySingleton::mutex; 1.2.饿汉式（Eager Initialization） 实例化时机：饿汉式单例在程序启动时就立即创建实例，即立即初始化。\n线程安全性：饿汉式实现是线程安全的，因为它在程序启动时就完成了实例化，不存在多线程竞争的问题。\n资源利用率：饿汉式可能会在程序启动时就占用资源，即使该单例实例尚未被使用。\n性能开销：由于避免了锁机制，饿汉式在单例获取时通常具有较高的性能。\n实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class EagerSingleton { private: static EagerSingleton instance; // 静态实例 EagerSingleton() {} // 私有构造函数 public: static EagerSingleton\u0026amp; getInstance() { return instance; } }; EagerSingleton EagerSingleton::instance; 1.3.选择建议 如果单例对象的创建成本较高，且在程序早期不需要立即使用，懒汉式可能更合适，因为它可以延迟对象的创建。 如果需要确保线程安全，且对单例对象的创建时机没有特别要求，饿汉式是一个简单且有效的选择。 在多线程环境中，如果使用懒汉式，需要确保通过适当的同步机制（如双重检查锁定）来保证线程安全。 两种实现方式各有优缺点，应根据具体应用场景和需求来选择最合适的实现策略。\n2.单例模式 Singleton 实现方式及详细介绍 在 C++中，单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来访问这个实例。以下是单例模式的实现方式及详细介绍：\n2.1. 懒汉式（线程不安全） 懒汉式单例模式在第一次使用时才会创建实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Singleton { private: static Singleton* instance; Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton* getInstance() { if (instance == nullptr) { instance = new Singleton(); } return instance; } // 其他成员函数和数据成员 void doSomething() { // ... } }; // 初始化静态成员变量 Singleton* Singleton::instance = nullptr; 在上述代码中， getInstance 函数在第一次被调用时才会创建Singleton类的实例。如果该函数后续被再次调用，将直接返回已经创建的实例。 2.2. 懒汉式（线程安全） 懒汉式单例模式在多线程环境下可能会出现问题。如果多个线程同时进入getInstance函数并且instance为nullptr，那么可能会创建多个实例。 为了解决这个问题，可以使用互斥锁来确保在多线程环境下只有一个线程能够创建实例。例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;mutex\u0026gt; class Singleton { private: static Singleton* instance; static std::mutex mutex; Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton* getInstance() { if (instance == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); if (instance == nullptr) { instance = new Singleton(); } } return instance; } // 其他成员函数和数据成员 void doSomething() { // ... } }; // 初始化静态成员变量 Singleton* Singleton::instance = nullptr; std::mutex Singleton::mutex; 2.3. 饿汉式（线程安全） 饿汉式单例模式在程序启动时就创建实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Singleton { private: static Singleton instance; // 静态实例 Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton\u0026amp; getInstance() { return instance; } // 其他成员函数和数据成员 void doSomething() { // ... } }; // 实现静态成员变量 Singleton Singleton::instance; 2.4. C++11后 局部静态变量（线程安全） 实现原理 C++11 引入了线程安全的静态局部变量初始化特性。利用这个特性，可以在获取单例实例的方法中声明一个静态局部变量，该变量在第一次调用方法时被初始化，并且保证线程安全。 利用局部静态变量的线程安全特性实现单例模式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Singleton { private: Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton\u0026amp; getInstance() { static Singleton instance; // 局部静态变量 return instance; } // 其他成员函数和数据成员 void doSomething() { // ... } }; 2.5. 注意事项 单例类的构造函数、拷贝构造函数和赋值操作符通常都是私有的，以防止创建多个实例。 需要确保单例的析构函数是公共的，以便能够销毁单例对象。 在多线程环境中，需要特别注意线程安全问题，可以选择使用锁或原子操作来保证线程安全。 单例模式在实际应用中非常广泛，比如配置管理器、数据库连接池管理器等场景。然而，过度使用单例可能导致代码难以测试和维护，因此应谨慎使用。\n3.单例模式的应用场景 日志系统 在一个应用程序中，通常只需要一个日志系统来记录各种信息。使用单例模式可以确保无论在程序的哪个部分调用日志系统，都只有一个实例在运行，避免了多个日志系统之间的冲突和资源浪费。 例如，可以将日志系统实现为单例类，提供统一的接口来记录不同级别的日志信息。 数据库连接 在访问数据库时，通常需要建立一个数据库连接。使用单例模式可以确保只有一个数据库连接实例存在，避免了重复建立连接的开销和资源浪费。 例如，可以将数据库连接类实现为单例类，提供方法来执行数据库查询和更新操作。 配置管理 应用程序的配置信息通常在整个程序中都需要访问。使用单例模式可以确保只有一个配置管理实例存在，方便在程序的任何地方获取和修改配置信息。 例如，可以将配置管理类实现为单例类，提供方法来读取和修改配置文件中的参数。 总之，单例模式在 C++ 中是一种非常有用的设计模式，它可以确保一个类只有一个实例，并提供一个全局访问点来访问这个实例。在实际应用中，可以根据具体情况选择懒汉式或饿汉式单例模式，并注意线程安全和资源管理等问题。\n4.单例模式在多线程环境下如何保证线程安全？ 在多线程环境下保证单例模式的线程安全，可以采用以下几种方法：\n4.1. 双重检查锁定（Double-Checked Locking, DCL） 双重检查锁定是一种常见的线程安全单例实现方式，它减少了锁的开销。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;mutex\u0026gt; class Singleton { private: static Singleton* instance; static std::mutex mutex; Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton* getInstance() { if (instance == nullptr) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); if (instance == nullptr) { // 再次检查实例是否已被创建 instance = new Singleton(); } } return instance; } }; // 初始化静态成员变量 Singleton* Singleton::instance = nullptr; std::mutex Singleton::mutex; 4.2. 局部静态变量 利用局部静态变量的线程安全特性，编译器和其他运行时环境保证了局部静态变量的线程安全初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Singleton { private: Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton\u0026amp; getInstance() { static Singleton instance; // 局部静态变量 return instance; } }; 4.3. 原子操作 使用原子操作来确保实例化过程的原子性，避免多线程同时创建实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;atomic\u0026gt; #include \u0026lt;mutex\u0026gt; class Singleton { private: static std::atomic\u0026lt;bool\u0026gt; initialized; static Singleton* instance; static std::mutex mutex; Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton* getInstance() { if (!initialized.load()) { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); if (!initialized.load()) { instance = new Singleton(); initialized.store(true); } } return instance; } }; // 初始化静态成员变量 std::atomic\u0026lt;bool\u0026gt; Singleton::initialized(false); Singleton* Singleton::instance = nullptr; std::mutex Singleton::mutex; 4.4. 使用 std::call_once 和 std::once_flag C++11 引入了 std::call_once 函数，它保证在多线程环境下对给定函数的首次调用是单线程执行的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;mutex\u0026gt; class Singleton { private: static std::mutex mutex; static std::once_flag onceFlag; static Singleton* instance; Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton* getInstance() { std::call_once(onceFlag, [](){ instance = new Singleton(); }); return instance; } }; // 初始化静态成员变量 std::mutex Singleton::mutex; std::once_flag Singleton::onceFlag; Singleton* Singleton::instance = nullptr; 4.5. 注意事项 双重检查锁定需要使用 std::atomic 或者合适的锁机制来避免多线程环境下的竞态条件。 局部静态变量的方法简单且线程安全，但可能在程序的生命周期内无法释放单例对象占用的资源。 std::call_once 是C++11引入的，它提供了一种优雅的方式来保证线程安全的单例模式实现。 在设计单例模式时，需要根据实际的应用场景和需求来选择合适的线程安全实现方式。\n5.除了懒汉式和饿汉式，还有哪些实现单例模式的方法？ 除了懒汉式和饿汉式，C++中还有其他几种实现单例模式的方法，包括使用C++11标准引入的线程安全静态局部变量、基于函数的局部静态变量、以及使用智能指针。以下是这些方法的示例：\n5.1. 线程安全静态局部变量（C++11） C++11标准规定，静态局部变量在首次使用时会自动初始化，并且是线程安全的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Singleton { private: Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton\u0026amp; getInstance() { static Singleton instance; // 线程安全的静态局部变量 return instance; } // 其他成员函数和数据成员 }; 5.2. 基于函数的局部静态变量 在C++中，函数内部的静态变量在首次调用函数时初始化，并且具有线程安全的特性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Singleton { private: Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton\u0026amp; getInstance() { static Singleton\u0026amp; instance = createInstance(); return instance; } private: static Singleton\u0026amp; createInstance() { static Singleton instance; return instance; } }; // 其他成员函数和数据成员 5.3. 使用 std::call_once 和 std::once_flag C++11引入了std::call_once，它用于确保在多线程环境下对某个函数的调用是单次的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;mutex\u0026gt; class Singleton { private: static std::once_flag onceFlag; static Singleton* instance; Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static Singleton* getInstance() { std::call_once(onceFlag, [](){ instance = new Singleton(); }); return instance; } // 确保析构函数是公共的，以便能够销毁单例对象 ~Singleton() {} }; // 初始化静态成员变量 std::once_flag Singleton::onceFlag; Singleton* Singleton::instance = nullptr; 5.4. 使用智能指针 使用std::shared_ptr来管理单例实例，可以自动处理内存释放。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;memory\u0026gt; class Singleton { private: static std::shared_ptr\u0026lt;Singleton\u0026gt; instance; Singleton() {} // 私有构造函数 // 禁用拷贝构造函数和赋值操作符 Singleton(const Singleton\u0026amp;) = delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;) = delete; public: static std::shared_ptr\u0026lt;Singleton\u0026gt; getInstance() { if (instance == nullptr) { instance.reset(new Singleton()); } return instance; } // 其他成员函数和数据成员 }; // 初始化静态成员变量 std::shared_ptr\u0026lt;Singleton\u0026gt; Singleton::instance; 5.5. 注意事项 选择实现单例模式的方法时，需要考虑线程安全性、性能、资源管理等因素。 确保单例的析构函数是公共的，以便能够销毁单例对象。 智能指针方法虽然可以自动管理内存，但在某些情况下可能会引起循环引用或其他问题，需要谨慎使用。 这些方法各有优缺点，可以根据项目的具体需求和约束来选择最合适的实现方式。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-singleton-pattern/","title":"design pattern Singleton Pattern"},{"content":"设计模式-状态模式-State Pattern [TOC]\nOverview 状态模式（State Pattern）是一种行为型设计模式 它允许一个对象在其内部状态改变时改变它的行为，看起来好像修改了它的类 这种模式通过将状态相关的行为封装在独立的类中，并在运行时根据状态对象来切换这些行为，从而使得对象能够在内部状态变化时合理地更改其行为 1.状态模式（State Pattern） 状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变它的行为，看起来好像修改了它的类。这种模式通过将状态相关的行为封装在独立的类中，并在运行时根据状态对象来切换这些行为，从而使得对象能够在内部状态变化时合理地更改其行为。\n状态模式的主要角色包括：\nContext（上下文）：维护一个指向当前状态对象的引用，这个引用定义了当前状态对象应该执行哪些操作。\nState（状态接口）：定义一个接口，以封装与Context的一个特定状态相关的行为。\nConcrete State（具体状态）：实现State接口，定义与一个特定状态相关的行为。\nClient（客户端）：创建Context对象，并根据需要改变其状态。\n状态模式的实现通常涉及以下几个步骤：\n定义状态接口，声明在不同状态下需要执行的操作。 实现具体状态类，这些类实现状态接口，并定义每个状态下的行为。 创建上下文类，持有状态接口的引用，并提供方法来改变其状态。 客户端代码根据需要改变上下文的状态。 以下是一个简单的C++实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include \u0026lt;iostream\u0026gt; // 状态接口 class State { public: virtual void insertQuarter() = 0; virtual void ejectQuarter() = 0; virtual void turnCrank() = 0; virtual void dispense() = 0; virtual ~State() {} }; // 具体状态A class ConcreteStateA : public State { public: void insertQuarter() override { std::cout \u0026lt;\u0026lt; \u0026#34;State A: Inserted a quarter.\\n\u0026#34;; } void ejectQuarter() override { std::cout \u0026lt;\u0026lt; \u0026#34;State A: Ejected a quarter.\\n\u0026#34;; } void turnCrank() override { std::cout \u0026lt;\u0026lt; \u0026#34;State A: Turned crank.\\n\u0026#34;; } void dispense() override { std::cout \u0026lt;\u0026lt; \u0026#34;State A: Dispensed.\\n\u0026#34;; } }; // 具体状态B class ConcreteStateB : public State { public: void insertQuarter() override { std::cout \u0026lt;\u0026lt; \u0026#34;State B: Inserted a quarter.\\n\u0026#34;; } void ejectQuarter() override { std::cout \u0026lt;\u0026lt; \u0026#34;State B: Ejected a quarter.\\n\u0026#34;; } void turnCrank() override { std::cout \u0026lt;\u0026lt; \u0026#34;State B: Turned crank.\\n\u0026#34;; } void dispense() override { std::cout \u0026lt;\u0026lt; \u0026#34;State B: Dispensed.\\n\u0026#34;; } }; // 上下文 class GumballMachine { private: State* state; public: GumballMachine(State* state) : state(state) {} void setState(State* state) { this-\u0026gt;state = state; } void insertQuarter() { state-\u0026gt;insertQuarter(); } void ejectQuarter() { state-\u0026gt;ejectQuarter(); } void turnCrank() { state-\u0026gt;turnCrank(); } void dispense() { state-\u0026gt;dispense(); } }; int main() { State* stateA = new ConcreteStateA(); GumballMachine gumballMachine(stateA); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.ejectQuarter(); State* stateB = new ConcreteStateB(); gumballMachine.setState(stateB); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.dispense(); delete stateA; delete stateB; return 0; } 在这个例子中，GumballMachine 是上下文，它持有一个指向 State 接口的指针。ConcreteStateA 和 ConcreteStateB 是具体的状态类，它们实现了 State 接口中定义的操作。在 main 函数中，我们创建了一个 GumballMachine 实例，并在不同状态下切换，展示了状态模式的使用。\n状态模式的优点包括局部化了状态相关的操作，将状态转换逻辑封装在状态对象内部，以及可以在运行时切换对象的行为。缺点是可能增加系统中对象的数量，每个状态都需要一个具体的状态类。\n2.状态模式优缺点 优点 单一职责原则。 将与特定状态相关的代码放在单独的类中。 开闭原则。 无需修改已有状态类和上下文就能引入新状态。 通过消除臃肿的状态机条件语句简化上下文代码。 缺点 如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。 状态模式（State Pattern）的优缺点如下：\n2.1.优点 局部化状态行为：将与特定状态相关的行为封装在单独的状态类中，使得状态相关的代码更加模块化和易于管理。\n消除庞大的条件分支语句：在没有使用状态模式的情况下，对象的状态管理可能需要大量的条件分支语句，状态模式可以将这些条件分支分散到不同的状态类中。\n易于扩展：新增状态时，只需添加一个新的具体状态类，而无需修改其他代码，符合开闭原则。\n清晰的逻辑：状态模式使得状态转换逻辑更加清晰，每个状态类都明确定义了何时以及如何转换到其他状态。\n提高可维护性：状态模式将对象的状态封装在单独的类中，使得状态的管理和对象的其他行为分离，提高了代码的可维护性。\n促进职责单一：每个状态类只关注与自身状态相关的行为，符合单一职责原则。\n2.2.缺点 过多的状态类：如果系统中状态很多，可能会导致大量的具体状态类，增加系统的复杂性。\n增加系统开销：每个状态都是一个对象，可能会增加内存开销，尤其是在状态对象数量较多的情况下。\n状态管理复杂：在某些情况下，状态转换逻辑可能非常复杂，需要仔细设计以确保状态转换的正确性。\n可能引入循环依赖：在一些设计中，状态对象之间可能存在相互引用，这可能导致循环依赖问题。\n状态切换可能导致错误：如果状态转换逻辑不明确或者错误，可能会导致系统行为异常。\n状态切换的可见性：在某些设计中，状态切换可能对外部不可见，这可能会使得调试和测试变得更加困难。\n在使用状态模式时，应该根据具体的应用场景和需求来决定是否采用这种模式。在设计时，应该考虑到状态模式可能带来的复杂性，并确保状态转换逻辑的正确性和清晰性。\n3.状态模式在实际开发中有哪些常见的应用场景？ 状态模式在实际开发中广泛应用于需要根据对象状态改变行为的场景。以下是一些典型的应用场景：\n工作流管理：在工作流管理系统中，每个任务可能有不同的状态，如待审批、审批中、已批准、已拒绝等。状态模式可以用来封装每个状态下的行为。\n订单处理系统：在电子商务平台中，订单可以有多种状态，如未支付、已支付、正在发货、已发货、交易完成、交易取消等。状态模式可以管理这些状态的转换以及每个状态下允许的操作。\n游戏状态管理：在游戏中，玩家或游戏本身可能有不同的状态，如游戏开始、游戏暂停、游戏结束等。状态模式可以用来控制游戏在不同状态下的行为。\n权限控制：在权限控制系统中，用户可能有不同的权限状态，如普通用户、审核中、管理员等。状态模式可以用来封装与不同权限相关的行为。\n设备状态控制：在嵌入式系统或硬件控制软件中，设备可能有多种状态，如待机、工作、错误、维护等。状态模式可以用来管理设备在不同状态下的行为。\n用户界面状态：在图形用户界面（GUI）中，组件如按钮、菜单项等可能有不同的状态，如可用、禁用、选中等。状态模式可以用来处理不同状态下的事件。\n协议状态机：在网络通信协议中，连接可能有不同的状态，如连接建立、数据传输、连接关闭等。状态模式可以用来管理这些状态的转换。\n状态验证：在需要根据对象状态进行验证的系统中，如表单填写，每个字段可能有多种状态，如已填写、未填写、验证通过、验证失败等。状态模式可以用来封装状态验证逻辑。\n定时任务调度：在任务调度系统中，任务可能有计划中、执行中、已完成、已跳过等状态。状态模式可以用来管理任务在不同状态下的行为。\n产品生命周期管理：在产品生命周期管理中，产品可能经历设计、生产、销售、维护、淘汰等状态。状态模式可以用来封装每个状态下的行为。\n状态模式的优点在于它将状态相关的行为封装在具体的状态类中，使得状态转换逻辑清晰，并且可以在运行时动态地改变对象的行为。然而，它也可能导致系统中状态类的数量增多，因此在设计时需要权衡其优缺点。\n4.在设计状态模式时，有哪些常见的问题和挑战？ 在设计状态模式时，可能会遇到以下常见问题和挑战：\n状态类爆炸：如果系统中存在很多状态，可能会导致大量的具体状态类，这会增加系统的复杂性和维护成本。\n状态转换逻辑复杂：状态模式要求将状态转换逻辑封装在上下文（Context）中，当状态转换逻辑非常复杂时，管理这些转换可能会变得困难。\n状态一致性：确保在状态转换过程中，上下文的状态始终保持一致是一个挑战，特别是在多线程环境中。\n状态管理：随着系统的发展，状态的增加和删除需要仔细管理，以避免状态管理的混乱。\n状态的入口：在某些情况下，确定状态的初始状态并正确初始化上下文可能是一个挑战。\n状态恢复：在某些应用中，可能需要支持状态的撤销和恢复，这需要额外的设计和实现。\n状态依赖：有些状态的行为可能依赖于其他状态的信息，这可能导致状态类之间的耦合。\n状态模式与观察者模式的结合：在需要状态变化通知其他对象时，如何有效地结合状态模式和观察者模式是一个设计挑战。\n状态的持久化：在某些系统中，可能需要将状态持久化到数据库或文件中，这需要在状态模式中考虑持久化和恢复的逻辑。\n状态的线程安全：在多线程环境中，确保状态的线程安全是一个挑战，需要考虑同步和并发访问的问题。\n状态的可预测性：在复杂的系统中，状态转换可能不是线性的，设计时需要确保状态转换的可预测性和正确性。\n状态模式的过度使用：在一些简单的场景中，过度使用状态模式可能会导致不必要的复杂性。\n为了解决这些问题和挑战，设计时需要仔细考虑系统的规模、状态的数量、状态转换的复杂性以及系统的可维护性。同时，应该遵循设计原则，如单一职责原则、开闭原则和迪米特法则，来确保系统的灵活性和可扩展性。在实现时，可以考虑使用设计模式的组合，如结合策略模式、命令模式或观察者模式，来解决特定的设计问题。\n5.状态模式在多线程环境中如何保证状态的一致性和线程安全？ 在多线程环境中，确保状态模式的一致性和线程安全，可以采取以下措施：\n使用互斥锁（Mutex）：在状态转换方法中使用互斥锁来保护状态的一致性，确保同一时间只有一个线程可以改变状态。\n条件变量（Condition Variable）：在状态模式中，条件变量可以用来协调线程间的工作，当状态发生改变时，通知等待的线程。\n避免死锁：在设计状态模式时，要注意避免死锁的发生。确保获取锁的顺序一致，或者使用定时锁（尝试锁），以防止线程永久阻塞。\n最小化锁的粒度：尽量减小锁的范围和持有时间，例如使用std::lock_guard和std::unique_lock来自动管理锁的生命周期。\n使用不可变对象：如果状态对象是不可变的，那么它们自然是线程安全的，因为它们的状态在创建后不会改变。\n线程局部存储（Thread-Local Storage）：使用线程局部存储来保存每个线程的状态，这样可以避免线程间的共享和竞争。\n使用原子操作：对于简单的状态更新，可以使用原子操作来确保操作的原子性，而不需要使用重量级的锁。\n状态模式与观察者模式结合：当状态改变时，使用观察者模式通知所有依赖于状态的对象，确保它们能够及时响应状态的变化。\n避免在持有锁时进行长时间操作：持有锁时不要执行耗时的计算或者调用外部资源，这样可以减少锁的等待时间，提高系统的并发性能。\n使用读写锁（Read-Write Lock）：如果状态读操作远多于写操作，可以使用读写锁来允许多个线程同时读取状态，但在写入时需要独占访问。\n通过上述措施，可以在多线程环境中有效地使用状态模式，同时确保状态的一致性和线程安全。在实际应用中，应根据具体的并发需求和性能目标来选择合适的同步策略。\n6.状态模式在实际项目中如何与观察者模式结合使用？ 在实际项目中，状态模式和观察者模式可以结合使用来构建更加灵活和响应式的系统。以下是它们结合使用的一些常见应用场景和方法：\n工作流状态更新：在一个工作流管理系统中，每个任务都有不同的状态，如“待审批”、“审批中”、“已完成”等。状态模式可以用来封装每个状态下的行为。同时，当任务状态发生变化时，系统可能需要通知其他部分，比如通知任务的处理者或更新相关的监控仪表板。这时，观察者模式可以用来实现状态变化的通知机制。\n用户界面与数据模型同步：在模型-视图-控制器（MVC）架构中，数据模型（Model）的变化需要实时反映到视图（View）上。状态模式可以用来管理数据模型的不同状态，而观察者模式则确保当数据模型的状态发生变化时，所有依赖的视图都能得到更新。\n游戏状态管理：在游戏开发中，游戏可能有不同的游戏状态，如“菜单”、“游戏进行中”、“暂停”、“游戏结束”等。状态模式可以用来定义这些状态和它们之间的转换。观察者模式则可以用来通知游戏中的其他系统或组件，如声音系统、得分系统等，关于游戏状态的变化。\n订单处理系统：在电子商务平台中，订单对象会经历多个状态，如“新建”、“支付”、“发货”、“完成”等。状态模式可以用来封装订单的每个状态相关的行为。当订单状态发生变化时，可能需要通知物流系统、库存系统或客户服务系统，观察者模式可以用来实现这种通知。\n设备状态监控：在嵌入式系统或物联网（IoT）设备中，设备可能有多种状态，如“待机”、“工作”、“错误”、“维护”等。状态模式可以用来管理设备的状态和行为。观察者模式则可以用来实现设备状态变化的监控和报警系统。\n结合使用状态模式和观察者模式时，关键在于设计一个清晰的状态转换逻辑，并确保状态变化能够及时通知到所有相关的观察者。这种结合使用可以提高系统的模块化和可维护性，同时也使得状态变化的管理更加集中和一致。\n7.在设计状态模式和观察者模式的结合时，有哪些常见的设计模式或原则可以参考？ 在设计状态模式和观察者模式的结合时，可以参考以下设计原则和模式：\n单一职责原则：确保每个类和模块只负责一个功能，这样当状态改变时，相关的类可以独立地变化而不影响其他模块。\n开闭原则：设计时应当使系统易于扩展新的状态或观察者，而不需要修改已有的代码。\n依赖倒置原则：高层模块不应依赖于低层模块，两者都应该依赖于抽象。在状态模式和观察者模式的结合中，可以通过接口或抽象类来实现。\n迪米特法则：减少对象之间的直接交互，通过中介者来传递消息，这有助于降低系统的耦合度。\n命令模式：在状态模式中，可以结合命令模式来封装具体的行为，使得状态转换更加灵活。\n中介者模式：当系统中的组件交互复杂时，可以使用中介者模式来简化组件之间的通信。\n策略模式：在状态模式中，可以使用策略模式来定义一系列算法（行为），并在运行时选择使用哪一个算法。\n模板方法模式：在观察者模式中，可以使用模板方法模式来定义一个算法的框架，允许子类在不改变算法结构的情况下重写算法的某些步骤。\n组合模式：当观察者或状态对象需要形成树形结构时，可以使用组合模式来表示部分-整体层次结构。\n迭代器模式：在观察者模式中，如果需要遍历所有观察者，可以使用迭代器模式来提供一个顺序访问的接口。\n在实际应用中，可以根据具体的需求和上下文来选择适合的设计原则和模式。例如，如果状态转换逻辑复杂，可以考虑使用策略模式来简化；如果需要在状态变化时通知多个观察者，可以结合使用观察者模式。通过这些设计原则和模式的结合使用，可以构建出灵活、可扩展且易于维护的系统。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-state-pattern/","title":"design pattern State Pattern"},{"content":"设计模式-策略模式-Strategy Pattern [TOC]\nOverview 策略模式（Strategy Pattern）是一种行为型设计模式 它定义了一系列的算法，并将每一个算法封装起来，使它们可以互换使用，算法的变化不会影响使用算法的用户 策略模式让算法独立于使用它的客户端而变化。 1.策略模式（Strategy Pattern） 策略模式（Strategy Pattern）是一种行为型设计模式，它定义了一系列的算法，并将每一个算法封装起来，使它们可以互换使用，算法的变化不会影响使用算法的用户。策略模式让算法独立于使用它的客户端而变化。\n在C++中实现策略模式通常涉及以下几个步骤：\n定义策略接口：这个接口定义了所有支持的算法必须遵循的方法。 实现具体策略：为每一个算法创建一个类，实现策略接口。 创建上下文：上下文持有策略接口的引用，通过这个引用调用算法的方法。 以下是一个简单的C++实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; // 策略接口 class Strategy { public: virtual ~Strategy() {} virtual int execute(int n) = 0; }; // 具体策略A class ConcreteStrategyA : public Strategy { public: int execute(int n) override { return n * n; } }; // 具体策略B class ConcreteStrategyB : public Strategy { public: int execute(int n) override { return n * n * n; } }; // 上下文 class Context { private: std::unique_ptr\u0026lt;Strategy\u0026gt; strategy; public: void setStrategy(std::unique_ptr\u0026lt;Strategy\u0026gt; s) { strategy = std::move(s); } int executeStrategy(int n) { if (strategy) { return strategy-\u0026gt;execute(n); } return 0; } }; int main() { Context context; // 使用策略A std::unique_ptr\u0026lt;Strategy\u0026gt; strategyA(new ConcreteStrategyA()); context.setStrategy(std::move(strategyA)); std::cout \u0026lt;\u0026lt; \u0026#34;Strategy A (10): \u0026#34; \u0026lt;\u0026lt; context.executeStrategy(10) \u0026lt;\u0026lt; std::endl; // 更换策略为B std::unique_ptr\u0026lt;Strategy\u0026gt; strategyB(new ConcreteStrategyB()); context.setStrategy(std::move(strategyB)); std::cout \u0026lt;\u0026lt; \u0026#34;Strategy B (10): \u0026#34; \u0026lt;\u0026lt; context.executeStrategy(10) \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，Strategy 是策略接口，它定义了一个 execute 方法。ConcreteStrategyA 和 ConcreteStrategyB 是具体策略类，它们实现了 Strategy 接口，并提供了不同的算法实现。\nContext 是上下文类，它持有一个 Strategy 接口的指针，并使用它来执行算法。在 main 函数中，我们创建了一个 Context 对象，并分别设置了 ConcreteStrategyA 和 ConcreteStrategyB 策略，然后执行了算法。\n策略模式的优点包括算法的封装和切换的灵活性，以及算法可独立于使用它的客户端变化。缺点可能包括策略类的数量增多，以及需要维护这些策略类。在设计时，应该根据实际需求来决定是否使用策略模式。\n2.策略模式优缺点 优点 你可以在运行时切换对象内的算法。 你可以将算法的实现和使用算法的代码隔离开来。 你可以使用组合来代替继承。 开闭原则。 你无需对上下文进行修改就能够引入新的策略。 缺点 如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。 客户端必须知晓策略间的不同——它需要选择合适的策略。 许多现代编程语言支持函数类型功能， 允许你在一组匿名函数中实现不同版本的算法。 这样， 你使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。 策略模式（Strategy Pattern）的优缺点如下：\n2.1.优点 算法的封装：策略模式将算法封装在独立的策略类中，使得算法可以独立于使用它的客户端而变化。\n易于扩展：新的策略可以很容易地添加到系统中，而不需要修改现有的代码，符合开闭原则。\n消除条件语句：策略模式可以消除复杂的条件分支语句，使得代码更加简洁和易于维护。\n算法的互换性：策略模式允许在运行时切换不同的算法，使得算法可以像对象一样被创建和销毁。\n提高代码的可读性：通过将算法封装在独立的类中，策略模式使得代码结构更加清晰，易于理解。\n算法的重用：策略模式使得算法可以在不同的上下文中重用，提高了代码的复用性。\n灵活性：策略模式提供了高度的灵活性，允许在不同的时间点选择不同的策略。\n2.2.缺点 客户端必须了解策略：客户端需要了解所有可用的策略，以便能够做出正确的选择。\n策略类的数量增多：如果系统中有大量的策略，可能会导致策略类的数目迅速增长，增加系统的复杂性。\n可能增加内存开销：策略模式可能会增加内存的使用，因为每个策略都是一个对象，需要为其分配内存。\n可能引入复杂性：在某些简单的情况下，策略模式可能会引入不必要的复杂性。\n可能违反里氏替换原则：如果策略类的实现不完全遵循基类或接口的约定，可能会导致里氏替换原则被违反。\n可能影响性能：策略模式可能会影响性能，因为每次切换策略都需要创建新的策略对象，这可能会增加内存分配和对象创建的开销。\n策略模式与简单工厂模式的混淆：在某些情况下，策略模式可能会与简单工厂模式混淆，导致设计上的混淆。\n在使用策略模式时，应该根据具体的应用场景和需求来决定是否采用这种模式。在设计时，应该考虑到策略模式可能带来的复杂性，并确保策略的切换逻辑清晰且易于管理。\n3.策略模式在实际开发中有哪些常见的应用场景？ 策略模式（Strategy Pattern）是一种行为设计模式，它定义了一系列的算法，并将每一个算法封装起来，使它们可以互换使用。策略模式让算法的变化独立于使用算法的客户。在软件开发中，策略模式有多种应用场景，以下是一些常见的例子：\n支付方式选择：在电子商务平台中，用户可以选择不同的支付方式，如信用卡、PayPal、微信支付等。每种支付方式都是一个策略，可以根据用户的选择动态切换。\n排序算法：在需要排序数据时，可能会有多种排序算法，如快速排序、归并排序、冒泡排序等。策略模式允许用户根据需要选择最合适的排序算法。\n图形渲染：在图形处理软件中，不同的图形对象可能需要不同的渲染策略，例如，2D图形和3D图形的渲染方式不同。\n数据访问：在多层架构中，数据访问层可能会使用不同的数据源或访问技术（如数据库、文件系统、远程服务等），策略模式可以用来封装这些不同的访问方式。\n缓存策略：在需要缓存数据的系统中，可能会有多种缓存策略，如LRU（最近最少使用）、FIFO（先进先出）等，策略模式可以用来实现这些不同的缓存策略。\n日志记录：在应用程序中，可能会有多种日志记录方式，如控制台日志、文件日志、数据库日志等。策略模式可以用来根据不同的需要选择不同的日志记录方式。\n用户权限验证：在需要权限控制的系统中，可能会有多种权限验证策略，如基于角色的访问控制（RBAC）、基于属性的访问控制（ABAC）等。\n算法动态切换：在需要根据不同条件动态切换算法的场景中，策略模式可以提供灵活的算法切换机制，例如，根据输入数据的特性选择不同的算法。\n游戏AI行为：在游戏开发中，不同的角色可能会有不同的行为策略，如攻击、防御、逃跑等，策略模式可以用来实现这些不同的行为。\n配置文件解析：在需要解析不同格式配置文件的系统中，如XML、JSON、YAML等，策略模式可以用来封装不同的解析算法。\n策略模式的关键在于它提供了一种方式，使得算法可以在运行时被选择和更换，而不需要修改使用算法的代码。这增加了代码的灵活性和可维护性。\n4.在C++中，如何优化策略模式以提高性能？ 在C++中优化策略模式以提高性能，可以考虑以下几个方面：\n减少动态内存分配：频繁的内存分配和释放会影响性能。可以通过使用对象池（Object Pool）来重用对象，减少动态内存分配的次数。\n利用移动语义：C++11引入了移动语义，它允许资源从一个对象转移到另一个对象，而不需要复制。这可以减少不必要的拷贝操作，提高性能。\n返回值优化（RVO）：编译器可以优化函数返回局部对象时的拷贝操作。确保你的代码能够利用编译器的这种优化。\n使用引用传递：对于大型对象或频繁传递的对象，使用引用传递而不是值传递，可以避免拷贝操作。\n避免不必要的虚函数调用：虚函数调用有一定的开销。如果策略模式中的算法可以是确定的，考虑使用非虚函数或静态多态性（如函数指针或std::function）。\n选择适当的数据结构：使用高效的数据结构可以减少算法的复杂度。例如，使用std::vector而不是std::list，因为std::vector在随机访问时更高效。\n预先分配内存：如果你知道将要使用的资源大小，预先分配足够的内存可以避免在运行时多次分配和释放。\n减少虚函数表查找：虚函数表（v-table）查找会增加额外的开销。在策略模式中，如果可能，使用接口继承来减少虚函数的数量。\n使用constexpr和编译期计算：对于不会改变的策略参数，使用constexpr可以在编译期进行计算，减少运行时的计算负担。\n代码剖析：使用剖析工具（如gprof）来确定性能瓶颈，并针对这些瓶颈进行优化。\n通过这些策略，你可以在保持策略模式灵活性的同时，提高程序的性能。记住，优化应该基于实际的性能数据，而不是盲目地进行。在进行优化之前，最好先进行性能剖析，找出真正的瓶颈所在。\n5.在实际开发中，如何判断一个场景是否适合使用策略模式？ 在实际开发中，判断一个场景是否适合使用策略模式，可以依据以下几个关键点：\n算法的多样性：如果系统中存在多种算法或行为，并且这些算法在功能上相似，但实现方式不同，策略模式可能是一个合适的选择。\n算法的可替换性：如果算法可能会在运行时根据条件变化，或者用户需要能够选择不同的算法，策略模式提供了一种灵活的方式来切换算法。\n算法的独立性：如果算法的实现细节对于客户端来说是透明的，或者客户端不需要知道算法的具体实现，策略模式可以帮助封装算法的细节。\n算法的复杂性：如果算法的实现非常复杂，或者算法可能会随着时间而变化，策略模式可以帮助管理这种复杂性，使得算法的变化不会影响到使用算法的代码。\n客户端的多样性：如果不同的客户端需要不同的算法，或者客户端需要能够根据需要选择不同的算法，策略模式可以提供这种灵活性。\n扩展性：如果预计未来可能会添加更多的算法，策略模式可以使得添加新算法变得更加容易，而不需要修改现有的代码。\n代码的可维护性：如果算法的实现分散在多个地方，或者算法的实现与使用算法的代码紧密耦合，策略模式可以帮助提高代码的可维护性。\n性能考虑：如果算法的性能是一个关键因素，策略模式可以帮助选择最合适的算法，或者在不同的算法之间进行权衡。\n配置的灵活性：如果算法的选择需要通过配置文件或用户输入来决定，策略模式可以使得这种配置变得更加灵活。\n解耦合：如果希望算法的实现与使用算法的代码解耦，策略模式可以帮助实现这一点。\n在考虑使用策略模式时，还可以问自己以下问题：\n是否有多种算法可以解决同一问题？ 是否需要在运行时选择或切换算法？ 是否希望算法的实现对客户端透明？ 是否希望算法的添加、修改或删除对现有代码的影响最小？ 如果对这些问题的回答大多数是肯定的，那么策略模式可能是一个合适的选择。\n6.策略模式在设计时有哪些常见的错误或者陷阱需要避免？ 在设计策略模式时，确实存在一些常见的错误或陷阱，以下是一些需要避免的情况：\n过度使用：策略模式并不是解决所有问题的万能钥匙。如果只有一种算法或者算法的选择不经常变化，使用策略模式可能会导致不必要的复杂性。\n策略类与上下文类耦合：策略模式的目的是将算法的实现与使用算法的代码解耦。如果策略类与上下文类（Context）耦合得太紧密，就会失去策略模式的优势。\n策略接口设计不当：策略接口应该定义清晰且一致的方法，以便不同的策略可以互换。如果接口设计得过于复杂或不一致，可能会导致策略难以实现或替换。\n策略类太多：如果为每种可能的情况都创建一个策略类，可能会导致类的数量过多，增加维护成本。应该考虑是否有一些策略可以合并或者是否有一些策略可以通过参数配置来实现。\n策略选择逻辑复杂：策略的选择逻辑应该简单明了。如果策略选择逻辑过于复杂，可能会使得代码难以理解和维护。\n忽视策略的初始化：策略对象可能需要一些初始化数据才能正确工作。如果忽视了这一点，可能会导致策略对象在运行时出现错误。\n忽视策略的销毁：如果策略对象持有资源（如数据库连接、文件句柄等），则需要确保这些资源在策略对象不再使用时被正确释放。\n策略类的性能问题：策略类的性能可能会影响整个系统的性能。在设计策略时，应该考虑策略的性能，并在必要时进行优化。\n策略类的状态管理：如果策略类持有状态，需要确保状态在策略切换时被正确处理。否则，可能会导致不一致的状态或错误。\n策略类的错误处理：策略类应该能够处理错误，并在出现错误时提供清晰的反馈。如果忽视了错误处理，可能会导致系统在运行时出现不可预测的行为。\n策略类的线程安全性：如果策略对象在多线程环境中使用，需要确保策略对象是线程安全的，或者提供适当的同步机制。\n忽视策略的可测试性：策略模式应该使得策略类易于测试。如果策略类难以测试，可能会影响代码的质量和可维护性。\n在设计策略模式时，应该仔细考虑这些潜在的问题，并采取适当的措施来避免它们。通过合理的设计和实现，策略模式可以提高代码的灵活性、可维护性和可扩展性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-strategy-pattern/","title":"design pattern Strategy Pattern"},{"content":"设计模式-模板方法模式-Template Method Pattern [TOC]\nOverview 模板方法模式（Template Method Pattern）是一种行为设计模式 它在父类中定义了一个算法的框架，允许子类在不改变算法结构的情况下重写算法的某些步骤 这种模式是通过在抽象类中定义一个模板方法来实现的，这个模板方法调用多个其他的方法，这些方法可以是抽象的，可以在子类中得到进一步实现 1.模板方法模式（Template Method Pattern） 模板方法模式（Template Method Pattern）是一种行为设计模式，它在父类中定义了一个算法的框架，允许子类在不改变算法结构的情况下重写算法的某些步骤。这种模式是通过在抽象类中定义一个模板方法来实现的，这个模板方法调用多个其他的方法，这些方法可以是抽象的，可以在子类中得到进一步实现。\n1.1.特点 算法框架：在抽象类中定义算法的步骤。 扩展性：子类可以重写算法的某些步骤，而不需要改变算法的结构。 代码复用：通过模板方法，可以在不同的子类中复用算法框架。 1.2.结构 AbstractClass：定义模板方法和算法框架。 ConcreteClass：实现在抽象类中定义的抽象方法。 1.3.示例代码 在C++中实现模板方法模式，我们通常结合模板类和虚函数来创建一个通用的算法框架，同时允许子类根据需要重写某些步骤。下面是一个使用模板类实现模板方法模式的示例：\n1.3.1.定义模板基类 首先，我们定义一个模板基类，其中包含模板方法和一些虚函数，这些虚函数将在派生类中被重写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 模板基类 template \u0026lt;typename T\u0026gt; class Algorithm { public: // 模板方法 void execute() { step1(); step2(); step3(); } protected: // 抽象步骤，子类必须实现 virtual void step1() = 0; virtual void step2() = 0; virtual void step3() = 0; }; 1.3.2.实现具体步骤 接下来，我们创建一个派生类，实现基类中定义的抽象步骤。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 具体算法类 template \u0026lt;typename T\u0026gt; class ConcreteAlgorithm : public Algorithm\u0026lt;T\u0026gt; { public: void step1() override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteAlgorithm: Step 1\u0026#34; \u0026lt;\u0026lt; std::endl; } void step2() override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteAlgorithm: Step 2\u0026#34; \u0026lt;\u0026lt; std::endl; } void step3() override { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteAlgorithm: Step 3\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 1.3.3.客户端代码 最后，我们编写客户端代码来使用这些类。\n1 2 3 4 5 6 int main() { ConcreteAlgorithm\u0026lt;int\u0026gt; algorithm; algorithm.execute(); // 执行算法 return 0; } 1.3.4.编译和运行 将上述代码保存到一个.cpp文件中，然后使用C++编译器编译并运行。例如，如果你使用g++，可以使用以下命令：\n1 2 g++ -o algorithm algorithm.cpp ./algorithm 1.3.5.输出 运行程序后，你将看到以下输出：\n1 2 3 ConcreteAlgorithm: Step 1 ConcreteAlgorithm: Step 2 ConcreteAlgorithm: Step 3 这个示例展示了如何在C++中使用模板类来实现模板方法模式。这种模式允许你在不改变算法结构的情况下，通过子类重写算法的某些步骤来实现多态性。这种模式在实际开发中非常有用，特别是在需要实现多种相似算法或行为时。\n1.4.应用场景 多个子类有共同的方法：这些方法的实现步骤相同，但具体实现不同。 需要控制扩展：当算法的结构不应改变，但需要在不同的子类中有不同的行为时。 1.5.优点 代码复用：减少代码重复。 扩展性：子类可以扩展算法的某些步骤。 控制反转：算法的控制权在父类，实现在子类。 1.6.缺点 有时可导致设计更加复杂：如果算法的步骤很多，可能会导致设计变得复杂。 模板方法模式是一个很好的工具，用于在保持算法结构不变的情况下，允许子类有选择地实现算法的某些步骤。\n2.模板方法模式优缺点 优点 你可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。 你可将重复代码提取到一个超类中。 缺点 部分客户端可能会受到算法框架的限制。 通过子类抑制默认步骤实现可能会导致违反里氏替换原则。 模板方法中的步骤越多， 其维护工作就可能会越困难。 3.模板方法模式 应用场景 模板方法模式在C++中的使用场景通常涉及到需要在子类中实现算法的某些步骤，同时保持算法的总体结构不变。以下是一些典型的应用场景：\n算法框架：\n当你需要在不同的子类中实现相似的算法时，你可以在基类中定义算法的骨架，然后在每个子类中实现具体的步骤。 数据处理：\n在处理数据时，可能需要执行一系列固定的步骤，如验证、处理和保存数据。模板方法模式可以定义这些步骤的顺序，而具体的处理逻辑则由子类实现。 用户界面操作：\n用户界面操作通常遵循一定的模式，如初始化界面、处理用户输入、更新界面和清理资源。模板方法模式可以用来定义这些步骤，而具体的界面元素和事件处理则由子类实现。 游戏开发：\n在游戏开发中，不同类型的游戏可能需要遵循相似的游戏循环，如初始化游戏、开始游戏、处理游戏逻辑和结束游戏。模板方法模式可以用来定义这些步骤，而具体的游戏逻辑则由子类实现。 数据库访问：\n数据库访问通常包括连接数据库、执行查询、处理结果和关闭连接等步骤。模板方法模式可以用来定义这些步骤，而具体的数据库操作则由子类实现。 设计模式实现：\n许多设计模式，如建造者模式、工厂方法模式等，可以通过模板方法模式来实现，以确保在创建复杂对象时遵循一定的步骤。 测试框架：\n在测试框架中，测试过程可能包括设置测试环境、执行测试用例、验证结果和清理测试环境等步骤。模板方法模式可以用来定义这些步骤，而具体的测试逻辑则由测试用例类实现。 插件架构：\n在插件架构中，插件可能需要遵循一定的生命周期，如初始化、激活、执行和停用。模板方法模式可以用来定义这些生命周期的执行顺序，而具体的插件逻辑则由子类实现。 报表生成：\n报表生成通常包括数据收集、数据过滤、数据排序和生成报表等步骤。模板方法模式可以用来定义这些步骤的执行顺序，而具体的报表格式和数据源则由子类实现。 文件处理：\n在处理不同类型文件时，可能需要执行一系列相似的步骤，如打开文件、读取内容、处理数据和关闭文件。模板方法模式可以用来定义这些步骤，而具体的文件格式处理则由子类实现。 在实际开发中，模板方法模式有助于减少代码重复，提高代码的可维护性和可扩展性。通过定义一个通用的算法框架，你可以在不同的上下文中重用这个框架，同时允许子类提供特定的实现细节。\n4.如何用模板方法模式解决实际开发中的特定问题？ 使用模板方法模式解决实际开发中的特定问题通常涉及以下步骤：\n识别算法框架：\n确定问题域中的通用算法框架，即一系列步骤，这些步骤在不同的场景中都是相似的，但每个步骤的具体实现可能有所不同。 定义抽象基类：\n创建一个抽象基类，其中包含模板方法和一系列抽象步骤。模板方法是算法框架的实现，它调用这些抽象步骤。 实现具体步骤：\n为每个步骤提供默认实现（如果可能），或者声明它们为纯虚函数，要求子类提供具体实现。 创建具体子类：\n为每种特定场景创建一个子类，重写基类中的抽象步骤，以提供特定于场景的实现。 使用算法：\n在客户端代码中，使用基类指针或引用来操作子类对象，利用多态性执行模板方法。 4.1.示例：报表生成器 假设我们需要开发一个报表生成器，它可以生成不同类型的报表，但所有报表生成过程都遵循相同的步骤：收集数据、处理数据、格式化输出。\n步骤 1：定义抽象基类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; // 抽象基类 class Report { public: // 模板方法 virtual void generate() { collectData(); processData(); outputData(); } protected: virtual void collectData() = 0; virtual void processData() = 0; void outputData() { std::cout \u0026lt;\u0026lt; \u0026#34;Outputting data...\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 步骤 2：创建具体子类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 具体子类：财务报表 class FinancialReport : public Report { protected: void collectData() override { std::cout \u0026lt;\u0026lt; \u0026#34;Collecting financial data...\u0026#34; \u0026lt;\u0026lt; std::endl; } void processData() override { std::cout \u0026lt;\u0026lt; \u0026#34;Processing financial data...\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体子类：销售报表 class SalesReport : public Report { protected: void collectData() override { std::cout \u0026lt;\u0026lt; \u0026#34;Collecting sales data...\u0026#34; \u0026lt;\u0026lt; std::endl; } void processData() override { std::cout \u0026lt;\u0026lt; \u0026#34;Processing sales data...\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 步骤 3：使用算法 1 2 3 4 5 6 7 8 9 10 11 int main() { std::unique_ptr\u0026lt;Report\u0026gt; report; report = std::make_unique\u0026lt;FinancialReport\u0026gt;(); report-\u0026gt;generate(); report = std::make_unique\u0026lt;SalesReport\u0026gt;(); report-\u0026gt;generate(); return 0; } 4.2.输出 1 2 3 4 5 6 Collecting financial data... Processing financial data... Outputting data... Collecting sales data... Processing sales data... Outputting data... 在这个例子中，Report 类定义了报表生成的模板方法，包括收集数据、处理数据和输出数据的步骤。FinancialReport 和 SalesReport 类分别实现了这些步骤的具体逻辑。客户端代码通过基类指针来操作不同的报表对象，实现了多态性。\n通过这种方式，模板方法模式帮助我们定义了一个通用的算法框架，同时允许在不同的子类中实现特定的步骤，使得代码更加模块化和可扩展。\n5.在实际开发中，如何确定一个算法是否适合使用模板方法模式？ 在实际开发中，确定一个算法是否适合使用模板方法模式，可以通过以下几个关键点来评估：\n算法的稳定性：\n算法的总体结构是否稳定，而只有某些步骤的具体实现会变化。如果算法的核心步骤在不同情况下保持不变，那么它可能适合使用模板方法模式。 步骤的多样性：\n算法是否包含多个步骤，其中一些步骤在不同情况下有不同的实现。模板方法模式允许在基类中定义算法框架，而将具体实现留给子类。 多态性的需求：\n是否需要通过多态性来处理不同类型的对象。模板方法模式通过在基类中定义模板方法和在子类中重写步骤，可以实现多态性。 代码复用：\n是否希望在不同的子类中复用算法框架。如果算法的某些步骤在多个子类中是通用的，那么使用模板方法模式可以减少代码重复。 扩展性：\n是否需要在未来可能添加新的步骤或子类。模板方法模式提供了良好的扩展性，允许在不修改现有代码的情况下添加新的步骤或子类。 控制反转：\n是否希望在基类中控制算法的流程，而在子类中提供具体实现。模板方法模式将算法的控制权集中在基类，而将实现细节留给子类。 复杂性管理：\n算法是否足够复杂，以至于将其分解为多个步骤可以提高代码的可读性和可维护性。模板方法模式可以帮助管理复杂性，通过将算法分解为更小的、可管理的步骤。 客户端代码的简洁性：\n是否希望客户端代码能够简洁地使用算法，而不需要关心具体的实现细节。模板方法模式允许客户端通过基类接口来使用算法，而具体的实现细节由子类处理。 设计原则的遵循：\n是否符合开闭原则（对扩展开放，对修改封闭）。模板方法模式允许在不修改现有代码的情况下扩展新的步骤或子类，符合开闭原则。 上下文环境：\n考虑项目的具体上下文，例如团队的熟悉度、项目的时间线、维护成本等。如果团队对模板方法模式熟悉，且项目允许一定程度的设计工作，那么使用模板方法模式可能是合适的。 通过考虑这些因素，你可以决定一个算法是否适合使用模板方法模式。如果算法符合上述多数条件，那么使用模板方法模式可能是一个合适的选择，它可以帮助提高代码的可维护性、可扩展性和复用性。\n6.如何在我的项目中实现模板方法模式？ 在你的项目中实现模板方法模式，可以遵循以下步骤：\n6.1. 确定适用场景 首先，确保你的场景适合使用模板方法模式。这通常意味着你有一个算法框架，它在多个类中是通用的，但某些步骤需要在子类中定制。\n6.2. 定义抽象基类 创建一个抽象基类，它定义了模板方法和算法的框架。这个类将包含：\n模板方法：一个或多个步骤组成的算法，这些步骤通过调用抽象操作来执行。 抽象操作：定义为纯虚函数（pure virtual functions），子类必须实现这些函数。 6.3. 实现具体步骤 在抽象基类中实现一些步骤，这些步骤可以是具体的，也可以是抽象的。具体的步骤可以直接提供实现，而抽象步骤则留给子类实现。\n6.4. 创建具体子类 为每个需要定制算法步骤的场景创建子类。这些子类将实现抽象基类中定义的抽象步骤。\n6.5. 使用多态 在客户端代码中，使用抽象基类的指针或引用来操作子类对象。这样，你可以利用多态性在运行时调用正确的子类实现。\n6.5.1.示例实现 假设你正在开发一个支付系统，其中不同的支付方式（如信用卡、PayPal、银行转账）需要执行相似的步骤，但每个步骤的具体实现不同。\n步骤 1：定义抽象基类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class PaymentProcessor { public: // 模板方法 void processPayment() { authorizePayment(); capturePayment(); finalizePayment(); } protected: // 抽象步骤 virtual void authorizePayment() = 0; virtual void capturePayment() = 0; virtual void finalizePayment() = 0; }; 步骤 2：创建具体子类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class CreditCardProcessor : public PaymentProcessor { protected: void authorizePayment() override { std::cout \u0026lt;\u0026lt; \u0026#34;Authorizing credit card payment.\u0026#34; \u0026lt;\u0026lt; std::endl; } void capturePayment() override { std::cout \u0026lt;\u0026lt; \u0026#34;Capturing credit card payment.\u0026#34; \u0026lt;\u0026lt; std::endl; } void finalizePayment() override { std::cout \u0026lt;\u0026lt; \u0026#34;Finalizing credit card payment.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class PayPalProcessor : public PaymentProcessor { protected: void authorizePayment() override { std::cout \u0026lt;\u0026lt; \u0026#34;Authorizing PayPal payment.\u0026#34; \u0026lt;\u0026lt; std::endl; } void capturePayment() override { std::cout \u0026lt;\u0026lt; \u0026#34;Capturing PayPal payment.\u0026#34; \u0026lt;\u0026lt; std::endl; } void finalizePayment() override { std::cout \u0026lt;\u0026lt; \u0026#34;Finalizing PayPal payment.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 步骤 3：使用多态 1 2 3 4 5 6 7 8 9 10 11 12 13 int main() { PaymentProcessor* processor = new CreditCardProcessor(); processor-\u0026gt;processPayment(); delete processor; // 清理资源 processor = new PayPalProcessor(); processor-\u0026gt;processPayment(); delete processor; // 清理资源 return 0; } 6.6. 测试和验证 确保你的实现符合预期，通过单元测试验证每个子类的正确性，以及模板方法模式的整体行为。\n6.7. 文档和维护 为你的代码编写文档，说明模板方法模式的使用和每个类的职责。随着项目的进展，维护和扩展你的模板方法实现。\n通过这些步骤，你可以在你的项目中有效地实现模板方法模式，提高代码的可重用性和可维护性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-template-method-pattern/","title":"design pattern Template Method Pattern"},{"content":"设计模式-访问者模式-Visitor Pattern [TOC]\nOverview 访问者模式（Visitor Pattern）是一种行为设计模式 它允许你为一个对象结构（比如组合结构）增加新的能力，而不需要改变结构中的类 这种模式通过创建一个访问者类，它能够访问并操作对象结构中的元素，从而实现对元素的操作和结构的分离 1.访问者模式（Visitor Pattern） 访问者模式（Visitor Pattern）是一种行为设计模式，它允许你为一个对象结构（比如组合结构）增加新的能力，而不需要改变结构中的类。这种模式通过创建一个访问者类，它能够访问并操作对象结构中的元素，从而实现对元素的操作和结构的分离。\n1.1.访问者模式的组成部分 元素接口（Element）：定义一个 accept 方法，它接受一个访问者对象。 具体元素（ConcreteElement）：实现元素接口，实现 accept 方法，让访问者访问该元素。 访问者接口（Visitor）：为每种类型的元素声明一个访问方法，这样让访问者可以访问元素。 具体访问者（ConcreteVisitor）：实现每个访问者接口中的方法，定义对每种元素的访问操作。 1.2.C++实现示例 下面是一个简单的C++示例，演示了如何实现访问者模式：\n定义元素接口和具体元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 元素接口 class Element { public: virtual void accept(class Visitor* visitor) = 0; virtual ~Element() {} }; // 具体元素A class ConcreteElementA : public Element { public: void accept(Visitor* visitor) override { visitor-\u0026gt;visit(this); } void operationA() { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteElementA operation\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 具体元素B class ConcreteElementB : public Element { public: void accept(Visitor* visitor) override { visitor-\u0026gt;visit(this); } void operationB() { std::cout \u0026lt;\u0026lt; \u0026#34;ConcreteElementB operation\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 定义访问者接口和具体访问者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 访问者接口 class Visitor { public: virtual void visit(ConcreteElementA* element) = 0; virtual void visit(ConcreteElementB* element) = 0; virtual ~Visitor() {} }; // 具体访问者 class ConcreteVisitor : public Visitor { public: void visit(ConcreteElementA* element) override { element-\u0026gt;operationA(); } void visit(ConcreteElementB* element) override { element-\u0026gt;operationB(); } }; 客户端代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main() { ConcreteElementA* elementA = new ConcreteElementA(); ConcreteElementB* elementB = new ConcreteElementB(); ConcreteVisitor* visitor = new ConcreteVisitor(); elementA-\u0026gt;accept(visitor); elementB-\u0026gt;accept(visitor); delete elementA; delete elementB; delete visitor; return 0; } 1.3.输出 1 2 ConcreteElementA operation ConcreteElementB operation 1.4.说明 在这个示例中，Element 是元素接口，ConcreteElementA 和 ConcreteElementB 是具体元素，它们实现了 accept 方法。Visitor 是访问者接口，ConcreteVisitor 是具体访问者，它实现了对每种元素的访问操作。\n客户端代码创建了元素和访问者的实例，并通过调用 accept 方法，让访问者访问每个元素。\n1.5.应用场景 访问者模式适用于以下场景：\n操作复杂：当你需要对一个对象结构中的元素执行多种操作，并且这些操作经常变化时。 结构稳定：当你的对象结构稳定，但需要增加新操作时，使用访问者模式可以在不修改结构的情况下增加新操作。 分离操作和对象：当你希望将操作和对象结构分离，使得操作可以独立于结构变化时。 1.6.总结 访问者模式提供了一种将操作和对象结构分离的方法，使得你可以在不修改对象结构的情况下增加新操作。这种模式在处理复杂对象结构和需要动态添加操作的场景中非常有用。\n2.访问者模式优缺点 优点 开闭原则。 你可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改。 单一职责原则。 可将同一行为的不同版本移到同一个类中。 访问者对象可以在与各种对象交互时收集一些有用的信息。 当你想要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助。 缺点 每次在元素层次结构中添加或移除一个类时， 你都要更新所有的访问者。 在访问者同某个元素进行交互时， 它们可能没有访问元素私有成员变量和方法的必要权限。 访问者模式（Visitor Pattern）是一种允许你添加新的操作到对象结构上，而无需改变对象结构本身的设计模式。它通过引入一个访问者接口来实现，该接口可以对各种元素类进行操作。以下是访问者模式的一些优缺点：\n2.1.优点 分离操作和对象结构：\n访问者模式将算法和对象结构分离，使得操作可以在不修改对象结构的情况下增加。 扩展性：\n可以在不修改已有类的基础上，通过添加新的访问者来扩展新的操作。 集中相关操作：\n将多个操作集中到一个访问者中，可以简化系统结构，提高操作的组织性。 解耦操作和对象：\n访问者模式使得操作和对象的耦合度降低，因为对象不需要知道谁来访问它们。 复用性：\n访问者可以被复用，同一个访问者可以用于不同的对象结构。 2.2.缺点 违反了单一职责原则：\n访问者模式可能会使得访问者承担过多的职责，因为它需要包含所有元素类型的操作。 增加新的元素类困难：\n如果要增加新的元素类，可能需要在访问者接口中添加新的访问方法，这可能需要修改所有访问者的实现，违反了开闭原则。 违反了里氏替换原则：\n由于访问者模式需要在元素类中添加 accept 方法，这可能会使得子类违反里氏替换原则。 增加系统的复杂性：\n引入访问者模式会增加系统的复杂度，因为需要额外的访问者类和接口。 违反了依赖倒置原则：\n元素类依赖于访问者接口，这违反了依赖倒置原则，即高层模块不应该依赖于低层模块，两者都应该依赖于抽象。 难以维护：\n随着访问者数量的增加，维护和更新访问者模式变得更加困难。 不适合频繁修改的结构：\n如果对象结构经常变化，那么每次变化都可能需要修改访问者的代码，这会增加维护成本。 2.3.总结 访问者模式是一种强大的模式，它允许你向对象结构添加新的操作而不需要修改对象结构本身。然而，它也带来了一些缺点，如增加系统复杂性和维护难度。因此，在决定使用访问者模式时，需要权衡其优缺点，确保它适合你的应用场景。通常，当对象结构相对稳定，而需要对结构中的元素执行多种操作时，访问者模式是一个不错的选择。\n3.访问者模式在处理哪些类型的编程问题时特别有用，能否给出一些具体的场景？ 访问者模式特别适用于以下类型的编程问题：\n复杂的对象结构：\n当你有一个复杂的对象结构（如组合模式创建的树形结构），并且希望执行的操作依赖于多种不同类型的元素时。 需要扩展的操作集合：\n当对象结构的操作集合经常变化，或者你希望在不修改对象结构的情况下添加新操作时。 对象结构的第三方扩展：\n当对象结构可能会被第三方扩展，而你希望第三方能够在不修改现有代码的情况下添加新的操作。 复杂的数据处理：\n在数据处理应用中，需要对数据结构中的元素执行多种复杂的、不相关的操作，如统计、转换、输出等。 对象结构的分析：\n在需要对对象结构进行分析并生成报告时，如代码分析工具中对代码结构的检查和报告。 对象结构的验证：\n在需要对对象结构进行验证或校验时，如软件设计中的约束检查。 对象结构的转换：\n当需要将一种对象结构转换为另一种结构或格式时，如在不同数据模型之间转换数据。 3.1.具体场景示例 XML或HTML文档处理：\n你可以定义一个文档元素的类层次结构，然后使用访问者模式来执行如打印、解析、验证或转换文档的操作。 编译器设计：\n在编译器中，可以使用访问者模式来实现语法分析树的遍历，对不同的语法结构节点执行不同的语义分析或代码生成操作。 报表生成：\n在报表系统中，对象结构可能包含各种财务数据，访问者可以执行生成不同格式报表的操作，如PDF、Excel或HTML。 图形编辑器：\n在图形编辑器中，可以定义一个图形元素的类层次结构，访问者可以执行不同的操作，如渲染、转换格式、应用滤镜等。 软件设计审核：\n在软件设计审核工具中，可以使用访问者模式来检查设计模式的使用、代码规范的遵守或潜在的设计问题。 数据模型转换：\n在需要将数据从一个模型转换到另一个模型时，可以使用访问者模式来遍历源模型并构建目标模型。 游戏开发：\n在游戏开发中，对象结构可能包含不同类型的游戏元素，如角色、敌人、物品等。访问者模式可以用来执行如AI行为、渲染、碰撞检测等操作。 插件架构：\n在插件架构中，访问者模式可以用来允许插件对主程序的对象结构执行特定的操作，而不需要修改主程序的代码。 使用访问者模式时，重要的是要确保对象结构相对稳定，而操作经常变化或可能由第三方扩展。这样可以最大化地发挥访问者模式的优势，同时避免其缺点。\n4.访问者模式在处理并发问题时有哪些优势和局限性？ 访问者模式在处理并发问题时的优势和局限性如下：\n4.1.优势 分离关注点：访问者模式将数据结构与操作逻辑分离，使得并发操作可以在不改变元素类的情况下实现，从而提高了代码的可维护性和可扩展性 。 扩展性：在并发环境中，可以轻松添加新的访问者来处理并发操作，而无需修改现有的元素类，这符合开闭原则 。 集中管理：可以在访问者中集中处理并发问题，例如同步和锁管理，而不是在每个元素类中分散处理 。 灵活性：通过访问者模式，可以在运行时动态选择不同的访问者来处理并发操作，提高了系统的灵活性 。 4.2.局限性 复杂性增加：并发环境下，访问者模式可能会增加系统的复杂性，因为需要考虑线程安全和并发控制等问题 。 性能考虑：在高并发场景下，访问者模式可能会导致性能瓶颈，因为所有的操作都通过访问者进行，可能会增加额外的开销 。 同步问题：在并发访问共享资源时，需要在访问者中妥善处理同步和并发控制，否则可能会导致数据不一致或竞态条件 。 调试难度：由于访问者模式增加了系统的复杂性，调试并发问题可能会变得更加困难 。 在实际应用中，访问者模式可以用于处理多种并发操作，例如在多线程环境中对对象结构进行操作。然而，设计者需要仔细考虑并发控制和性能优化，以确保系统的稳定性和效率。\n5.在实际开发中，如何避免访问者模式带来的性能瓶颈问题？ 在实际开发中，避免访问者模式带来的性能瓶颈问题可以采取以下策略：\n优化访问者算法：确保访问者执行的操作尽可能高效，减少不必要的计算和资源消耗。\n减少访问者数量：合理设计系统，避免创建过多的访问者类，每个访问者类都应该有明确的职责。\n使用默认访问者：为新添加的元素类提供一个默认的访问者实现，这样在不修改现有访问者的情况下也能处理新元素。\n避免频繁的访问者调用：在设计时考虑是否真的需要对每个元素都应用访问者，有时候可以通过设计模式如组合模式来减少对访问者的依赖。\n并发访问者执行：如果可能，可以考虑并行处理元素，特别是在处理大量元素时。这可能需要在访问者的设计中考虑线程安全问题。\n延迟计算：对于复杂的操作，可以考虑使用延迟计算（Lazy Evaluation）策略，只有在真正需要结果时才执行计算。\n资源池：对于资源密集型的操作，可以考虑使用资源池来管理资源，避免频繁的资源申请和释放带来的开销。\n监控和调优：使用性能监控工具来分析系统的性能瓶颈，并根据监控结果对访问者模式的使用进行调优。\n批量处理：在处理大量元素时，可以考虑批量处理元素，减少遍历次数和访问者的调用次数。\n代码优化：对访问者模式的代码进行优化，包括减少方法调用、优化数据结构、使用更高效的算法等。\n通过上述策略，可以在保持访问者模式带来的好处的同时，减少其可能引入的性能问题。在实际应用中，需要根据具体情况灵活选择和调整这些策略。\n6.如何通过代码优化来减少访问者模式的性能开销？ 通过代码优化来减少访问者模式的性能开销，可以考虑以下几个方面：\n优化算法逻辑：\n确保访问者中的算法尽可能高效，避免不必要的计算和资源消耗。 减少循环中的重复操作，例如通过缓存结果来避免重复的数据库查询或重复的计算。 减少对象创建：\n访问者模式可能会创建多个访问者对象，尤其是在频繁调用的情况下。可以考虑重用访问者对象，而不是每次都创建新的实例。 避免过度设计：\n只在真正需要的时候使用访问者模式。如果操作不复杂或者不经常变化，直接在元素类中实现可能更高效。 使用高效的数据结构：\n选择合适的数据结构来存储元素，以减少访问者遍历元素时的性能开销。例如，使用索引或者哈希表来快速定位元素。 并行处理：\n如果访问者的操作是独立的，可以考虑使用多线程或者并发库来并行处理元素，以提高性能。 延迟计算：\n对于复杂的计算，可以使用延迟计算（Lazy Evaluation）策略，只有在真正需要结果时才执行计算。 减少方法调用：\n减少访问者和元素之间的方法调用次数，可以通过直接访问数据或者将多个操作合并到一个方法调用来实现。 使用访问者组合：\n如果有多个访问者执行相似的操作，可以考虑将它们组合成一个访问者，以减少遍历次数。 优化接受方法：\n在元素的 accept 方法中，直接调用访问者的方法，避免不必要的中间步骤。 避免在访问者中使用循环：\n尽量在对象结构中使用循环来遍历元素，而不是在访问者中。这样可以减少访问者需要处理的逻辑。 使用轻量级的访问者：\n确保访问者对象尽可能轻量，避免在访问者中包含不必要的状态或者资源。 代码剖析和性能测试：\n使用代码剖析工具来分析性能瓶颈，并进行针对性的优化。 定期进行性能测试，确保优化后的代码达到了预期的性能提升。 合理使用继承和组合：\n在设计元素类和访问者类时，合理使用继承和组合，避免过度使用继承带来的复杂性和性能开销。 通过这些代码优化策略，可以有效地减少访问者模式在实际应用中的性能开销，提高程序的运行效率。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/design-pattern-visitor-pattern/","title":"design pattern Visitor Pattern"},{"content":"设计模式-常见的设计原则或最佳实践 [TOC]\nOverview 1.在设计模式中，有哪些常见的设计原则或最佳实践？ 在设计模式中，有哪些常见的设计原则或最佳实践？ What are the common design principles or best practices in design patterns?\n在设计模式中，有一些核心的设计原则和最佳实践，它们帮助开发者创建灵活、可维护和可扩展的软件系统。以下是一些常见的设计原则：\n单一职责原则（Single Responsibility Principle, SRP）： 每个类应该只有一个引起它变化的原因，即每个类应该只负责一项任务。\n开放-封闭原则（Open-Closed Principle, OCP）： 软件实体应该对扩展开放，对修改关闭。这意味着设计时应当使软件模块易于扩展，但不需要修改现有代码。\n里氏替换原则（Liskov Substitution Principle, LSP）： 子类对象必须能够替换掉它们的父类对象，而不影响程序的行为。\n接口隔离原则（Interface Segregation Principle, ISP）： 客户端不应该依赖于它不使用的接口。应该将大的接口拆分成小的、特定的接口。\n依赖倒置原则（Dependency Inversion Principle, DIP）： 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。\n最少知识原则（Law of Demeter, LoD）： 一个对象应该对其他对象有最少的了解。只与你的直接朋友通信，不与“朋友的朋友”通信。\n合成/聚合复用原则（Composite Reuse Principle, CRP）： 尽量使用对象的合成/聚合，而不是通过继承来复用代码。\n迪米特法则（Principle of Least Knowledge, POLK）： 一个对象应该对其他对象有最少的了解，只与直接的朋友通信，不与“朋友的朋友”通信。\n好莱坞原则（Hollywood Principle）： “别调用我们，我们会调用你”。组件应该提供接口供其他组件使用，而不是主动调用其他组件。\nSOLID原则： SOLID是上述前五个原则的首字母缩写，它是一个整体的设计原则集合，用于指导面向对象设计。\nYAGNI（You Aren\u0026rsquo;t Gonna Need It）： 不要为未来可能的需求添加代码，只实现当前需要的功能。\nKISS（Keep It Simple, Stupid）： 保持设计简单，避免不必要的复杂性。\nDRY（Don\u0026rsquo;t Repeat Yourself）： 避免代码重复。重复的代码会导致维护困难。\nLOD（Learning Opportunities Daily）： 每天都是学习的机会，鼓励开发者不断学习和改进。\nWET（Write Everything Twice）： 在某些情况下，为了保持代码的清晰和简单，重复编写代码可能是可接受的。\n这些原则和最佳实践不是一成不变的规则，而是指导软件开发过程中的思考和决策的工具。在实际应用中，开发者需要根据具体情况灵活运用这些原则。\n2.如何将单一职责原则应用到实际的软件开发中？ 单一职责原则（Single Responsibility Principle, SRP）是面向对象设计原则之一，它指出一个类应该只有一个引起它变化的原因。在实际的软件开发中，应用单一职责原则可以提高代码的可维护性、可读性和可测试性。以下是一些将单一职责原则应用到实际软件开发中的策略：\n明确类的功能： 在设计类时，首先明确这个类应该承担的功能。如果一个类承担了多个功能，考虑将其拆分成多个类。\n避免“万能”类： 避免创建一个类来处理所有事情。例如，一个类不应该同时负责数据访问、业务逻辑和用户界面。\n使用职责分离： 将不同的职责分离到不同的类中。例如，如果一个类既处理用户输入也处理数据存储，应该将其拆分为一个输入处理类和一个数据访问类。\n抽象和封装： 通过抽象和封装来隐藏类的内部实现细节，只暴露与类职责相关的接口。\n接口和抽象类： 使用接口和抽象类来定义类应该实现的行为，而不是具体的实现细节。\n服务定位器模式： 使用服务定位器模式来解耦类之间的依赖关系，使得类只关注自己的职责。\n依赖注入： 通过依赖注入（Dependency Injection）来提供类需要的外部依赖，而不是让类自己创建或查找这些依赖。\n模块化： 将应用程序分解为多个模块，每个模块只负责一部分功能。\n持续重构： 在开发过程中，持续地重构代码，以确保每个类都只承担单一职责。\n编写单元测试： 编写单元测试来验证类的职责。如果一个类有多个职责，编写测试可能会变得复杂。\n避免条件语句： 如果一个类中包含大量的条件语句（如if-else或switch-case），这可能是该类承担了多个职责的信号。\n使用职责链模式： 如果存在多个对象处理请求，可以使用职责链模式来确保每个对象只处理它负责的请求部分。\n领域驱动设计（DDD）： 使用领域驱动设计来定义领域模型，确保每个实体或服务都只处理与其领域相关的职责。\n通过将单一职责原则应用到软件开发中，可以创建出更加模块化、灵活和易于维护的系统。然而，也要注意不要过度分解类，这可能会导致系统过于复杂。正确的平衡是关键。\n3.如何识别一个类是否违反了单一职责原则？ 识别一个类是否违反了单一职责原则通常可以通过以下几个步骤和迹象来判断：\n检查类的方法数量： 如果一个类有过多的方法，这可能意味着它承担了多个职责。虽然这不是绝对的标准，但可以作为一个初步的警示。\n分析方法的多样性： 查看类中的方法是否服务于不同的目的。如果方法之间没有明显的联系，或者它们处理的问题领域不同，这可能是违反单一职责原则的迹象。\n检查类的属性： 如果一个类包含了多种类型的属性，这些属性服务于不同的功能，这可能表明类承担了多个职责。\n评估条件语句： 如果一个类中包含大量的条件语句（如if-else或switch-case），并且这些条件语句处理的是类的不同功能，这可能是违反单一职责原则的信号。\n观察类的变化原因： 如果发现类需要因为多种不同的原因而改变，这可能意味着它承担了多个职责。例如，如果一个类既处理用户界面也处理业务逻辑，那么用户界面的变化和业务逻辑的变化都会导致这个类的变化。\n检查类是否参与多个业务流程： 如果一个类在多个业务流程中扮演不同的角色，这可能意味着它承担了多个职责。\n评估类的命名： 如果类名不够具体或者包含了多个名词，这可能表明它承担了多个职责。一个好的类名应该清晰地反映出它的职责。\n检查类是否依赖于多个外部接口： 如果一个类依赖于多个不同的外部接口，并且这些接口服务于不同的功能，这可能是违反单一职责原则的迹象。\n考虑类的可测试性： 如果发现很难为类编写单元测试，或者需要模拟多个不同的依赖来测试类的不同部分，这可能意味着类承担了多个职责。\n使用代码度量工具： 可以使用代码度量工具来分析类的复杂度，如圈复杂度、方法数、类内聚性等，这些度量可以帮助识别可能违反单一职责原则的类。\n团队讨论和代码审查： 通过团队讨论和代码审查，可以发现类是否承担了过多的职责，以及是否有更好的设计选择。\n识别违反单一职责原则的类是一个持续的过程，需要开发者保持对代码的敏感度和对设计原则的理解。通过重构和优化，可以逐步改善代码结构，使其更加符合单一职责原则。\n4.能否提供一些实际的案例，说明这些设计原则是如何帮助解决实际问题的？ 设计原则在软件开发中扮演着至关重要的角色，它们帮助开发者创建出高质量、易于维护和扩展的软件系统。以下是一些实际案例，展示了这些设计原则是如何帮助解决实际问题的：\n单一职责原则（SRP）：\n例如，在电商平台中，订单类（Order）可能同时负责处理订单逻辑、计算总价、打印订单信息以及保存订单到数据库。遵循单一职责原则，这些功能可以被分离到OrderCalculator、OrderPrinter和OrderRepository等不同的类中，每个类只处理一项任务 。 开闭原则（OCP）：\n在支付系统中，可能需要支持多种支付方式，如信用卡、PayPal、微信支付等。通过使用开闭原则，系统可以在不修改现有代码的情况下，通过添加新的支付方式类来扩展功能，这些类都实现同一个支付接口 。 里氏替换原则（LSP）：\n在图形界面编程中，基础控件类如Button可能设计为可拖拽。如果RadioButton继承自Button，但它不需要拖拽功能，那么RadioButton不应该重写Button的拖拽方法，以保证继承体系的稳定性 。 接口隔离原则（ISP）：\n考虑一个内容管理系统，如果有一个庞大的接口ContentEditor，它包含了编辑文本、图片、视频等所有功能。根据接口隔离原则，这些功能可以被分离到TextEditor、ImageEditor和VideoEditor等更小的接口中，使得实现类只需要依赖它们实际使用的方法 。 依赖倒置原则（DIP）：\n在构建一个应用程序时，如果高层策略类直接依赖于低层的实现类，这将导致代码难以维护和扩展。依赖倒置原则提倡高层模块应该依赖于抽象，这样可以通过抽象层来注入具体的实现，从而降低模块间的耦合度 。 合成/聚合复用原则（CARP）：\n在设计一个企业资源规划（ERP）系统时，可以使用合成或聚合来组合不同的业务组件，如订单处理、库存管理和客户关系管理等。这种设计允许系统灵活地添加或替换组件，而不需要对整个系统进行大规模重构 。 尼尔森十大设计原则：\n例如，腾讯视频通过互动组件和视频进度条的结合，提升了用户参与感和个性化体验 。美团App通过设计心理学和实时活动组件，增强了用户的操控感并缓解了等待焦虑 。 UI设计原则：\n对齐原则确保界面元素有序排列，提升美观性 。格式塔原理中的亲密性原则帮助设计师通过元素的接近程度来创建视觉上的整体感 。 模块化设计：\n通过将软件系统划分为独立的模块，每个模块有明确的接口和功能定义，可以降低复杂性并提高可维护性 。 健壮性设计：\n例如，当软件遇到错误输入或操作时，通过异常处理机制能够保持稳定运行，并给出有用的错误提示 。 通过这些案例，我们可以看到设计原则在实际软件开发中的应用，它们帮助开发者构建出更加健壮、灵活和用户友好的软件系统。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E6%88%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-design_principles_or_best_practices/","title":"设计模式-常见的设计原则或最佳实践 design_principles_or_best_practices"},{"content":"Overview [TOC]\n在设计模式中，有哪些常见的设计原则或最佳实践？ What are the common design principles or best practices in design patterns?\n设计原则 design_principles_or_best_practices 23种 设计模式 创建式模式Creative Mode 工厂方法模式 factory_method_mode 抽象工厂模式 abstract_factory 生成器模式 builder_pattern 原型模式 prototype_pattern 单例模式 singleton_pattern 结构型模式Structural pattern 适配器模式 adapter_pattern 桥接模式 bridge_pattern 组合模式 composite_pattern 装饰模式 decorator_pattern 外观模式 facade_pattern 享元模式 flyweight_pattern 代理模式 proxy_pattern 行为模式Behavioral patterns 责任链模式 chain_of_responsibility_pattern 命令模式 command_pattern 选代器模式 iterator_pattern 中介者模式 mediator_pattern 备忘录模式 memento_pattern 观察者模式 observer_pattern 状态模式 state_pattern 策略模式 strategy_pattern 模板方法模式 template_method_pattern 访问者模式 visitor_pattern 解释器模式 interpreter_pattern 关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%B3%BB%E5%88%97/","title":"设计模式-系列"},{"content":"设计模式-结构性模式-structural patterns [TOC]\nOverview 1.结构性模式（Structural Patterns） 结构性模式（Structural Patterns）是软件设计模式的一种，它们主要关注如何将对象和类组装成较大的结构，同时保持结构的灵活和可复用。以下是七种常见的结构性设计模式：\n适配器模式（Adapter Pattern）：\n允许对象间的接口不兼容问题得以解决，使得原本因接口不兼容而不能一起工作的类可以一起工作。 装饰器模式（Decorator Pattern）：\n动态地给一个对象添加额外的职责，同时又不改变其结构。装饰器模式提供了一种灵活的替代方案，用于扩展对象的功能。 代理模式（Proxy Pattern）：\n为另一个对象提供一个代替或占位符，以控制对它的访问。代理可以在不改变对象的代码的前提下，增加访问的控制或其他额外功能。 外观模式（Facade Pattern）：\n提供了一个统一的高层接口，用于访问子系统中的一群接口。外观模式定义了一个高层接口，使得子系统更易于使用。 桥接模式（Bridge Pattern）：\n将抽象部分与其实现部分分离，使它们可以独立地变化。桥接模式主要用于把抽象与实现解耦，让它们可以独立地扩展。 组合模式（Composite Pattern）：\n允许你将对象组合成树形结构，以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 享元模式（Flyweight Pattern）：\n用于减少创建对象的数量，分享细粒度的对象。享元模式通过共享对象来支持大量细粒度对象的高效使用。 结构性模式的应用场景包括但不限于：\n适配器模式：适用于需要整合具有不同接口的现有子系统或第三方库的场景。 装饰器模式：适用于需要动态地给对象添加职责，同时又希望保持类的数量最小化的场景。 代理模式：适用于需要控制或延迟对对象的访问，或者需要为对象添加额外的安全控制或延迟初始化的场景。 外观模式：适用于需要提供一个简化的接口来访问复杂的类系统或库的场景。 桥接模式：适用于需要将一个类层次结构的抽象部分与它的实现部分分离，使它们可以独立变化的场景。 组合模式：适用于需要将对象组合成树形结构，并且希望用户对单个对象和组合对象的使用具有一致性的场景。 享元模式：适用于需要大量相似对象，而这些对象的创建和销毁成本很高时，通过共享来减少内存占用和提高效率。 结构性模式通过提供灵活的设计方案，帮助开发者构建松耦合、可扩展且易于维护的系统。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-08T00:08:00+08:00","permalink":"https://wesigj.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F-structural-patterns/","title":"设计模式-结构性模式-structural patterns"},{"content":"C++面试基础系列-abstract [TOC]\nOverview 在C++中，abstract这个概念主要与抽象类（Abstract Class）相关。抽象类是一种不能被实例化的类，它通常包含至少一个纯虚函数（Pure Virtual Function）。抽象类用于定义接口或行为规范，可以被其他类继承并实现具体的功能。\n1.abstract关键点 以下是一些关于C++中抽象类的关键点：\n纯虚函数： 纯虚函数是在基类中声明但没有实现的虚函数，其声明方式是在函数声明的末尾加上= 0。 例如：virtual void doSomething() = 0; 抽象类的定义： 包含至少一个纯虚函数的类就是抽象类。 抽象类不能被直接实例化，但可以被用作其他类的基类。 继承抽象类： 派生类必须实现基类中的所有纯虚函数，否则派生类也会是抽象类。 接口定义： 抽象类通常用于定义接口，让不同的派生类实现相同的接口。 多态性： 抽象类支持多态性，可以通过基类指针或引用调用派生类重写的虚函数。 示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 抽象类声明 class Shape { public: virtual void draw() const = 0; // 纯虚函数 virtual ~Shape() {} // 虚析构函数，确保派生类析构正确性 }; // 派生类实现抽象类 class Circle : public Shape { public: void draw() const override { // 绘制圆形的代码 } }; // 使用抽象类 Shape* shape = new Circle(); shape-\u0026gt;draw(); delete shape; 抽象类的作用： 强制实现接口：确保所有派生类都实现了抽象类中定义的纯虚函数。 代码复用：基类可以提供一些通用的实现，派生类可以重写或继承这些实现。 设计原则： 遵循里氏替换原则（Liskov Substitution Principle），确保派生类可以替换其基类。 注意事项： 抽象类通常包含虚析构函数，以确保派生类的析构函数被正确调用。 C++11及以后版本： C++11引入了final关键字，可以修饰类或成员函数，表示它们不能被进一步继承或重写。 抽象类是C++面向对象编程中的一个重要概念，它有助于实现代码的模块化和可扩展性。通过使用抽象类，开发者可以定义清晰的接口，并在不同的派生类中实现这些接口的具体行为。\n2.C++ 抽象类和纯虚函数的例子 在这个例子中，Shape 是一个抽象类，它定义了一个纯虚函数 getArea。 Circle 和 Rectangle 是 Shape 的派生类，它们分别实现了 getArea 函数。 由于 Shape 是抽象类，我们不能直接创建它的实例，但可以创建 Circle 和 Rectangle 的实例。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; // 抽象基类 class Shape { public: // 纯虚函数，用于计算面积 virtual double getArea() const = 0; // 虚析构函数 virtual ~Shape() {} }; // 派生类 Circle class Circle : public Shape { public: // 构造函数 Circle(double radius) : radius(radius) {} // 实现基类的纯虚函数 double getArea() const override { return 3.14159 * radius * radius; } private: double radius; }; // 派生类 Rectangle class Rectangle : public Shape { public: // 构造函数 Rectangle(double width, double height) : width(width), height(height) {} // 实现基类的纯虚函数 double getArea() const override { return width * height; } private: double width, height; }; int main() { // 由于 Shape 是抽象类，不能直接实例化 // Shape shape; // 错误 Circle circle(5.0); Rectangle rectangle(4.0, 6.0); std::cout \u0026lt;\u0026lt; \u0026#34;Circle area: \u0026#34; \u0026lt;\u0026lt; circle.getArea() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle area: \u0026#34; \u0026lt;\u0026lt; rectangle.getArea() \u0026lt;\u0026lt; std::endl; return 0; } 3.abstract重点 纯虚函数使一个类变成抽象类 抽象类类型的指针和引用 如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类 抽象类可以有构造函数 构造函数不能是虚函数，而析构函数可以是虚析构函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 抽象类 class Base { public: Base(){ cout \u0026lt;\u0026lt; \u0026#34;Constructor: Base\u0026#34; \u0026lt;\u0026lt; endl; } virtual ~Base(){ cout \u0026lt;\u0026lt; \u0026#34;Destructor : Base\u0026#34; \u0026lt;\u0026lt; endl; } virtual void func() = 0; }; class Derived: public Base { public: Derived(){ cout \u0026lt;\u0026lt; \u0026#34;Constructor: Derived\u0026#34; \u0026lt;\u0026lt; endl; } ~Derived(){ cout \u0026lt;\u0026lt; \u0026#34;Destructor : Derived\u0026#34; \u0026lt;\u0026lt; endl;} void func(){cout \u0026lt;\u0026lt; \u0026#34;In Derived.func().\u0026#34; \u0026lt;\u0026lt; endl;} }; 当基类指针指向派生类对象并删除对象时，我们可能希望调用适当的析构函数。 如果析构函数不是虚拟的，则只能调用基类析构函数。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-abstract/","title":"C++ basic abstract"},{"content":"C++面试基础系列-assert [TOC]\nOverview 1.assert关键点 在C++中，assert宏是断言机制的一部分，用于在开发过程中检查程序的逻辑错误。如果断言的条件不满足，程序将终止执行，并通常会输出相关的错误信息。\n以下是一些关于C++中assert宏的关键点：\n定义：assert宏定义在\u0026lt;cassert\u0026gt;或\u0026lt;assert.h\u0026gt;头文件中。\n语法：assert宏的基本语法是assert(expression)，其中expression是一个在运行时求值的表达式。\n行为：如果expression的值为true，程序继续正常执行。如果expression的值为false，则程序将打印一条错误消息，并终止执行。\n调试：assert宏通常用于调试阶段，以确保程序的某些关键条件得到满足。在发布版本中，可以通过预处理器指令NDEBUG来禁用assert宏。\n示例：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cassert\u0026gt; int main() { int x = 10; assert(x \u0026gt; 5); // 如果x大于5，程序继续执行 std::cout \u0026lt;\u0026lt; \u0026#34;x的值是：\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; assert(x \u0026lt; 20); // 如果x小于20，程序继续执行 return 0; } 自定义消息：C++11开始支持使用static_assert进行编译时断言，并且可以传递一个字符串作为错误消息： 1 static_assert(sizeof(int) \u0026gt;= 4, \u0026#34;int类型必须至少占用4个字节\u0026#34;); 编译时断言：static_assert是在编译时检查条件是否为真的断言，如果条件为假，编译器将报错并停止编译过程。\n性能：由于assert在运行时检查条件，因此在性能敏感的应用中应谨慎使用，或者在发布版本中禁用。\n禁用断言：可以通过定义NDEBUG宏来禁用所有assert宏：\n1 2 #define NDEBUG #include \u0026lt;cassert\u0026gt; 使用断言是一种很好的实践，可以帮助开发者及早发现和修复错误。然而，它们不应该被用作错误处理的主要手段，因为它们在生产环境中可能被禁用。 关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-assert/","title":"C++ basic assert"},{"content":"C++面试基础系列-bit_field Overview “ 位域 “ 或 “ 位段 “(Bit field)为一种数据结构，可以把数据以位的形式紧凑的储存，并允许程序员对此结构的位进行操作。\n优点 它可以使数据单元节省储存空间，当程序需要成千上万个数据单元时，这种方法就显得尤为重要。 位段可以很方便的访问一个整数值的部分内容从而可以简化程序源代码。 缺点： 而这种数据结构的缺点在于，位段实现依赖于具体的机器和系统，在不同的平台可能有不同的结果，这导致了位段在本质上是不可移植的。 关键点： 位域在内存中的布局是与机器有关的 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定 取地址运算符（\u0026amp;）不能作用于位域，任何指针都无法指向类的位域 1.bit_field位域 在C和C++编程中，bit_field（位字段）是一种数据结构技术，它允许程序员访问和操作内存中存储的整数的特定部分。以下是位字段的一些关键点：\n内存节省 ：位字段允许程序员将多个数据项存储在一个小的存储单元内，从而节省内存空间。 数据表示 ：位字段通常用于表示具有固定位宽的数据，例如状态标志、控制位或特定的配置选项。 声明方式 ： 位宽指定 ：在声明位字段时，可以通过冒号(:)后跟数字来指定每个字段的位宽。 位操作 ：位字段常用于位操作，如位与(\u0026amp;)、位或(|)、位异或(^)、位非(~)和位移操作。 数据对齐 ：位字段可能会影响数据的内存对齐，编译器可能会在位字段结构体中添加填充位以满足对齐要求。 可移植性问题 ：位字段的布局（即位字段在内存中的顺序）可能依赖于编译器和平台，因此可能存在可移植性问题。 访问方式 ：位字段通常作为结构体的成员来访问，可以结合点(.)或箭头(-\u0026gt;)操作符使用。 应用场景 ： 硬件设备寄存器的访问。 状态机的状态表示。 配置选项的存储。 限制 ：位字段的使用应谨慎，因为它们可能会使代码难以理解和维护，且容易出错。 类型安全 ：位字段本身是强类型，但位字段的运算可能导致隐式类型转换。 编译器特性 ：某些编译器可能提供特定的特性或扩展来支持位字段的声明和操作。 位字段是C和C++中一种强大的特性，尤其适用于需要精细控制内存使用和硬件级编程的场合。然而，由于它们可能带来的复杂性和可移植性问题，建议仅在确实需要时才使用位字段。\n2.bit_field字节对齐 2.1.位域的声明 位域通常使用结构体声明， 该结构声明为每个位域成员设置名称，并决定其宽度：\n1 2 3 4 struct bit_field_name { type member_name : width; }; Elements Description bit_field_name 位域结构名 type 位域成员的类型，必须为 int、signed int 或者 unsigned int 类型 member_name 位域成员名 width 规定成员所占的位数 1 2 3 4 5 6 7 8 struct BitField { unsigned int is_enabled : 1; // 1位用于表示是否启用 unsigned int : 3; // 3位用于表示是否启用 unsigned int has_data : 1; // 1位用于表示是否有数据 unsigned int length1 : 3; // 3位用于表示是否有数据 unsigned int length2 : 8; // 8位用于表示是否有数据 // 可以继续添加更多位字段 }; length1其容量为 2^3 = 8，即赋值范围应为 [0,7]。 length2其容量为 2^8 = 256，即赋值范围应为 [0,255]。 未命名的位域，表示占位，字节对齐，仅起填充作用，并无实际意义。 2.2.位域的对齐 一个位域成员不允许跨越两个 unsigned int 的边界，如果成员声明的总位数超过了一个 unsigned int 的大小， 那么编译器会自动移位位域成员，使其按照 unsigned int 的边界对齐。 例如：\n1 2 3 4 5 6 struct stuff { unsigned int field1: 30; unsigned int field2: 4; unsigned int field3: 3; }; field1 + field2 = 34 Bits，超出 32 Bits, 编译器会将 field2移位至下一个 unsigned int 单元存放， stuff.field1 和 stuff.field2 之间会留下一个 2 Bits 的空隙， stuff.field3 紧跟在 stuff.field2 之后，该结构现在大小为 2 * 32 = 64 Bits。\n这个空洞可以用之前提到的未命名的位域成员填充，我们也可以使用一个宽度为 0 的未命名位域成员令下一位域成员与下一个整数对齐。 例如:\n1 2 3 4 5 6 7 8 struct stuff { unsigned int field1: 30; unsigned int : 2; unsigned int field2: 4; unsigned int : 0; unsigned int field3: 3; }; 这里 stuff.field1 与 stuff.field2 之间有一个 2 Bits 的空隙，stuff.field3 则存储在下一个 unsigned int 中，该结构现在大小为 3 * 32 = 96 Bits。\n3.位域的初始化和位的重映射 3.1.初始化 位域的初始化与普通结构体初始化的方法相同，这里列举两种，如下:\n1 struct stuff s1= {20,8,6}; 或者直接为位域成员赋值\n1 2 3 4 struct stuff s1; s1.field1 = 20; s1.field2 = 8; s1.field3 = 4; 3.2.位域的重映射 (Re-mapping) 声明一个 大小为 32 Bits 的位域\n1 2 3 4 5 6 struct box { unsigned int ready: 2; unsigned int error: 2; unsigned int command: 4; unsigned int sector_no: 24; }b1; 3.2.1.利用重映射将位域归零 1 2 int* p = (int *) \u0026amp;b1; // 将 \u0026#34;位域结构体的地址\u0026#34; 映射至 \u0026#34;整形（int*) 的地址\u0026#34; *p = 0; // 清除 s1，将各成员归零 3.2.2.利用联合 (union) 将 32 Bits 位域 重映射至 unsigned int 型 先简单介绍一下联合\n“联合” 是一种特殊的类，也是一种构造类型的数据结构。在一个 “联合” 内可以定义多种不同的数据类型， 一个被说明为该 “联合” 类型的变量中，允许装入该 “联合” 所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的\n“联合” 与 “结构” 有一些相似之处。但两者有本质上的不同。在结构中各成员有各自的内存空间， 一个结构变量的总长度是各成员长度之和（空结构除外，同时不考虑边界调整）。而在 “联合” 中，各成员共享一段内存空间， 一个联合变量的长度等于各成员中最长的长度。应该说明的是， 这里所谓的共享不是指把多个成员同时装入一个联合变量内， 而是指该联合变量可被赋予任一成员值，但每次只能赋一种值， 赋入新值则冲去旧值。\n我们可以声明以下联合:\n1 2 3 4 union u_box { struct box st_box; unsigned int ui_box; }; x86 系统中 unsigned int 和 box 都为 32 Bits, 通过该联合使 st_box 和 ui_box 共享一块内存。具体位域中哪一位与 unsigned int 哪一位相对应，取决于编译器和硬件。 利用联合将位域归零，代码如下：\n1 2 union u_box u; u.ui_box = 0; 4.C++ std::bitset 尽管位字段在某些低级编程或硬件操作中很有用，但现代C++提供了一些替代方案，这些方案可能更加灵活和可移植。例如， 可以使用 std::bitset来访问和操作位集合，它提供了一种类型安全的方式来处理位字段，而且不依赖于特定的硬件或编译器特性 。 此外，对于需要表示多个布尔标志或小数据字段的情况，可以使用联合体（union）和位操作来实现类似的功能，但需要手动管理位的读写操作 std::bitset是C++标准模板库（STL）中的一个类模板，用于表示和操作固定大小的位集合（bit set）。以下是std::bitset的一些关键特性和用法：\n类型安全：std::bitset提供了一种类型安全的方式来访问和操作位。 固定大小：与C语言中的位字段不同，std::bitset的大小在编译时确定，并且是固定的。 声明和初始化： 1 2 3 std::bitset\u0026lt;N\u0026gt; b; std::bitset\u0026lt;N\u0026gt; b2(10); // 所有位初始化为 0，除了最后一位设置为 1 std::bitset\u0026lt;N\u0026gt; b3 = ~b2; // 位取反 访问位：使用operator[]来访问和修改特定的位。 1 2 bool bit = b[3]; // 获取第 4 位的值 b[3] = 1; // 设置第 4 位为 1 设置和清除位：提供set()和reset()成员函数来设置或清除特定的位。 1 2 b.set(3); // 设置第 4 位为 1 b.reset(3); // 清除第 4 位 翻转位：flip()成员函数用于翻转指定位的状态。 1 b.flip(3); // 翻转第 4 位的状态 统一操作：提供set()和reset()的重载版本，允许一次性设置或清除多个位。 1 b.set(3, 4, 5); // 同时设置第 4、5、6 位 位操作：支持位运算符\u0026amp;（与）、|（或）、^（异或）和~（取反）。 1 2 3 4 5 std::bitset\u0026lt;N\u0026gt; b1, b2; std::bitset\u0026lt;N\u0026gt; b3 = b1 \u0026amp; b2; // 位与 std::bitset\u0026lt;N\u0026gt; b4 = b1 | b2; // 位或 std::bitset\u0026lt;N\u0026gt; b5 = b1 ^ b2; // 位异或 std::bitset\u0026lt;N\u0026gt; b6 = ~b1; // 位取反 转换：可以将std::bitset对象转换为整数类型，或从整数类型构造std::bitset对象。 1 2 3 4 int i = 0b11001100; std::bitset\u0026lt;8\u0026gt; b(i); std::bitset\u0026lt;8\u0026gt; b2 = b; int j = static_cast\u0026lt;int\u0026gt;(b2); 大小和索引：std::bitset的大小由模板参数指定，位的索引从0开始。 迭代器：std::bitset不提供迭代器，因为它是一个连续的位集合。 效率：对于固定大小的位操作，std::bitset通常比使用数组或向量（vector）更高效。 std::bitset是处理位字段操作的现代C++替代方案，它提供了一个简洁、安全和高效的方式来处理位级别的数据。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-bit_field/","title":"C++ basic bit_field"},{"content":"C++面试基础系列-bit_operation 1.bit_operation定义 位操作也叫位运算，计算机底层基于二进制计算，所以位运算的运算效率更高，速度更快。\n对于正数来说，其反码和原码一致。对负数来说，反码就是对除去最高符号位之外的所有二进制位取反。\n对于正数来说，其补码与反码一致。对负数来说，补码就是对反码做通常意义上的加一操作（含进位）。\n整数在计算机中是以补码的形式储存的，这就是为什么我们要介绍原码、反码和补码。\n补码的好处：\n其一是明确了整数「0」的表示（否则可以有 0000 0000 和 1000 0000 两种方式表示）， 其二是对整数的加法只需要统一的一套电路来处理即可。 1 2 20 = 0001 0100(原码Source code) = 0001 0100(反码Inverse code) = 0001 0100(补码complement) -20 = 1001 0100(原码Source code) = 1110 1011(反码Inverse code) = 1110 1100(补码complement) 2.bit_operation位运算符号类型 符号 描述 运算规则 \u0026amp; 与 两个位都为1时，结果才为1 | 或 两个位都为0时，结果才为0 ^ 异或 两个位相同为0，相异为1 ~ 取反 0变1，1变0 \u0026laquo; 左移 各二进位全部左移若干位，高位丢弃，低位补0 \u0026raquo; 右移 各二进位全部右移若干位，高位补0或符号位补齐 3.位运算的常用操作总结 功 能 位运算 示例 方法一：提取最右边的1出来 x \u0026amp; (~x + 1) 100101000 -\u0026gt; 000001000 方法二：提取最右边的1出来 x \u0026amp; (-x) 100101000 -\u0026gt; 000001000 从右边开始，把最后一个 $1$ 改写成 $0$ x \u0026amp; (x - 1) 100101000 -\u0026gt; 100100000 去掉右边起第一个 $1$ 的左边 x \u0026amp; (x ^ (x - 1)) 或 x \u0026amp; (-x) 100101000 -\u0026gt; 1000 去掉最后一位 x \u0026gt;\u0026gt; 1 101101 -\u0026gt; 10110 取右数第 $k$ 位 x \u0026gt;\u0026gt; (k - 1) \u0026amp; 1 1101101 -\u0026gt; 1, k = 4 取末尾 $3$ 位 x \u0026amp; 7 1101101 -\u0026gt; 101 取末尾 $k$ 位 x \u0026amp; 15 1101101 -\u0026gt; 1101, k = 4 只保留右边连续的 $1$ (x ^ (x + 1)) \u0026gt;\u0026gt; 1 100101111 -\u0026gt; 1111 右数第 $k$ 位取反 x ^ (1 \u0026lt;\u0026lt; (k - 1)) 101001 -\u0026gt; 101101, k = 3 在最后加一个 $0$ x \u0026lt;\u0026lt; 1 101101 -\u0026gt; 1011010 在最后加一个 $1$ (x \u0026lt;\u0026lt; 1) + 1 101101 -\u0026gt; 1011011 把右数第 $k$ 位变成 $0$ x \u0026amp; ~(1 \u0026lt;\u0026lt; (k - 1)) 101101 -\u0026gt; 101001, k = 3 把右数第 $k$ 位变成 $1$ x | (1 \u0026lt;\u0026lt; (k - 1)) 101001 -\u0026gt; 101101, k = 3 把右边起第一个 $0$ 变成 $1$ x | (x + 1) 100101111 -\u0026gt; 100111111 把右边连续的 $0$ 变成 $1$ x | (x - 1) 11011000 -\u0026gt; 11011111 把右边连续的 $1$ 变成 $0$ x \u0026amp; (x + 1) 100101111 -\u0026gt; 100100000 把最后一位变成 $0$ x | 1 - 1 101101 -\u0026gt; 101100 把最后一位变成 $1$ x | 1 101100 -\u0026gt; 101101 把末尾 $k$ 位变成 $1$ x | (1 \u0026lt;\u0026lt; k - 1) 101001 -\u0026gt; 101111, k = 4 最后一位取反 x ^ 1 101101 -\u0026gt; 101100 末尾 $k$ 位取反 x ^ (1 \u0026lt;\u0026lt; k - 1) 101001 -\u0026gt; 100110, k = 4 4.位运算与宏定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #define bitRead(value, bit) (((value) \u0026gt;\u0026gt; (bit)) \u0026amp; 0x01) #define bitSet(value, bit) ((value) |= (1UL \u0026lt;\u0026lt; (bit))) #define bitClear(value, bit) ((value) \u0026amp;= ~(1UL \u0026lt;\u0026lt; (bit))) #define bitReverse(value, bit) ((value) ^= (1UL \u0026lt;\u0026lt; (bit))) #define bitWrite(value, bit, bitvalue) ((bitvalue) ? bitSet(value, bit) : bitClear(value, bit)) #define lowByte(w) ((w) \u0026amp; 0xff) #define highByte(w) ((w) \u0026gt;\u0026gt; 8) #define bitRigthmostGet(value) ((value) \u0026amp; (-value)) #define bitRigthmostClear(value) ((value) \u0026amp; (value-1)) //嵌入式中位操作 #define SET_BIT(REG, BIT) ((REG) |= (BIT)) #define CLEAR_BIT(REG, BIT) ((REG) \u0026amp;= ~(BIT)) #define READ_BIT(REG, BIT) ((REG) \u0026amp; (BIT)) //嵌入式中寄存器操作 #define CLEAR_REG(REG) ((REG) = (0x0)) #define WRITE_REG(REG, VAL) ((REG) = (VAL)) #define READ_REG(REG) ((REG)) #define MODIFY_REG(REG, CLEARMASK, SETMASK) WRITE_REG((REG), (((READ_REG(REG)) \u0026amp; (~(CLEARMASK))) | (SETMASK))) 5.二进制枚举子集 除了上面的这些常见操作，我们经常常使用二进制数第 $1 \\sim n$ 位上 $0$ 或 $1$ 的状态来表示一个由 $1 \\sim n$ 组成的集合。也就是说通过二进制来枚举子集。\n5.1.二进制枚举子集简介 先来介绍一下「子集」的概念。\n子集：如果集合 $A$ 的任意一个元素都是集合 $S$ 的元素，则称集合 $A$ 是集合 $S$ 的子集。可以记为 $A \\in S$。 有时候我们会遇到这样的问题：给定一个集合 $S$，枚举其所有可能的子集。\n枚举子集的方法有很多，这里介绍一种简单有效的枚举方法：「二进制枚举子集算法」。\n对于一个元素个数为 $n$ 的集合 $S$ 来说，每一个位置上的元素都有选取和未选取两种状态。我们可以用数字 $1$ 来表示选取该元素，用数字 $0$ 来表示不选取该元素。\n那么我们就可以用一个长度为 $n$ 的二进制数来表示集合 $S$ 或者表示 $S$ 的子集。其中二进制的每一个二进位都对应了集合中某一个元素的选取状态。对于集合中第 $i$ 个元素来说，二进制对应位置上的 $1$ 代表该元素被选取，$0$ 代表该元素未被选取。\n举个例子，比如长度为 $5$ 的集合 $S = \\lbrace 5, 4, 3, 2, 1 \\rbrace$，我们可以用一个长度为 $5$ 的二进制数来表示该集合。\n比如二进制数 $11111_{(2)}$ 就表示选取集合的第 $1$ 位、第 $2$ 位、第 $3$ 位、第 $4$ 位、第 $5$ 位元素，也就是集合 $\\lbrace 5, 4, 3, 2, 1 \\rbrace$，即集合 $S$ 本身。如下表所示：\n集合 S 中元素位置 5 4 3 2 1 二进位对应值 1 1 1 1 1 对应选取状态 选取 选取 选取 选取 选取 再比如二进制数 $10101_{(2)}$ 就表示选取集合的第 $1$ 位、第 $3$ 位、第 $5$ 位元素，也就是集合 $\\lbrace 5, 3, 1 \\rbrace$。如下表所示：\n集合 S 中元素位置 5 4 3 2 1 二进位对应值 1 0 1 0 1 对应选取状态 选取 未选取 选取 未选取 选取 再比如二进制数 $01001_{(2)}$ 就表示选取集合的第 $1$ 位、第 $4$ 位元素，也就是集合 $\\lbrace 4, 1 \\rbrace$。如下标所示：\n集合 S 中元素位置 5 4 3 2 1 二进位对应值 0 1 0 0 1 对应选取状态 未选取 选取 未选取 未选取 选取 通过上面的例子我们可以得到启发：对于长度为 $5$ 的集合 $S$ 来说，我们只需要从 $00000 \\sim 11111$ 枚举一次（对应十进制为 $0 \\sim 2^5 - 1$）即可得到长度为 $5$ 的集合 $S$ 的所有子集。\n我们将上面的例子拓展到长度为 $n$ 的集合 $S$。可以总结为：\n对于长度为 $n$ 的集合 $S$ 来说，只需要枚举 $0 \\sim 2^n - 1$（共 $2^n$ 种情况），即可得到集合 $S$ 的所有子集。 5.2 二进制枚举子集代码 1 2 3 4 5 6 7 8 9 10 11 class Solution: def subsets(self, S): # 返回集合 S 的所有子集 n = len(S) # n 为集合 S 的元素个数 sub_sets = [] # sub_sets 用于保存所有子集 for i in range(1 \u0026lt;\u0026lt; n): # 枚举 0 ~ 2^n - 1 sub_set = [] # sub_set 用于保存当前子集 for j in range(n): # 枚举第 i 位元素 if i \u0026gt;\u0026gt; j \u0026amp; 1: # 如果第 i 为元素对应二进位删改为 1，则表示选取该元素 sub_set.append(S[j]) # 将选取的元素加入到子集 sub_set 中 sub_sets.append(sub_set) # 将子集 sub_set 加入到所有子集数组 sub_sets 中 return sub_sets # 返回所有子集 (https://liam.page/2015/10/02/how-to-get-the-last-1-bit-of-an-integer/\nhttps://github.com/itcharge/LeetCode-Py\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-bit_operation/","title":"C++ basic bit_operation"},{"content":" C++面试基础系列-const 1.const含义 const表示常类型，其值不可更改。\n2.const作用 修饰常量 1 const int a = 66; 类型检查 const具有类型，并支持所有类型 const修饰，名为常量，具备不可更改属性 防更改，保护作用，增加程序健壮性 节省空间，内存 从汇编上看，const实质是使用内存地址访问，#define是立即数 const常量存储在内存中，只有一个内存地址，#define是预编译时，拷贝到代码中，不占用内存空间（RAM），占用ROM。 3.const作用域 const 常量具有块作用域（如果定义在函数或代码块内部）或文件作用域（如果定义在所有函数外部），遵循C语言的普通作用域规则。 #define 定义的宏在预处理阶段展开，没有作用域的概念，除非使用 #undef 取消定义。 4.修饰常量 1 2 const int a =66; a = 0; //ERROR can not change const constant 5.const与指针 1 2 3 4 const int *p; //指向const常类型的普通指针 int const *p; //同上 int * const p;//指向int类型的常指针 const int *const p;//指向const常类型的常指针 有趣的解析方法\n1 2 3 4 const char * p; //p is a pointer to const char char const * p; //同上 char * const p; //p is a const pointer to char const char * const p; //p is a const pointer to const char 5.1.指向常量的指针 指向常量的指针，其中常量不可修改 1 2 const int *p; # *p=10; //error 不能修改常量 1 2 3 const int a=10; const int *p = \u0026amp;a; // int *p = \u0026amp;a; //error 常量必须用常指针指向 允许把非const对象的地址赋给指向const对象的指针 1 2 int a=10; const int *p = \u0026amp;a; 1 2 3 const int *p; int a=10; p= \u0026amp;a; 5.2.常指针 const指针定义时，必须初始化，const指针不可变，但指向的值可变。\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;iostream\u0026gt; int main(){ int a =66; int b =88; int * const p = \u0026amp;a; // p = \u0026amp;b; //error std::cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;std::endl; a=100; std::cout\u0026lt;\u0026lt;*p\u0026lt;\u0026lt;std::endl; } const指针不能指向常量\n1 2 3 4 5 6 7 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ const int a=0; //\u0026#34;const int *\u0026#34; 类型的值不能用于初始化 \u0026#34;int *const\u0026#34; 类型的实体 // int * const p=\u0026amp;a; // error! can not const int* -\u0026gt; int*const } 5.3.指向常量的常指针 1 2 const int a = 10; const int * const p = \u0026amp;a; 6.const与函数 const修饰函数返回值 const int fun(); 函数返回const常量，但是函数返回后通常会拷贝。\nconst int *fun(); 函数返回指向常量的指针，指针指向的内容不能更改。\nint *const fun(); 指针不能更改。\nconst修饰函数参数 函数参数或函数参数指针在函数内不能更改 1 2 3 void fun1(const int a);//参数不可变 void fun2(int *const a);//指针不能变 void fun(char *dest, const char *src);//防止常类型src被更改 主要功能： 保护参数和指针不被更改。 保护常类型不被更改。\nCPP中引用，增加效率，防止更改 1 void fun(const T \u0026amp;a);//T为模板，任意类型 cpp，增加了引用(reference)：\nC语言本身没有引用（reference）的概念，引用是C++等其他编程语言中的一个特性。在C语言中，参数传递通常通过值传递（pass by value）或指针传递（pass by pointer）实现。 如果T为基础类型，理论来说，基础数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。\n面试问题：\n如果函数需要传入一个指针，是否需要为该指针加上const，把const加在指针不同的位置有什么区别? 如果写的函数需要传入的参数是一个复杂类型的实例，传入值参数或者引用参数有什么区别，什么时候需要为传入的引用参数加上const? 7.const与类 在类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改 数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。 例如： 1 2 3 4 5 6 7 8 9 10 class MyClass { public: void normalFunction() { // 可以修改成员变量 } void constantFunction() const { // 不能修改任何成员变量，除非它们被声明为 mutable } }; 在这个示例中，normalFunction 是一个非常成员函数，可以修改对象的状态；而 constantFunction 是一个常成员函数，承诺不修改对象的状态，并且可以被用于操作常量对象。\n使用const关键字进行修饰的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字进行说明的成员函数不能用来操作常对象。 const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数. 简单来说\n常对象才能调用常函数和常量，不可调用非常函数或变量。 常函数不能调用，修改任何成员函数，成员变量，除非它们被声明为 mutable 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; class MyClass { private: int value; public: // 构造函数 MyClass(int val) : value(val) {} // 非const成员函数，可以修改成员变量 void modifyValue(int newValue) { value = newValue; std::cout \u0026lt;\u0026lt; \u0026#34;Value modified to: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } // const成员函数，不能修改成员变量，但可以读取 void displayValue() const { std::cout \u0026lt;\u0026lt; \u0026#34;Current value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } }; int main() { const MyClass constObject(10); // 创建一个const对象 // 下面的调用是允许的，因为displayValue()是一个const成员函数 constObject.displayValue(); // 下面的调用将导致编译错误，因为modifyValue()不是一个const成员函数 // constObject.modifyValue(20); // 错误：不能在const对象上调用non-const成员函数 // 创建一个非const对象 MyClass nonConstObject(20); // 可以调用非const成员函数来修改非const对象的状态 nonConstObject.modifyValue(30); // 正确调用 // 也可以调用const成员函数来读取非const对象的状态 nonConstObject.displayValue(); // 正确调用 return 0; } 从中可以看出，const对象只能调用const函数和const常量，\n于类中的const成员变量必须通过初始化列表进行初始化，如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 class Apple{ private: int people[100]; public: Apple(int i); const int apple_number; }; Apple::Apple(int i):apple_number(i) { } 8.const与static 8.1.将常量定义与static结合 1 static const int apple_number 8.2.在类外面初始化 1 const int Apple::apple_number=10; 使用c++11进行编译，可以在定义出初始化：\n1 2 3 static const int apple_number=10; // 或者 const int apple_number=10; 这两种都在c++11中支持！\n编译的时候加上-std=c++11即可！\n在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。\n在类中声明：\n1 static int ap; 在类实现文件中使用：\n1 int Apple::ap=666 对于此项，c++11不能进行声明并初始化，也就是上述使用方法。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-const/","title":"C++ basic const"},{"content":"C++面试基础系列-decltype [TOC]\nOverview 在C++中，decltype 是一个类型推导关键字，它用于确定表达式的类型。decltype 可以在编译时确定一个变量或表达式的类型，而不需要显式地声明类型。这在模板编程和泛型编程中非常有用，尤其是在C++11及以后的版本中。 1.decltype关键点 以下是 decltype 的一些关键点：\n基本用法：\ndecltype 的基本语法是 decltype(表达式)，它返回表达式的类型。 引用修饰符：\n如果表达式是一个左值，decltype 将返回带有引用修饰符的类型（例如 int\u0026amp;）。如果表达式是一个右值，返回的类型将不包含引用修饰符（例如 int）。 数组和函数类型：\ndecltype 不会从数组或函数类型中推导出 pointer 类型，而是保持原始类型（例如 int[] 或 void()）。 结合 auto 关键字：\ndecltype 经常与 auto 关键字结合使用，以实现类型推导。 模板参数推导：\n在模板参数推导中，decltype 可以用于推导出模板参数的类型。 lambda 表达式：\n对于 lambda 表达式，decltype 推导出的类型是 std::function 的实例类型。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;typeinfo\u0026gt; // 需要包含这个头文件来使用 typeid void exampleFunction(int\u0026amp; i) { std::cout \u0026lt;\u0026lt; \u0026#34;Type of i: \u0026#34; \u0026lt;\u0026lt; typeid(i).name() \u0026lt;\u0026lt; std::endl; // 注意：这里不需要使用 decltype，因为 i 已经是 int\u0026amp; 类型 } int main() { int a = 10; double b = 3.14; std::cout \u0026lt;\u0026lt; \u0026#34;Type of a: \u0026#34; \u0026lt;\u0026lt; typeid(a).name() \u0026lt;\u0026lt; std::endl; // decltype(a) 是不必要的，因为 a 已经是一个 int 类型的变量 auto x = a; // 使用 auto 推导 x 的类型为 int std::cout \u0026lt;\u0026lt; \u0026#34;Type of x: \u0026#34; \u0026lt;\u0026lt; typeid(x).name() \u0026lt;\u0026lt; std::endl; // 移除 exampleFunction 的调用，因为它没有返回值 // auto y = exampleFunction(a); // 这行是错误的 // 代码中 auto y = exampleFunction(a); 这一行存在问题，因为 exampleFunction 函数没有返回值，所以尝试将一个没有返回值的函数调用赋值给变量 y 是不正确的。auto 关键字在这里会推导出 void 类型，因为 exampleFunction 的返回类型是 void。 // decltype 推导 lambda 表达式的类型 auto lambda = [](int i) { return i * 2; }; std::cout \u0026lt;\u0026lt; \u0026#34;Type of lambda: \u0026#34; \u0026lt;\u0026lt; typeid(lambda).name() \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，decltype 用于推导不同表达式的类型。注意，typeid 用于输出类型信息，它需要包含 \u0026lt;typeinfo\u0026gt; 头文件。decltype 在这里用于推导变量 a 的类型，以及 auto 变量 x 的类型。对于 exampleFunction 函数，decltype 推导了函数参数 i 的类型。最后，对于 lambda 表达式，decltype 推导出了一个 std::function 类型。 请注意，typeid(lambda).name() 可能不会返回一个有用的字符串，因为 lambda 表达式产生的函数对象类型通常不是多态类型，name() 方法对于非多态类型可能返回空指针。如果你想要打印 lambda 表达式的类型，你可能需要使用其他方法，例如直接使用 std::cout 来输出类型信息。\ndecltype 是C++11引入的一个非常有用的关键字，它简化了类型声明，并在模板编程中提供了极大的灵活性。\n2.C++类型推导 C++ 类型推导是一个强大的特性，它允许编译器自动确定变量或表达式的类型，而不需要显式地声明类型。这在编写模板代码、使用泛型编程、以及简化代码时非常有用。以下是一些C++中类型推导的关键点和机制：\n自动类型推导（Auto）：\n使用 auto 关键字可以让编译器根据初始化表达式推导出变量的类型。 decltype：\ndecltype 关键字用于推导出某个表达式的类型，但不会对表达式结果进行值的推导。 模板参数推导：\n当使用模板函数或模板类时，编译器可以推导出模板参数的类型。 构造函数的类型推导：\nC++11 引入了构造函数的成员初始化列表，允许从构造函数参数推导出成员变量的类型。 类型别名（Type Aliases）：\n使用 using 或 typedef 声明类型别名，可以简化复杂类型名的书写。 类型特征（Type Traits）：\n\u0026lt;type_traits\u0026gt; 头文件提供了一系列编译时检查和修改类型的工具。 C++14 泛型 lambda 表达式：\n在 C++14 中，lambda 表达式的捕获列表可以使用 auto 来自动推导捕获变量的类型。 C++17 结构化绑定：\n结构化绑定允许从元组、pair 或数组中提取多个值，并自动推导出这些值的类型。 C++17 if 语句和 switch 语句中的初始化：\n在 C++17 中，可以在 if 或 switch 语句中初始化变量，并自动推导其类型。 C++20 概念（Concepts）：\n概念允许定义类型必须满足的条件，这有助于在模板编程中进行更精确的类型推导。 C++20 模块（Modules）：\n模块可以帮助简化包含和类型声明，间接影响类型推导。 C++20 consteval 关键字：\n允许声明一个函数总是被编译器在编译时调用，有助于编译时的类型推导。 C++20 requires 子句：\n在模板定义中使用 requires 子句可以指定模板参数的类型约束和概念要求。 类型推导使得C++代码更加简洁和灵活，特别是在模板编程中。它减少了代码冗余，提高了代码的可读性和可维护性。然而，过度依赖类型推导有时也可能导致代码难以理解，因此在使用时需要权衡其利弊。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-decltype/","title":"C++ basic decltype"},{"content":"C++面试基础系列-double_colon(::) Overview 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的 1.double_colon(::)关键点 在C和C++中，双冒号 :: 被称为作用域解析运算符（scope resolution operator），但它在两种语言中的使用和含义略有不同：\nC语言中的:: 在C语言中，:: 几乎不被使用，因为它主要用于指定全局作用域，而C语言中大部分变量和函数默认就是全局作用域的。不过，:: 可以用来明确指出全局变量或函数，尤其是在与静态成员函数一起使用时。 C++中的:: 在C++中，:: 的使用要普遍得多，因为它用于解决作用域的问题，尤其是在类（class）和命名空间（namespace）中。 用于访问类的静态成员变量或静态成员函数：ClassName::staticMember。 用于访问命名空间中的成员：NamespaceName::member。 用于在类内部访问全局变量或函数，避免与局部变量或成员变量的名称冲突：::globalVariable。 用于在派生类中访问基类的成员：BaseClassName::member。 全局作用域： 在C++中，如果需要明确指出某个实体属于全局作用域，可以使用 ::。例如，在一个函数内部，如果你想要访问全局变量，可以使用 ::globalVariable。 类型转换： 在C++中，:: 也用于类型转换，称为静态类型转换或类类型转换，例如 Type::pointer。 模板参数： 在C++模板编程中，:: 用于指定模板参数的命名空间或类作用域，例如 std::vector\u0026lt;int\u0026gt;。 匿名空间： 在C++中，:: 还可以用于匿名命名空间，这是一种特殊的命名空间，它提供了文件内唯一的作用域。 C++11中的统一初始化： 从C++11开始，:: 不再是统一初始化（Uniform Initialization）的一部分。统一初始化使用花括号 {} 而不是 ::。 总结来说，:: 在C++中是一个关键的运算符，用于处理作用域相关的问题，而在C语言中，由于作用域规则的不同，:: 的使用相对较少。\n2.double_colon(::)使用示例 在C++中，双冒号 :: 是作用域解析运算符（scope resolution operator），用于明确指出我们访问的是特定作用域内的实体。以下是 :: 的一些主要用途和示例：\n2.1.访问类成员 使用 :: 来访问类的成员变量和成员函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MyClass { public: int memberVar; void memberFunc() { // ... } }; int main() { MyClass myObj; myObj.memberVar = 10; // 访问成员变量 myObj.memberFunc(); // 访问成员函数 } 2.2.静态成员访问 使用 :: 来访问类的静态成员，因为静态成员不属于类的任何特定对象。\n1 2 3 4 5 6 7 8 9 10 class MyClass { public: static int staticMember; }; int MyClass::staticMember = 20; // 定义静态成员 int main() { cout \u0026lt;\u0026lt; MyClass::staticMember \u0026lt;\u0026lt; endl; // 访问静态成员 } 2.3.命名空间中的实体 使用 :: 来访问命名空间中的实体。\n1 2 3 4 5 6 7 namespace MyNamespace { int myVar = 5; } int main() { cout \u0026lt;\u0026lt; MyNamespace::myVar \u0026lt;\u0026lt; endl; // 访问命名空间中的变量 } 2.4.全局变量和函数 在局部作用域中，使用 :: 来访问全局变量和函数。\n1 2 3 4 5 6 7 8 9 10 11 int globalVar = 10; void globalFunc() { // ... } int main() { int localVar = 5; ::globalVar = localVar; // 访问全局变量 ::globalFunc(); // 调用全局函数 } 2.5.友元类 当一个类声明了另一个类为友元时，可以使用 :: 来访问友元类的私有或保护成员。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class FriendClass { public: void friendFunc() { // ... } }; class MyClass { public: void accessFriend() { FriendClass::friendFunc(); // 访问友元类的成员函数 } }; 2.6.类型转换 :: 也用于静态类型转换，即 static_cast。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Base { public: virtual void func() { // ... } }; class Derived : public Base { public: void func() override { // ... } }; void func(Base* basePtr) { Derived* derivedPtr = static_cast\u0026lt;Derived*\u0026gt;(basePtr); // 类型转换 derivedPtr-\u0026gt;func(); } 2.7.枚举类成员访问 当枚举被定义在类中时，使用 :: 来访问枚举成员。\n1 2 3 4 5 6 7 8 class MyClass { public: enum MyEnum { A, B, C }; }; int main() { int value = MyClass::A; // 访问枚举成员 } 2.8.模板参数 使用 :: 来指定模板参数的命名空间或类作用域。\n1 2 3 4 5 6 7 8 template \u0026lt;typename T\u0026gt; void myFunc(T param) { // ... } int main() { myFunc\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;(10); // 使用 :: 指定模板参数的命名空间 } :: 是C++中一个非常有用的运算符，它帮助我们明确地访问作用域内的实体，提高代码的可读性和清晰度。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-double_colon/","title":"C++ basic double_colon(::)"},{"content":"C++面试基础系列-enum 1.enum关键点 enum（枚举）是一种数据类型，在C和C++语言中用来定义命名的整数值集合。枚举为一组相关的常量提供了一种更加清晰和易于理解的表示方式。\n以下是enum的一些关键点：\n1.1.定义枚举类型 使用enum关键字定义枚举类型，可以指定底层的整数类型（如int、unsigned int等），如果不指定，默认为`int。\n1 enum Color { RED, GREEN, BLUE }; 1.2.枚举成员 枚举成员是枚举类型的值，它们在定义时自动从0开始编号，每个成员依次加1。\n1.3.指定底层类型 可以为枚举成员指定底层类型，改变它们的存储大小和范围。\n1 enum Color : uint8_t { RED = 1, GREEN, BLUE }; 1.4.前向声明 在C++中，可以对枚举类型进行前向声明，但需要在后续的定义中指定其成员。\n1 2 3 4 // C++前向声明 enum Color; // ... 后续定义 enum Color { RED, GREEN, BLUE }; 1.5.作用域 在C++中，枚举类型具有作用域，其成员名称在枚举类型的作用域内有效。C语言中的枚举成员是全局的，除非使用enum { member1, member2, \u0026hellip; }语法。\n1.6.类型安全 枚举提供了类型安全，不同枚举类型的值不能互相赋值或比较，除非显式地进行类型转换。\n1.7.与整数的兼容性 枚举类型可以与整数类型进行比较和赋值，但这样做可能会破坏类型安全。\n1.8.迭代器 C++11标准引入了基于范围的for循环，可以方便地遍历枚举类型的所有值。\n1 2 3 for (Color c : {RED, GREEN, BLUE}) { // 使用c } 1.9.强类型枚举（C++11） C++11引入了强类型枚举，使用enum class关键字定义，增强了类型安全。\n1 enum class Color { RED, GREEN, BLUE }; 1.10.位字段枚举 枚举类型可以用于定义位字段，表示一组标志位的组合。\n1.11.枚举作为函数参数和返回类型 枚举类型可以作为函数的参数和返回类型，提供清晰的函数接口。\n枚举是一种非常有用的语言特性，它提高了代码的可读性和可维护性，特别是在处理一组相关的常量时。在嵌入式编程、状态机实现、配置选项等方面都有广泛应用。\n2.enum与namespace 解决作用域不受限带来的命名冲突问题 给枚举变量命名时加前缀 C 程序中，为了一致性我们会把所有常量统一加上前缀。但是这样定义枚举变量的代码就显得累赘。 C 程序中可能不得不这样做。不过 C++ 程序员恐怕都不喜欢这种方法。替代方案是命名空间: 下面代码可以用 Color::Type c = Color::RED; 来定义新的枚举变量 1 2 3 4 5 6 7 8 9 namespace Color { enum Type { RED=15, YELLOW, BLUE }; }; 不过，因为命名空间是可以随后被扩充内容的，所以它提供的作用域封闭性不高。在大项目中，还是有可能不同人给不同的东西起同样的枚举类型名。\n3.enum与struct 解决作用域不受限带来的命名冲突问题 更“有效”的办法是用一个类或结构体来限定其作用域，例如：定义新变量的方法和上面命名空间的相同。 不过这样就不用担心类在别处被修改内容。 这里用结构体而非类，是因为本身希望这些常量可以公开访问。（struct默认位public类型的，class默认是private） 1 2 3 4 5 6 7 8 9 struct Color1 { enum Type { RED=102, YELLOW, BLUE }; }; 4.C++11 的枚举类（enum class） 在C++11中，enum class（强类型枚举）提供了相比传统 enum类型更多的优势，主要表现在以下几个方面：\n类型安全性 ：enum class提供了更强的类型检查，枚举成员不能隐式转换为整数类型，这避免了隐式类型转换错误和潜在的bug。例如，在 enum class中声明的枚举值，它们的作用域被限定在其类型内部，不同 enum class中的同名枚举值不会引起冲突 。 底层类型指定 ：enum class允许明确指定枚举成员的底层整数类型，如 uint8_t、int16_t等，提供了更多的灵活性和精确性，允许开发者根据需要选择最合适的整数类型来存储枚举成员，优化内存使用和性能 。 自动枚举值 ：C++11允许 enum class成员自动从0开始赋值，并依次递增，简化了枚举类型的声明，减少了代码冗余 。 枚举类型字面量 ：enum class的成员可以作为编译时常量使用，提高了代码的表达能力和可读性，使得枚举类型可以在模板元编程和编译时决策中发挥作用 。 基于 std::underlying_type的范围 ：C++11通过提供 std::underlying_type模板，使得对枚举类型的值进行迭代和比较变得更加容易，提供了更多的灵活性 。 枚举类型的比较操作 ：C++11标准库提供了对枚举类型的比较操作的支持，允许枚举类型的值与布尔值或其他枚举类型的值进行比较，提高了枚举类型的实用性 。 强类型枚举的引入主要是为了提高代码的安全性、清晰性、易用性和性能，这些改进反映了C++社区对于编写更安全、更高效和更易于理解的代码的持续追求 。\n划重点 新的enum的作用域不在是全局的 不能隐式转换成其他类型 1 2 3 4 5 6 7 8 9 10 11 12 /** * @brief C++11的枚举类 * 下面等价于enum class Color2:int */ enum class Color2 { RED=2, YELLOW, BLUE }; Color2 c2 = Color2::RED; cout \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(c2) \u0026lt;\u0026lt; endl; //必须转！ 可以指定用特定的类型来存储enum 1 2 3 4 5 6 7 8 9 enum class Color3:char; // 前向声明 // 定义 enum class Color3:char { RED=\u0026#39;r\u0026#39;, BLUE }; char c3 = static_cast\u0026lt;char\u0026gt;(Color3::RED); 5.class中enum常量 类的构造函数的初始化列表中进行：\n1 2 3 4 5 6 7 8 9 10 11 class A { A(int size); // 构造函数 const int SIZE ; }; A::A(int size) : SIZE(size) // 构造函数的定义 { } A a(100); // 对象 a 的 SIZE 值为 100 A b(200); // 对象 b 的 SIZE 值为 200 怎样才能建立在整个类中都恒定的常量呢？\n类中的枚举常量\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Day{ public: typedef enum { Monday= 0, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday }DayType; }; //访问的时候通过，Day::Monday或者Person::Tuesday来进行访问。 枚举常量不会占用对象的存储空间，它们在编译时被全部求值。\n枚举常量的缺点是：它的隐含数据类型是整数，其最大值有限，且不能表示浮点。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-enum/","title":"C++ basic enum"},{"content":"C++面试基础系列-explicit [TOC]\nOverview 1.explicit 在 C++ 中，\u0026ldquo;explicit\u0026rdquo; 关键字用于类构造函数，以防止隐式类型转换和复制初始化。使用 explicit 可以提高代码的安全性，因为它要求在转换类型时必须明确地进行。下面是一些关于 explicit 的使用场景和示例：\n1.1.使用场景 防止隐式转换：当你希望类的构造函数只用于显示转换，而不是由编译器隐式执行时。 避免歧义：在多构造函数的情况下，explicit 可以避免编译器在选择调用哪个构造函数时产生歧义。 1.2.语法 1 2 3 4 5 6 7 class MyClass { public: explicit MyClass(Type param) { // 构造函数实现 } // 其他成员和方法 }; 1.3.示例 1.3.1.防止隐式类型转换 1 2 3 4 5 6 7 8 9 10 11 12 class NumericString { public: explicit NumericString(const std::string\u0026amp; s) { // 初始化逻辑，可能包括检查字符串是否只包含数字 } }; int main() { NumericString ns(\u0026#34;123\u0026#34;); // 正确，显示转换 // NumericString ns2 = \u0026#34;123\u0026#34;; // 错误，因为构造函数是 explicit 的 return 0; } 1.3.2.构造函数重载解析 如果有多个构造函数，explicit 可以帮助编译器确定应该调用哪个构造函数。\n1 2 3 4 5 6 7 8 9 10 11 12 class Date { public: Date(int day, int month, int year) { /* ... */ } // 普通构造函数 explicit Date(const std::string\u0026amp; dateString) { /* ... */ } // 显式构造函数 }; int main() { Date d1(1, 1, 2023); // 调用第一个构造函数 Date d2(\u0026#34;2023-01-01\u0026#34;); // 调用第二个构造函数，需要显示转换 // Date d3 = \u0026#34;2023-01-01\u0026#34;; // 错误，因为第二个构造函数是 explicit 的 return 0; } 1.4.注意事项 默认情况下，所有构造函数都是隐式的。添加 explicit 关键字后，构造函数就不再参与隐式转换。 explicit 只能用在单个参数的构造函数上。如果你需要调用一个多参数的构造函数，可以定义一个转换操作符或工厂函数。 在 C++11 及以后的版本中，列表初始化可以绕过 explicit 的限制，因此要谨慎使用。 通过使用 explicit，你可以在设计类时提供额外的安全性，防止错误的类型转换和潜在的 bug。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-explicit/","title":"C++ basic explicit"},{"content":"C++面试基础系列-extern 1.extern关键点 在C和C++中，extern是一个关键字，用于声明一个变量或函数是在其他文件或编译单元中定义的，即它具有外部链接。以下是 extern的一些关键点：\n外部链接 ：extern关键字声明的变量或函数具有外部链接，这意味着它们可以在多个文件中访问。 声明而非定义 ：使用 extern是声明一个已经在其他地方定义的变量或函数，而不是定义它们。 多文件共享 ：当你想在多个文件中使用同一个全局变量或函数时，可以在其他文件中使用 extern来声明它们。 定义位置 ：被 extern声明的变量或函数必须在某个文件中有确切的定义（带有类型和存储期的声明）。 头文件中使用 ：extern经常与头文件一起使用，允许在多个源文件中包含同一个头文件，而不会因多重包含而导致变量或函数被多次定义。 C++中的使用 ：在C++中，extern也可以用于声明C语言编写的库中的变量和函数，因为它可以用来指定C语言的外部链接。 存储期 ：extern声明的变量具有静态存储期，即它们在程序的整个运行期间都存在。 作用域 ：extern声明的变量或函数在声明它们的文件中是可见的，但它们的作用域限制在声明它们的块内，除非它们在全局作用域中声明。 初始化 ：extern声明的变量不能在声明时初始化，因为它们已经在其他地方定义并初始化了。 示例： 1 2 3 4 5 // file1.c int globalVar = 42; // 定义并初始化一个全局变量 // file2.c extern int globalVar; // 声明 globalVar，它在 file1.c 中定义 在上述示例中，globalVar在 file1.c中定义并初始化。在 file2.c中，使用 extern关键字来声明 globalVar，表示它在其他地方定义，这样 file2.c就可以访问 globalVar了。\nextern是C和C++中实现不同文件间全局变量和函数共享的重要机制。\n2.C++ extern \u0026quot;C\u0026quot; 在C++中使用C语言编写的库时，extern \u0026quot;C\u0026quot;（注意C是大写的）是一个特殊的声明，它告诉C++编译器按照C语言的规则来处理被声明的实体。这主要是因为C++支持函数重载，而C语言不支持。以下是 extern \u0026quot;C\u0026quot;的一些特别作用：\n语言链接指示 ：extern \u0026quot;C\u0026quot;指示编译器，被声明的函数或变量遵循C语言的链接规则，而不是C++的命名规则（Name Mangling）。 避免名称重整（Name Mangling） ：C++编译器会对函数名进行编码（即名称重整），以支持函数重载。而C语言没有函数重载的概念，其函数名在编译后不会改变。使用 extern \u0026quot;C\u0026quot;可以防止C++编译器对C函数名进行重整。 兼容C库 ：当需要链接C语言编写的库时，使用 extern \u0026quot;C\u0026quot;可以确保C++代码能够正确调用C库中的函数和变量。 C++和C的互操作 ：extern \u0026quot;C\u0026quot;是C++代码与C代码进行互操作的一种方式，使得C++程序能够直接调用C语言的函数和访问全局变量。 头文件包含 ：在使用C语言库的头文件时，通常也会用 extern \u0026quot;C\u0026quot;将整个头文件的内容包裹起来，以确保所有引用的函数和变量都遵循C语言的链接规则。 全局作用域 ：extern \u0026quot;C\u0026quot;声明通常放在全局作用域中，以确保整个程序中的C++代码都遵循相同的链接规则。 extern \u0026quot;C\u0026quot;是C++中处理C语言库的重要工具，它确保了C++代码能够与C语言代码无缝集成和互操作。\n3.使用示例 C++中使用 extern \u0026ldquo;C\u0026rdquo; 示例 ： 1 2 3 4 5 6 7 8 9 10 11 12 // 假设有一个C语言写的库函数，声明如下： // int CFunction(); // C语言中的函数声明 // 在C++中调用C语言写的库函数 extern \u0026#34;C\u0026#34; { int CFunction(); // 使用extern \u0026#34;C\u0026#34;声明 } int main() { int result = CFunction(); // 正确调用C函数 return 0; } C并不能直接调用C++库函数。 关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-extern/","title":"C++ basic extern"},{"content":"C++面试基础系列-C++Features [TOC]\nOverview 1.C++Features C++与C的区别在于C++拥有更多的新特性 \u0026ldquo;Explicit C++\u0026quot;（显式C++）通常指的是在C++编程中明确地、直接地使用C++的特性和语法，而不是隐式地或通过兼容C的方式。这通常意味着充分利用C++的面向对象编程（OOP）特性，例如 类（classes）、 对象（objects）、 继承（inheritance）、 多态（polymorphism）、 抽象（abstraction）、 封装（encapsulation）。 以下是一些显式C++编程的关键概念和实践： 类和对象：使用类来创建复杂的数据结构，这些结构可以包含数据成员和成员函数。\n1 2 3 4 5 6 7 8 class MyClass { private: int privateData; public: MyClass() : privateData(0) {} // 构造函数 void set(int value) { privateData = value; } int get() const { return privateData; } }; 构造函数和析构函数：显式地定义构造函数来初始化对象，定义析构函数来执行清理工作。\n1 2 3 4 MyClass::MyClass(int initialValue) : privateData(initialValue) {} ~MyClass() { // 清理工作 } 继承：使用继承来创建基于现有类的新的类，实现代码复用。\n1 2 3 class DerivedClass : public BaseClass { // 继承BaseClass的成员 }; 多态：通过虚函数实现多态性，允许通过基类指针或引用调用派生类的方法。\n1 2 3 4 5 6 7 8 9 class Base { public: virtual void doSomething() { /* ... */ } }; class Derived : public Base { public: void doSomething() override { /* ... */ } }; 抽象类：使用纯虚函数创建抽象类，这些类不能被实例化，但可以作为其他类的接口。\n1 2 3 4 class AbstractClass { public: virtual void pureVirtualFunc() = 0; // 纯虚函数 }; 封装：将数据和操作这些数据的函数封装在类中，隐藏实现细节。\n1 2 3 4 5 6 7 class Encapsulation { private: int value; public: void setValue(int v) { value = v; } int getValue() const { return value; } }; 模板：使用模板创建泛型类和函数，允许在编译时实例化多种类型的类和函数。\n1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; class TemplateClass { T data; public: void set(T d) { data = d; } T get() const { return data; } }; 异常处理：使用try、catch和throw来处理程序中的异常情况。\n1 2 3 4 5 try { // 可能抛出异常的代码 } catch (const std::exception\u0026amp; e) { // 异常处理代码 } 智能指针：使用智能指针（如std::unique_ptr和std::shared_ptr）来自动管理内存。\n1 std::unique_ptr\u0026lt;MyClass\u0026gt; myPtr = std::make_unique\u0026lt;MyClass\u0026gt;(42); 命名空间：使用命名空间来组织代码，避免名称冲突。\n1 2 3 4 5 namespace MyNamespace { class MyClass { // ... }; } 标准库：充分利用C++标准库（STL），如容器、迭代器、算法等。\n1 2 #include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; myVector = {1, 2, 3}; 显式C++编程鼓励使用C++特有的特性来提高代码的安全性、可读性和效率，而不是依赖C风格的做法。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-features/","title":"C++ basic Features"},{"content":"C++面试基础系列-friend [TOC]\nOverview 在C++中，friend是一个关键字，它用于声明友元函数或友元类。友元是一种特殊的实体，它不是类的成员，但有权访问类的私有（private）和保护（protected）成员。使用friend可以突破类的封装性，让特定的函数或类访问类的内部细节。\n1.friend友元的常见用法 以下是一些关于friend在C++中的用法：\n友元函数：可以声明为友元的函数能够访问类的非公共成员。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MyClass { private: int privateData; public: MyClass(int val) : privateData(val) {} friend void accessPrivateData(MyClass\u0026amp; obj); // 声明友元函数 }; void accessPrivateData(MyClass\u0026amp; obj) { // 直接访问obj的私有成员 std::cout \u0026lt;\u0026lt; obj.privateData \u0026lt;\u0026lt; std::endl; } 友元类：可以声明为友元的类的所有成员函数都能够访问声明它的类的私有和保护成员。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class FriendClass; class MyClass { private: int privateData; public: MyClass(int val) : privateData(val) {} friend class FriendClass; // 声明友元类 }; class FriendClass { public: void accessPrivateData(MyClass\u0026amp; obj) { // 直接访问obj的私有成员 std::cout \u0026lt;\u0026lt; obj.privateData \u0026lt;\u0026lt; std::endl; } }; 友元在多文件编程中的使用：在多文件项目中，需要在类声明中和实现文件中都声明友元函数或类。\n1 2 3 4 5 6 7 8 9 10 // MyClass.h class MyClass { // ... friend void myFriendFunction(MyClass\u0026amp;); }; // MyClass.cpp void myFriendFunction(MyClass\u0026amp; obj) { // ... } 限制：友元不能继承。一个类不能从友元类那里继承访问权限。\n使用场景：当需要让函数或类访问内部数据，但又不想暴露这些数据给其他用户时，使用友元是一个合适的选择。\n注意事项：过度使用友元可能会破坏封装性，导致代码难以维护。应当谨慎使用，只在必要时使用友元。\n友元是C++中实现特定设计和优化性能的一种手段，但应当在确保不破坏类的封装性的前提下使用。\n2.友元函数和友元类在实际编程中有哪些常见的应用场景？ 友元函数和友元类在C++编程中有几种常见的应用场景，主要包括：\n访问私有数据：当一个函数需要访问类的私有成员，但又不想让这个函数成为类的成员函数时，可以将其声明为友元函数。\n实现辅助操作：一些操作可能在逻辑上不属于任何类，但需要访问特定类的私有成员。例如，用于操作或修改多个类内部状态的辅助函数。\n实现特定算法：某些算法可能需要访问多个类的私有数据，但算法本身与这些类没有继承或组合关系。通过声明友元函数，可以在不暴露类内部实现细节的前提下实现算法。\n操作符重载：对于非成员函数的运算符重载，如\u0026lt;\u0026lt;用于输出流，可能需要访问类的私有成员。在这种情况下，运算符重载函数常常被声明为友元。\n实现序列化和反序列化：在进行对象的序列化和反序列化时，可能需要访问对象的所有成员，包括私有成员。通过友元函数可以提供这种访问权限。\n实现单例模式：在实现单例模式时，友元函数可以用来访问私有构造函数，确保只有一个实例被创建。\n实现工厂模式：在工厂模式中，工厂类可能需要访问多个产品的私有构造函数来创建对象实例。通过声明工厂类为友元类，可以访问这些私有成员。\n实现访问者模式：访问者模式中，访问者需要对元素对象执行操作，但元素对象的内部结构需要保护。通过将访问者声明为元素类的友元，可以访问其内部结构。\n实现数据库或文件存储：在将对象存储到数据库或文件系统时，可能需要访问对象的私有成员以序列化数据。友元函数可以提供这种访问权限。\n实现性能优化：在某些性能敏感的应用中，友元函数可以用来减少对象拷贝或直接操作对象的内部数据结构，从而提高性能。\n实现测试和调试工具：在开发测试或调试工具时，可能需要访问类的内部状态，通过友元可以提供这种访问。\n使用友元时需要谨慎，因为它们破坏了类的封装性。过度使用友元可能导致代码难以理解和维护，因此应当在确保必要性和合理性的前提下使用。\n3.如何正确地在C++中使用友元类来优化多线程程序的性能？ 在C++中，使用友元类（friend class）可以优化多线程程序的性能，主要体现在以下几个方面：\n减少数据拷贝：通过允许友元类直接访问另一个类的私有成员，可以避免在多线程间传递和拷贝大量数据，从而提高效率 。\n提高访问速度：友元类可以无需通过公共接口直接访问类的私有成员，这减少了方法调用的开销，在多线程环境中，这可以减少同步所需的时间 。\n简化线程间通信：在多线程程序中，线程间通信是一个常见需求。使用友元类可以简化线程间的直接数据交换和通信，避免了复杂的同步机制 。\n优化资源管理：在多线程环境中，资源的共享和访问控制尤为重要。友元类可以访问类的私有资源管理方法，帮助实现更细粒度的资源控制和优化 。\n避免竞态条件：当多个线程需要访问同一资源时，使用友元类可以设计出更安全的访问模式，因为友元类可以访问用于同步的私有成员，如互斥锁，从而避免竞态条件 。\n提高代码的封装性和可维护性：尽管友元类会破坏一定的封装性，但如果合理使用，可以使得多线程程序的逻辑更加清晰，提高代码的可维护性 。\n实现特定的设计模式：在某些设计模式中，如享元模式或代理模式，友元类可以用来实现对象之间的直接联系，这在多线程环境中可以减少间接层的开销 。\n线程池管理：在实现线程池时，可以使用友元类来允许线程池管理线程的创建和销毁，同时直接访问线程的私有状态和数据，从而提高线程池的效率和响应速度 。\n线程同步：在多线程同步中，友元类可以用来实现同步机制，比如通过友元类访问线程的私有同步数据，实现条件变量、信号量等同步手段 。\n提高数据局部性：通过友元类，可以将频繁访问的数据结构的成员直接暴露给特定线程或线程局部使用，提高CPU缓存的数据局部性，从而提升性能 。\n总之，友元类在多线程程序中的应用可以带来性能上的优化，但同时也需要谨慎使用，以避免过度耦合和破坏封装性。\n4.在C++中，除了使用友元，还有哪些方式可以访问类的私有成员？ 在C++中，除了使用友元（friend），以下是一些可以访问类私有（private）或保护（protected）成员的方式：\n类成员函数：类的成员函数可以直接访问类的私有和保护成员。\n类的友元函数：通过在类内部声明为friend的函数可以访问类的私有和保护成员。\n继承：如果一个类是从另一个类继承来的（即使用private继承），即使基类的成员是私有的，派生类也可以访问这些成员。\n转换构造函数：如果类有一个转换构造函数或转换运算符，它可以将对象转换为另一个类型，并且如果那个类型有访问权限，就可以访问私有成员。\nlambda 表达式：在C++14中，可以在类的成员函数中捕获*this，然后使用lambda表达式来访问私有成员。\n模板函数：通过模板函数可以访问类的私有成员，因为模板实例化时会根据模板参数的具体类型来访问成员。\n嵌套类：如果一个类被定义在另一个类的内部，它自然就可以访问外部类的私有成员。\n静态成员函数：静态成员函数可以直接访问类的私有和保护静态成员。\n标准库算法：一些标准库算法，如std::for_each，可以配合函数对象或lambda表达式来访问对象的私有成员。\n序列化和反序列化：在进行对象的序列化和反序列化时，可以通过友元函数或模板函数来访问对象的私有成员。\n反射：使用一些第三方库，如Boost.Hana，可以实现反射机制，从而访问类的私有成员。\n内存字节直接访问：虽然不推荐使用，但可以通过直接操作内存字节的方式来访问对象的私有成员，这通常涉及到reinterpret_cast和指针运算。\n代理类：创建一个可以访问私有成员的代理类，通过代理类来访问或修改私有成员。\n单例模式：如果类是单例的，那么整个程序中只有一个实例，可以通过这个全局访问点来访问私有成员。\n全局函数：虽然全局函数通常不能直接访问类的私有成员，但如果它们被声明为类的友元，就可以访问。\n请注意，尽管有多种方式可以访问类的私有成员，但应当谨慎使用这些方法，以维护类的封装性和数据的安全性。\n5.除了友元，还有哪些设计模式可以用于访问类的私有成员？ 除了使用友元，以下是一些设计模式，它们可以在不同程度上用于访问或操作类的私有成员：\n代理模式（Proxy Pattern）： 代理模式提供了对目标对象的间接访问，控制对它的访问。代理可以在不暴露对象实现细节的情况下，允许访问其私有成员。\n适配器模式（Adapter Pattern）： 适配器模式可以转换一个类的接口，以便它可以与预期的接口兼容。在转换过程中，可以访问类的私有成员。\n外观模式（Facade Pattern）： 外观模式提供了一个统一的高层接口，用于访问子系统中的一群接口。在这种情况下，外观类可以访问子系统中类的私有成员。\n桥接模式（Bridge Pattern）： 桥接模式将抽象与实现分离，使它们可以独立变化。在桥接模式中，实现类可以访问抽象类的私有成员。\n装饰器模式（Decorator Pattern）： 装饰器模式可以在不修改对象自身的基础上，动态地给对象添加额外的职责。装饰者可以访问被装饰对象的私有成员。\n组合模式（Composite Pattern）： 组合模式允许将对象组合成树形结构，以表示“部分-整体”的层次结构。在这种结构中，组件可以访问叶节点的私有成员。\n策略模式（Strategy Pattern）： 策略模式定义了一系列算法，并将每一个算法封装起来，使它们可以互换。策略可以访问上下文（Context）对象的私有成员。\n模板方法模式（Template Method Pattern）： 模板方法模式在操作中定义了一个算法的框架，将一些步骤的执行延迟到子类中。在模板方法中，子类可以访问父类的私有成员。\n享元模式（Flyweight Pattern）： 享元模式用于高效地共享对象。享元可以访问内部状态的存储，这在某些情况下可以视为访问私有成员。\n访问者模式（Visitor Pattern）： 访问者模式允许在不修改类的情况下添加新的操作。访问者可以访问元素类的私有成员。\n观察者模式（Observer Pattern）： 观察者模式定义了对象之间的一对多依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都会得到通知。在某些实现中，观察者可以访问被观察对象的私有状态。\n中介者模式（Mediator Pattern）： 中介者模式定义了一个中介对象，用以封装一系列对象之间的交互。中介者可以访问相互作用的各个对象的私有成员。\n工厂模式（Factory Pattern）： 工厂模式用于创建对象，而不需要指定将要创建的具体类。在某些实现中，工厂可以访问类的私有构造函数。\n单例模式（Singleton Pattern）： 单例模式确保一个类只有一个实例，并提供一个全局访问点。由于全局访问点可以访问类的私有成员，这在实现单例时很常见。\n命令模式（Command Pattern）： 命令模式将请求封装为一个对象，从而允许用户使用不同的请求、队列或日志请求。命令的执行者可以访问接收者的私有成员。\n这些设计模式可以在不同的上下文和目的下使用，以实现对类私有成员的访问或操作。然而，设计模式的选择应基于具体问题的需求和上下文，以确保代码的清晰性、可维护性和扩展性。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-friend/","title":"C++ basic friend"},{"content":"C++面试基础系列-inline内联 [toc]\nOverview inline可以在头文件中声明和定义函数或变量 不违反一次定义规则（One Definition Rule, ODR） 会加快程序运行速度（避免函数调用的开销，如建立栈帧、传递参数等操作），但会增加代码ROM使用 1.inline介绍 在C++中，inline关键字是一种函数或变量的声明属性，它请求编译器在编译时将函数或变量的定义嵌入到每个使用该函数或变量的地方，从而避免函数调用的开销。使用inline可以提高程序的执行效率，尤其是在调用小型函数时。\n以下是inline的一些关键点和用法：\n1.定义内联函数 内联函数是在定义时使用inline关键字声明的函数。编译器会尝试将这些函数的定义直接嵌入到调用点，从而减少函数调用的开销。\n1 2 3 inline int add(int a, int b) { return a + b; } 2.内联函数的声明与定义 内联函数通常在头文件中声明和定义，这样它们的定义可以被多个编译单元（.cpp文件）包含，而不会违反一次定义规则（One Definition Rule, ODR）。\n3.编译器的自由裁量权 编译器对是否内联一个函数有最终决定权。即使使用了inline关键字，编译器也可能出于优化或其他原因选择不内联该函数。\n4.内联变量 inline也可以用于变量，特别是对于常量表达式。内联变量的定义可以在多个编译单元中使用，而不违反ODR。\n1 inline const int MAX_SIZE = 1024; 5.模板函数自动内联 模板函数在实例化时通常会被编译器视为内联，即使没有显式地使用inline关键字。\n1 2 3 4 template\u0026lt;typename T\u0026gt; T maximum(T a, T b) { return (a \u0026gt; b) ? a : b; } 6.内联汇编 inline还可以与汇编语言一起使用，允许在C++代码中嵌入汇编指令。\n1 2 3 4 5 inline int readFlag() { int flag; asm volatile(\u0026#34;in %1, %0\u0026#34; : \u0026#34;=a\u0026#34;(flag) : \u0026#34;dN\u0026#34;(0x01)); // x86特定汇编 return flag; } 7.内联命名空间 C++17引入了内联命名空间，它允许在不同的编译单元中使用相同的命名空间名称而不会引起冲突。\n1 2 3 4 5 inline namespace experimental { void func() { // ... } } 8.内联函数的限制 内联函数有一些限制，例如它们不能包含循环、跳转语句（如goto）、递归调用等复杂结构。\n9.内联函数的性能 内联函数可以减少函数调用的开销，但同时也会增加代码的大小。如果内联函数体较大，可能会导致缓存失效（cache misses），从而降低程序的运行效率。\n10.显式内联与隐式内联 从C++11开始，如果编译器决定不内联一个inline函数，它将作为普通的非内联函数调用。而在C++11之前，如果编译器不内联inline函数，它将完全忽略该函数的定义。\n使用inline可以提高程序的性能，但应当谨慎使用，以避免不必要的代码膨胀。在某些情况下，现代编译器的优化选项（如GCC的-O2或-O3）可能会自动内联适当的函数，而不需要显式地使用inline关键字。\n2.inline使用方法 在 C++中，inline关键字用于向编译器建议在适当的地方将函数展开，以减少函数调用的开销。以下是关于inline的详细介绍：\n2.1.使用方法 当定义一个函数时，可以在函数返回类型前加上inline关键字。例如：\n1 2 3 inline int add(int a, int b) { return a + b; } 2.2.作用原理 当编译器看到inline函数时，它可能会选择在调用该函数的地方直接将函数体的代码插入，而不是进行传统的函数调用。这样可以避免函数调用的开销，如建立栈帧、传递参数等操作。\n例如，在没有使用inline的情况下，函数调用可能会生成如下汇编代码：\n1 2 3 4 push parameter1 push parameter2 call add_function add esp, 8 ; 清理栈 而如果编译器将inline函数展开，可能的代码会是：\n1 2 mov eax, parameter1 add eax, parameter2 2.3.注意事项 编译器不一定会按照inline的建议进行函数展开。编译器会根据函数的复杂程度、调用次数等因素来决定是否展开函数。如果函数过于复杂，编译器可能会忽略inline关键字。 inline函数的定义通常应该放在头文件中。这是因为当多个源文件包含同一个头文件并使用inline函数时，编译器需要在每个源文件中看到函数的定义才能进行展开。如果inline函数的定义只在一个源文件中，而其他源文件只看到函数声明，编译器可能无法进行展开。 虽然inline可以减少函数调用开销，但过度使用可能会导致代码膨胀。如果函数体很大，展开多个函数调用可能会使生成的目标代码变得很大，从而占用更多的内存。 总的来说，inline是一个有用的关键字，可以在适当的情况下提高程序的性能，但需要谨慎使用。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-inline%E5%86%85%E8%81%94/","title":"C++ basic inline内联"},{"content":"C++面试基础系列-macro_definition宏定义 [toc]\nOverview 在C++中，宏定义是预处理器（preprocessor）的一个功能，它允许你创建一个符号名称来代表一个值或一段代码。宏定义通常在预处理指令#define后面指定。以下是宏定义的一些关键点和用法：\n1.宏定义的概念 1.1. 基本宏定义 使用#define指令创建一个宏。\n1 #define PI 3.14159 1.2. 带参数的宏 可以定义带参数的宏，类似于一个没有花括号的内联函数。\n1 #define SQUARE(x) ((x) * (x)) 1.3. 条件编译 宏可以用于条件编译，控制代码的编译过程。\n1 2 3 4 #define DEBUG_MODE #ifdef DEBUG_MODE std::cout \u0026lt;\u0026lt; \u0026#34;Debug information\u0026#34; \u0026lt;\u0026lt; std::endl; #endif 1 2 3 4 #define DEBUG_MODE #if define(DEBUG_MODE) std::cout \u0026lt;\u0026lt; \u0026#34;Debug information\u0026#34; \u0026lt;\u0026lt; std::endl; #endif 1.4. 宏的展开 在预处理阶段，宏将被展开到它们被引用的地方。\n1 std::cout \u0026lt;\u0026lt; \u0026#34;The square of 3 is \u0026#34; \u0026lt;\u0026lt; SQUARE(3) \u0026lt;\u0026lt; std::endl; 预处理器将上述代码展开为：\n1 std::cout \u0026lt;\u0026lt; \u0026#34;The square of 3 is \u0026#34; \u0026lt;\u0026lt; (3 * 3) \u0026lt;\u0026lt; std::endl; 1.5. 宏的副作用 宏可以导致意外的行为，尤其是如果宏的使用不符合预期或宏的定义不当。\n1.6. 宏与类型 宏可以用来定义常量值，但它们不包含类型信息。\n1.7. 宏的撤销 使用#undef可以撤销宏定义。\n1 #undef PI 1.8. 宏的可见性 默认情况下，宏在定义它们的文件中可见。使用#undef或在文件结尾可以限制它们的可见性。\n1.9. 避免宏冲突 在不同的头文件中定义相同的宏名可能会导致冲突。使用唯一的宏名称或命名空间可以避免这种情况。\n1.10. 宏与函数的区别 宏在预处理阶段展开，没有作用域和类型检查，而函数在编译时调用，具有类型安全和作用域规则。\n1.11. 字符串化操作符（#） 使用#可以将宏参数转换为字符串字面量。\n1 2 #define STRINGIZE(x) #x std::cout \u0026lt;\u0026lt; STRINGIZE(Hello World) \u0026lt;\u0026lt; std::endl; 1.12. 连接操作符（##） 使用##可以将两个宏参数连接起来。\n1 2 #define CONCAT(a, b) a ## b CONCAT(Hello, World); // 展开为HelloWorld 1.13. 宏的限制 宏不支持复杂的表达式和语句，如循环和条件语句。对于这些情况，应使用内联函数或模板。\n1.14. 宏在调试中的问题 宏在调试时可能不太容易跟踪，因为它们在预处理阶段就被展开。\n宏定义是C++中一个强大的工具，但它们也有局限性和潜在的问题。在许多情况下，现代C++推荐使用内联函数、模板或constexpr来替代宏，以提供更好的类型安全和可读性。\n在 C++中，宏定义（macro definition）是一种预处理指令，它允许你用一个标识符来代表一段代码或一个值。以下是关于 C++中宏定义的详细介绍：\n2.宏定义面试回答 2.1.定义方法 使用#define指令来定义宏。例如：\n1 2 #define PI 3.14159 #define MAX(a, b) ((a) \u0026gt; (b)? (a) : (b)) 在第一个例子中，定义了一个名为PI的宏，代表圆周率的值。在第二个例子中，定义了一个名为MAX的宏，它接受两个参数并返回较大的值。\n2.2.二、作用 提高代码的可读性和可维护性：通过给常量或常用表达式定义一个有意义的名称，可以使代码更易于理解。例如，使用PI来代表圆周率，而不是直接使用数值，这样在代码中看到PI就可以很容易地知道它的含义。 方便修改：如果需要修改一个常量的值或一个表达式的实现，可以只在宏定义处进行修改，而不需要在整个代码中逐个查找并修改。例如，如果要改变圆周率的精度，只需要修改PI的定义即可。 提高效率：对于一些简单的操作，可以使用宏来避免函数调用的开销。例如，上面的MAX宏可以在不进行函数调用的情况下比较两个值并返回较大的值。 2.3.注意事项 宏定义只是简单的文本替换，没有类型检查：在使用宏时，编译器不会进行类型检查。因此，可能会出现一些意想不到的结果。例如，MAX(2, 3.5)会将2和3.5都视为整数进行比较，可能会导致错误的结果。\n宏定义可能会引起副作用：如果宏的参数在表达式中有副作用，可能会导致意想不到的结果。例如：\n1 2 3 4 #define SQUARE(x) (x * x) int a = 5; int b = SQUARE(a++); 在这个例子中，b的值可能不是预期的 36，因为a++在宏展开后会被计算两次。\n宏定义没有作用域：宏定义在整个文件中都是有效的，除非被重新定义或使用#undef指令取消定义。这可能会导致命名冲突和难以调试的问题。\n为了避免这些问题，可以考虑使用常量表达式和内联函数来代替宏定义。常量表达式在编译时进行计算，并且有类型检查。内联函数也可以避免函数调用的开销，同时具有类型检查和更好的错误处理能力。\n3.位运算与宏定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #define bitRead(value, bit) (((value) \u0026gt;\u0026gt; (bit)) \u0026amp; 0x01) #define bitSet(value, bit) ((value) |= (1UL \u0026lt;\u0026lt; (bit))) #define bitClear(value, bit) ((value) \u0026amp;= ~(1UL \u0026lt;\u0026lt; (bit))) #define bitReverse(value, bit) ((value) ^= (1UL \u0026lt;\u0026lt; (bit))) #define bitWrite(value, bit, bitvalue) ((bitvalue) ? bitSet(value, bit) : bitClear(value, bit)) #define lowByte(w) ((w) \u0026amp; 0xff) #define highByte(w) ((w) \u0026gt;\u0026gt; 8) #define bitRigthmostGet(value) ((value) \u0026amp; (-value)) #define bitRigthmostClear(value) ((value) \u0026amp; (value-1)) //嵌入式中位操作 #define SET_BIT(REG, BIT) ((REG) |= (BIT)) #define CLEAR_BIT(REG, BIT) ((REG) \u0026amp;= ~(BIT)) #define READ_BIT(REG, BIT) ((REG) \u0026amp; (BIT)) //嵌入式中寄存器操作 #define CLEAR_REG(REG) ((REG) = (0x0)) #define WRITE_REG(REG, VAL) ((REG) = (VAL)) #define READ_REG(REG) ((REG)) #define MODIFY_REG(REG, CLEARMASK, SETMASK) WRITE_REG((REG), (((READ_REG(REG)) \u0026amp; (~(CLEARMASK))) | (SETMASK))) 4.宏定义使用场景 宏定义在C++中的用法多样，主要用于条件编译、常量定义、代码重用、调试辅助等场景。以下是一些常见的使用场景：\n4.1. 定义编译时常量 使用宏定义来创建编译时常量，这些常量在整个程序中都是可见的。\n1 #define MAX_BUFFER_SIZE 1024 4.2. 条件编译 宏定义可以用于条件编译，根据不同的条件包含或排除代码段。\n1 2 3 4 #define DEBUG_MODE #ifdef DEBUG_MODE std::cout \u0026lt;\u0026lt; \u0026#34;Debug information: \u0026#34; \u0026lt;\u0026lt; variable \u0026lt;\u0026lt; std::endl; #endif 4.3. 代码重用 宏定义可以代替多处重复的代码片段，减少代码冗余。\n1 2 #define PRINT_VALUE(x) std::cout \u0026lt;\u0026lt; #x \u0026#34; = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; PRINT_VALUE(value); 4.4. 函数样宏 宏可以定义为接受参数的宏，类似于函数，但它们是文本替换，没有类型检查。\n1 2 #define SQUARE(x) ((x) * (x)) int result = SQUARE(5); 4.5. 调试辅助 宏可以用于简化调试过程，例如定义断点或输出调试信息。\n1 #define DEBUG_BREAK() __builtin_trap() 4.6. 字符串化操作（#） 宏可以将参数转换为字符串，常用于错误消息或调试输出。\n1 2 3 #define STRINGIZE(x) #x #define CREATE_ERROR_MESSAGE(msg) \u0026#34;Error: \u0026#34; msg std::string errorMessage = CREATE_ERROR_MESSAGE(STRINGIZE(Invalid input)); 4.7. 连接符号（##） 宏可以将两个符号连接为一个新的符号。\n1 2 3 #define CONCAT内部(a, b) a ## b #define CONCAT外部(x) CONCAT内部(x, _t) CONCAT外部(myVar); 4.8. 循环展开（续行操作符）（\\） 宏可以用于手动展开循环，有时用于性能优化。\n1 2 3 4 5 6 7 8 #define REPEAT_4_TIMES(func) do { \\ func(0); \\ func(1); \\ func(2); \\ func(3); \\ } while(0) REPEAT_4_TIMES(index, std::cout \u0026lt;\u0026lt; \u0026#34;Index: \u0026#34; \u0026lt;\u0026lt; index \u0026lt;\u0026lt; std::endl;); 4.9. 兼容性和平台特定代码 宏可以用于根据不同的平台或编译器特性包含不同的代码。\n1 2 3 4 5 #if defined(WINDOWS) #define PATH_SEPARATOR \u0026#39;\\\\\u0026#39; #else #define PATH_SEPARATOR \u0026#39;/\u0026#39; #endif 4.10. 创建类型安全宏 使用宏结合类型转换操作符，可以创建类型安全的宏。\n1 #define CAST_PTR(type, ptr) ((type*)(ptr)) 4.11. 避免头文件重复包含 宏常用于防止头文件被多次包含。\n1 2 3 4 5 6 #ifndef HEADER_FILE_NAME_H #define HEADER_FILE_NAME_H // ... 头文件内容 ... #endif // HEADER_FILE_NAME_H 4.12. 性能测试 宏可以用于快速切换性能测试代码的启用或禁用。\n1 2 3 4 #define PERFORMANCE_TEST #ifdef PERFORMANCE_TEST // 性能测试代码 #endif 尽管宏定义在C++中非常有用，但它们也有缺点，如不进行类型检查、可能导致意外的替换效果等。因此，在可能的情况下，推荐使用内联函数、模板或constexpr来替代宏。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-macro_definition%E5%AE%8F%E5%AE%9A%E4%B9%89/","title":"C++ basic macro_definition宏定义"},{"content":"C++面试基础系列-polymorphic [TOC]\nOverview C++ 支持面向对象编程，包括类（Class）和对象（Object）、继承（Inheritance）、封装（Encapsulation）和多态（Polymorphism）。 C 语言不支持面向对象编程。 1.polymorphic多态性 在C++中，多态性（Polymorphism）是一个核心概念，它允许我们通过基类的接口来使用派生类的对象。多态性使得代码更加灵活和可扩展，主要有以下几种形式：\n编译时多态（静态绑定）：通过函数重载和运算符重载实现，它们在编译时就已经确定。\n运行时多态（动态绑定）：通过虚函数实现，调用哪个函数的实现是在运行时根据对象的实际类型来确定的。\n2.编译时多态的实现 编译时多态，也称为静态多态或早绑定（Early Binding），是在编译期间确定函数调用的机制。在C++中，编译时多态主要通过以下几种方式实现：\n函数重载（Function Overloading）：\n允许在同一个作用域内定义多个同名函数，只要它们的参数列表不同（参数类型、数量或顺序不同）。 运算符重载（Operator Overloading）：\n允许为自定义类型定义或修改已有运算符的行为。 模板（Templates）：\n允许创建泛型类和函数，它们可以在编译时根据模板参数实例化出不同类型的具体实现。 示例代码 函数重载示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; // 函数重载示例 void print(int num) { std::cout \u0026lt;\u0026lt; \u0026#34;Integer: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; std::endl; } void print(double num) { std::cout \u0026lt;\u0026lt; \u0026#34;Double: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; std::endl; } int main() { print(10); // 调用第一个print函数 print(3.14); // 调用第二个print函数 return 0; } 在这个例子中，print 函数被重载了两次，一次接受 int 类型的参数，另一次接受 double 类型的参数。编译器根据传递给 print 函数的参数类型来决定调用哪个函数。\n运算符重载示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; class Point { public: int x, y; Point(int x, int y) : x(x), y(y) {} // 运算符重载，实现点的加法 Point operator+(const Point\u0026amp; other) const { return Point(x + other.x, y + other.y); } }; int main() { Point p1(1, 2); Point p2(3, 4); Point p3 = p1 + p2; // 使用重载的 + 运算符 std::cout \u0026lt;\u0026lt; \u0026#34;p3: (\u0026#34; \u0026lt;\u0026lt; p3.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p3.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，我们为 Point 类重载了 + 运算符，使其能够实现两个点的加法。编译器在编译时根据操作数的类型确定使用哪个 + 运算符。\n模板示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; // 模板类示例 template \u0026lt;typename T\u0026gt; class Container { private: T value; public: Container(T val) : value(val) {} T getValue() const { return value; } }; int main() { Container\u0026lt;int\u0026gt; intContainer(10); Container\u0026lt;double\u0026gt; doubleContainer(3.14); std::cout \u0026lt;\u0026lt; \u0026#34;intContainer value: \u0026#34; \u0026lt;\u0026lt; intContainer.getValue() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;doubleContainer value: \u0026#34; \u0026lt;\u0026lt; doubleContainer.getValue() \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，我们定义了一个模板类 Container，它可以存储任何类型的值。编译器在编译时根据模板参数的类型来实例化 Container 类的不同版本。\n编译时多态的优点是调用效率高，因为它在编译期间就已经确定了调用的具体函数或方法。然而，它的局限性在于只能在编译时知道所有可能的调用类型。\n3.运行时多态的实现 虚函数（Virtual Functions）：在基类中使用 virtual 关键字声明的函数，可以被子类重写（Override）。 虚析构函数（Virtual Destructor）：确保通过基类指针删除派生类对象时，能够调用到正确的析构函数。 动态类型识别（Dynamic Cast）：在运行时检查对象的类型，并在需要时将基类指针转换为派生类指针。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; // 基类 class Animal { public: // 虚函数，用于模拟动物的声音 virtual void speak() const { std::cout \u0026lt;\u0026lt; \u0026#34;Some animal sound\u0026#34; \u0026lt;\u0026lt; std::endl; } // 虚析构函数 virtual ~Animal() {} }; // 派生类 Dog class Dog : public Animal { public: // 重写基类的虚函数 void speak() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Woof! Woof!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 派生类 Cat class Cat : public Animal { public: // 重写基类的虚函数 void speak() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Meow! Meow!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { // 创建对象 Animal* animal1 = new Dog(); Animal* animal2 = new Cat(); // 多态性：通过基类指针调用派生类的方法 animal1-\u0026gt;speak(); // 输出: Woof! Woof! animal2-\u0026gt;speak(); // 输出: Meow! Meow! // 清理 delete animal1; delete animal2; return 0; } 在这个例子中，Animal 是一个基类，它有一个虚函数 speak。Dog 和 Cat 是 Animal 的派生类，它们重写了 speak 函数。在 main 函数中，我们创建了 Dog 和 Cat 的对象，并通过基类指针 Animal* 调用了 speak 函数。由于多态性，即使我们通过基类指针调用，实际执行的也是派生类中重写的 speak 函数。\n这种通过基类接口来操作不同派生类对象的能力，就是多态性的体现。它使得我们可以编写更加通用的代码，而不必担心对象的具体类型。\n4.编译时多态的优点 在实际开发中，选择使用编译时多态而不是运行时多态的原因通常包括以下几点：\n性能：\n编译时多态（如函数重载和模板）通常比运行时多态（如虚函数）具有更高的性能。这是因为编译时多态在编译期间就已经确定了函数调用，没有运行时的类型检查和函数查找开销。 类型安全：\n编译时多态提供了更强的类型安全保证。编译器可以在编译期间检查类型错误和不一致性，从而避免了许多运行时错误。 代码清晰和可维护性：\n函数重载和模板可以提供更清晰的代码结构，使得代码更容易理解和维护。开发者可以直观地看到所有重载的函数或模板实例化，而不需要深入到类的继承层次中。 避免虚函数的限制：\n运行时多态依赖于虚函数，但虚函数有一些限制，例如不能是静态的，不能是构造函数，也不能是友元函数。在这些情况下，编译时多态是更合适的选择。 避免虚函数表的开销：\n运行时多态需要使用虚函数表（vtable）来实现，这会带来一定的内存和性能开销。对于小型对象或性能敏感的应用，这可能是不可接受的。 静态链接：\n编译时多态不依赖于运行时的动态链接，这使得程序的部署和链接更加简单和可靠。 编译时决策：\n在某些情况下，我们可能希望在编译时就做出某些决策，例如根据编译时常量来选择不同的实现。编译时多态允许我们根据模板参数或其他编译时已知信息来实现这一点。 避免动态绑定的不确定性：\n运行时多态的动态绑定可能会导致一些不确定性，例如当基类指针或引用指向的对象类型未知时。编译时多态可以消除这种不确定性，因为所有决策都是在编译时做出的。 特定场景的需求：\n在某些特定场景下，如元编程或编译时计算，编译时多态是实现这些需求的唯一或最佳方式。 避免运行时错误：\n运行时多态可能会因为类型不匹配或其他问题导致运行时错误。编译时多态可以在编译期间捕捉这些错误，从而提高程序的稳定性。 总之，编译时多态和运行时多态各有优势和适用场景。在实际开发中，开发者需要根据具体需求、性能要求、代码可维护性和其他因素来选择最合适的方法。在某些情况下，两者也可以结合使用，以实现最佳的编程效果。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-polymorphic/","title":"C++ basic polymorphic"},{"content":"C++面试基础系列-sizeof [TOC]\nOverview sizeof，可用于分析数据结构的内存分配，字节对齐 类 结构体 基础类型int，char等 数组 模板 sizeof与类， 空类的大小为1字节 虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小 普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小 虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！ 虚继承,继承基类的vptr。 1.sizeof基本用法 在 C++ 中，sizeof 运算符用于确定变量或类型在内存中的大小，以字节为单位。sizeof 是编译时运算符，它的值在编译时就已经确定，并被用作一个常量表达式。\n以下是 sizeof 的一些用法示例：\n1.1.基本类型 1 2 int i = 10; std::cout \u0026lt;\u0026lt; sizeof(i); // 输出 \u0026#39;i\u0026#39; 的大小，通常是 4 字节（取决于平台） 1.2.指针类型 1 2 int *p = \u0026amp;i; std::cout \u0026lt;\u0026lt; sizeof(p); // 输出指针 \u0026#39;p\u0026#39; 的大小，通常是 sizeof(void*)（取决于平台） 1.3.数组类型 1 2 int arr[10]; std::cout \u0026lt;\u0026lt; sizeof(arr); // 输出整个数组 \u0026#39;arr\u0026#39; 的大小，10 * sizeof(int) 1.1.结构体和类 1 2 3 4 5 6 7 struct MyStruct { int a; char b; double c; }; std::cout \u0026lt;\u0026lt; sizeof(MyStruct); // 输出 \u0026#39;MyStruct\u0026#39; 的总大小 4 + 1 + （3）+8 =16 1.4.引用类型 1 2 int \u0026amp;ref = i; std::cout \u0026lt;\u0026lt; sizeof(ref); // 输出引用 \u0026#39;ref\u0026#39; 的大小，通常等于 int 的大小 1.5.动态内存分配 1 2 3 int *dynamicArray = new int[10]; std::cout \u0026lt;\u0026lt; sizeof(dynamicArray); // 输出指针的大小，不是数组的大小 delete[] dynamicArray; // 记得释放内存 1.6.sizeof\u0026hellip; (C++11 可变参数模板) C++11 引入了 sizeof... 运算符，用于在模板中获取参数包中的参数数量。\n1 2 3 4 template\u0026lt;typename... Args\u0026gt; std::size_t countArgs() { return sizeof...(Args); } 1.7.注意事项 sizeof 一个类型或变量是编译时计算的，不占用运行时间。 sizeof 一个指针总是返回相同大小，因为指针的大小与它指向的对象的大小无关。 sizeof 一个数组返回的是整个数组的大小，不是数组指针的大小。 sizeof 可以用于静态数组，但对于动态数组，它返回的是指针的大小，而不是分配的内存块的大小。 sizeof 可以用于基本数据类型、指针、数组、结构体、类、枚举和引用。 sizeof 是 C++ 中一个非常有用的工具，可以帮助你了解不同类型和变量在内存中占用的空间大小。\n在 C++ 中，sizeof 运算符可以用来确定类型或对象在内存中的大小，这有助于优化内存分配。以下是一些使用 sizeof 来优化内存分配的方法：\n2.在 C++ 中，如何使用 sizeof 运算符来优化内存分配？ 在 C++ 中，sizeof 运算符可以用来优化内存分配，主要通过确保为对象分配的内存既足够又不过度。以下是一些具体的策略：\n在 C++ 中，可以使用 sizeof 运算符来优化内存分配，以下是一些方法：\n2.1.确定数组大小 静态数组：在定义静态数组时，可以使用 sizeof 来确保数组的大小与特定类型的对象相匹配，避免浪费内存或出现缓冲区溢出。例如：\n1 int arr[sizeof(int) * 10]; // 创建一个足够容纳 10 个整数的数组 这样可以确保数组的大小是根据整数的实际大小计算出来的，而不是使用一个固定的数字，提高了代码的可维护性和灵活性。\n动态分配数组：在使用 new 运算符动态分配数组时，可以结合 sizeof 来确定数组的大小。例如：\n1 int* dynamicArray = new int[sizeof(int) * n]; // n 是一个变量，表示所需的整数数量 这种方法可以根据实际需求动态地分配内存，避免分配过多或过少的内存。\n2.2.结构体和类的内存布局 了解内存占用：通过 sizeof 运算符可以了解结构体或类对象在内存中的占用大小。这对于优化内存布局和避免不必要的内存浪费非常有用。例如：\n1 2 3 4 5 6 struct MyStruct { int a; double b; char c; }; std::cout \u0026lt;\u0026lt; \u0026#34;Size of MyStruct: \u0026#34; \u0026lt;\u0026lt; sizeof(MyStruct) \u0026lt;\u0026lt; std::endl; 通过查看结构体的大小，可以确定其中各个成员变量的排列方式以及可能存在的内存对齐问题。如果发现结构体的大小超出了预期，可以考虑重新排列成员变量的顺序或者使用位域等技术来优化内存布局。\n内存对齐考虑：sizeof 运算符返回的值可能会受到内存对齐的影响。在某些平台上，编译器会对结构体和类的成员变量进行内存对齐，以提高访问效率。了解内存对齐规则可以帮助你更好地利用内存，并避免因对齐问题导致的内存浪费。例如：\n1 2 3 4 5 6 struct MyAlignedStruct { char a; int b; short c; }; std::cout \u0026lt;\u0026lt; \u0026#34;Size of MyAlignedStruct: \u0026#34; \u0026lt;\u0026lt; sizeof(MyAlignedStruct) \u0026lt;\u0026lt; std::endl; 在这个例子中，由于内存对齐的原因，结构体的大小可能会大于各个成员变量大小之和。可以通过调整成员变量的顺序或者使用特定的编译指令来控制内存对齐，以达到优化内存分配的目的。\n2.3.模板参数推导 容器类模板：在编写容器类模板时，可以使用 sizeof 运算符来推导模板参数的大小，从而实现更灵活的内存分配策略。例如：\n1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; class MyContainer { public: MyContainer(size_t size) : data(new T[size * sizeof(T)]) {} ~MyContainer() { delete[] data; } private: T* data; }; 在这个容器类模板中，构造函数根据传入的大小参数和 sizeof(T) 来动态分配内存，确保容器能够容纳正确数量的对象。这种方法可以适应不同类型的对象，提高了代码的通用性。\n函数模板参数推导：在函数模板中，也可以使用 sizeof 来推导参数的大小，从而实现更高效的内存操作。例如：\n1 2 3 4 5 6 template\u0026lt;typename T\u0026gt; void copyArray(T* destination, T* source, size_t size) { for (size_t i = 0; i \u0026lt; size; ++i) { new (destination + i) T(source[i]); } } 在这个函数模板中，通过 sizeof(T) 可以确定每个元素的大小，从而正确地进行内存复制操作。这种方法可以适用于不同类型的数组，提高了代码的复用性。\n2.4.避免内存泄漏和重复分配 动态内存管理：在使用动态内存分配时，要注意避免内存泄漏和重复分配。可以使用智能指针（如 std::unique_ptr 和 std::shared_ptr）来自动管理内存，或者在手动管理内存时，确保在合适的时机释放内存。例如：\n1 2 3 4 5 void processData() { int* data = new int[sizeof(int) * 10]; // 使用数据 delete[] data; } 在这个例子中，手动分配了一块内存，然后在使用完后及时释放。如果忘记释放内存，就会导致内存泄漏。可以考虑使用智能指针来自动管理内存，避免这种错误。\n避免重复分配：在一些情况下，可能会多次分配和释放内存，这会导致性能下降。可以通过合理的设计和使用 sizeof 来避免重复分配内存。例如：\n1 2 3 4 5 6 7 8 9 10 class MyDataProcessor { public: MyDataProcessor(size_t size) : data(new int[size * sizeof(int)]) {} ~MyDataProcessor() { delete[] data; } void processData() { // 使用数据 } private: int* data; }; 在这个例子中，在类的构造函数中一次性分配了足够的内存，然后在整个对象的生命周期内使用。避免了在每次处理数据时都进行内存分配和释放，提高了性能。\n总之，在 C++ 中，sizeof 运算符是一个非常有用的工具，可以帮助你优化内存分配，提高程序的性能和可维护性。但是，要注意正确使用 sizeof，并结合其他内存管理技术，以确保程序的正确性和稳定性。\n3.sizeof详细用例 在 C++ 中，sizeof 运算符提供了类型或对象所占内存的大小（以字节为单位），这可以在多种情况下帮助优化内存分配：\n3.1.动态数组分配 使用 sizeof 确定数组元素类型的大小，然后根据需要的元素数量动态分配数组。\n1 2 3 4 int n = 10; int* arr = new int[n]; // 使用 arr delete[] arr; 3.2.避免过度分配 对于结构体或类，使用 sizeof 来确保为实例分配的内存正好满足需求。\n1 2 3 4 5 6 7 8 9 struct MyStruct { int a; char b; }; size_t size = sizeof(MyStruct); MyStruct* s = static_cast\u0026lt;MyStruct*\u0026gt;(operator new(size)); // 使用 s operator delete(s); 3.3.使用 sizeof 与 new 表达式 在分配未知大小的对象时，可以使用 sizeof 来确保分配正确的大小。\n1 2 3 4 5 char* data = new char[sizeof(MyStruct)]; // 使用 data 作为 MyStruct 类型的内存 MyStruct* s = reinterpret_cast\u0026lt;MyStruct*\u0026gt;(data); // 使用 s delete[] data; 3.4.动态内存分配的类型安全封装 创建模板函数或类来封装内存分配逻辑，使用 sizeof 确保类型安全。\n1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; T* allocateArray(size_t count) { return new T[count]; } int* intArray = allocateArray\u0026lt;int\u0026gt;(100); // 使用 intArray delete[] intArray; 3.5.优化容器类 如果你实现了自定义容器类，使用 sizeof 来确定存储元素所需的内存，可以避免使用额外的内存分配器。\n1 2 3 4 5 6 template\u0026lt;typename T, size_t N\u0026gt; class Stack { private: T buffer[N]; // ... }; 3.6.内存对齐 使用 sizeof 来确保对象按照特定的对齐要求分配内存，这有助于提高访问效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct AlignedStruct { char a; double b; }; size_t alignment = alignof(AlignedStruct); size_t size = sizeof(AlignedStruct); void* memory = operator new(size); AlignedStruct* alignedStruct = reinterpret_cast\u0026lt;AlignedStruct*\u0026gt;( reinterpret_cast\u0026lt;std::uintptr_t\u0026gt;(memory) + alignment - reinterpret_cast\u0026lt;std::uintptr_t\u0026gt;(memory) % alignment ); // 使用 alignedStruct operator delete(memory); 3.7.避免内存泄漏 使用 sizeof 来跟踪分配的内存大小，确保正确释放内存。\n3.8.利用编译时常量 由于 sizeof 是编译时常量，可以在编译时计算所需内存大小，从而避免运行时计算的开销。\n3.9.使用 std::size 对于标准库容器，使用 std::size 成员函数来获取容器中元素的数量，然后结合 sizeof 来分配所需内存。\n1 2 3 4 5 6 std::vector\u0026lt;int\u0026gt; vec; // ... size_t numElements = vec.size(); int* array = new int[numElements]; // 使用 array delete[] array; 3.10.C++11 标准库特性 利用 C++11 的 std::array 或 std::unique_ptr 等特性，它们内部使用 sizeof 来管理内存，提供自动内存管理。\n通过这些方法，sizeof 运算符可以帮助你更精确地控制内存的使用，从而提高程序的性能和效率。然而，也要注意，过度优化可能会导致代码复杂性增加，因此应当在真正需要优化的地方使用这些技术。\n在 C++ 中，sizeof 运算符提供了一种在编译时获取类型或对象所占内存大小的方式。当涉及到类时，sizeof 的行为可以更加复杂，因为类可能包含成员变量、继承、内存对齐要求等。以下是一些更详细的点，解释了 sizeof 与类在 C++ 中的使用：\n4.sizeof与类 4.1.成员变量和类大小 类的大小由其所有非静态成员变量的大小决定。继承的成员也会被计算在内。\n1 2 3 4 5 6 7 8 class MyClass { int a; // 4 字节（大多数系统上） char b; // 1 字节 double c; // 8 字节 }; std::cout \u0026lt;\u0026lt; \u0026#34;Size of MyClass: \u0026#34; \u0026lt;\u0026lt; sizeof(MyClass) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34;; // 输出通常是 13 字节，但可能会因为内存对齐而更大，比如16字节。 4.2.内存对齐 编译器可能会在类成员之间或类末尾添加填充（padding），以确保数据按照特定的对齐边界存储。这可能会增加类的总大小。\n1 2 3 4 5 6 7 class AlignExample { char a; double b; // 可能需要 8 字节对齐 }; std::cout \u0026lt;\u0026lt; \u0026#34;Size of AlignExample: \u0026#34; \u0026lt;\u0026lt; sizeof(AlignExample); // 输出可能大于 9 字节，因为可能会在 \u0026#39;a\u0026#39; 和 \u0026#39;b\u0026#39; 之间添加填充。 4.3.继承和大小 派生类的 sizeof 包括了所有基类的成员，以及它自己的成员。\n1 2 3 4 5 6 7 8 9 10 class Base { int x; }; class Derived : public Base { double y; }; std::cout \u0026lt;\u0026lt; \u0026#34;Size of Derived: \u0026#34; \u0026lt;\u0026lt; sizeof(Derived); // 输出将包括 Base 中的 \u0026#39;x\u0026#39; 和 Derived 中的 \u0026#39;y\u0026#39; 的大小。 4.4.静态成员和大小 静态成员不属于任何类实例，因此它们不计入 sizeof 类的结果。\n1 2 3 4 5 6 7 class MyClass { public: static int staticVar; }; std::cout \u0026lt;\u0026lt; \u0026#34;Size of MyClass with static member: \u0026#34; \u0026lt;\u0026lt; sizeof(MyClass); // 输出通常为 1，因为静态成员不计入大小。 4.5.空类和大小 空类的大小通常至少为 1 字节，以确保在内存中可以区分不同的实例。\n1 2 3 4 class Empty {}; std::cout \u0026lt;\u0026lt; \u0026#34;Size of Empty class: \u0026#34; \u0026lt;\u0026lt; sizeof(Empty); // 输出通常为 1。 4.6.位域 位域是一种特殊的成员，它占用一个固定数量的位，但不一定增加类的大小。\n1 2 3 4 5 6 7 class BitFields { char a : 1; // 占用 1 位 int b : 7; // 占用 7 位，可能占用额外的存储单元 }; std::cout \u0026lt;\u0026lt; \u0026#34;Size of BitFields: \u0026#34; \u0026lt;\u0026lt; sizeof(BitFields); // 输出可能小于 5 字节，因为位域可能共享存储单元。 4.7.模板类和大小 模板类的大小取决于实例化时使用的类型。\n1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; class TemplateClass { T value; }; std::cout \u0026lt;\u0026lt; \u0026#34;Size of TemplateClass\u0026lt;int\u0026gt;: \u0026#34; \u0026lt;\u0026lt; sizeof(TemplateClass\u0026lt;int\u0026gt;); // 输出将取决于 \u0026#39;int\u0026#39; 的大小。 4.8.匿名类和大小 匿名类的大小由其成员决定，但它们通常用于定义不命名的类型。\n1 2 3 4 5 int main() { auto lambda = []() {}; std::cout \u0026lt;\u0026lt; \u0026#34;Size of anonymous lambda: \u0026#34; \u0026lt;\u0026lt; sizeof(lambda); // 输出取决于捕获的变量和编译器实现。 } 4.9.sizeof 与指针 sizeof 一个类的指针总是等于指针的大小，而不是类实例的大小。\n1 2 3 MyClass* ptr = nullptr; std::cout \u0026lt;\u0026lt; \u0026#34;Size of pointer to MyClass: \u0026#34; \u0026lt;\u0026lt; sizeof(ptr); // 输出是指针的大小，通常为 4 或 8 字节。 理解 sizeof 在类中的应用可以帮助你更好地管理内存和优化性能。然而，依赖于 sizeof 进行编程应该谨慎，因为内存布局可能因编译器和平台而异。\n在 C++中，sizeof运算符在涉及类时有以下一些重要特点和用途：\n4.10.继承与多态对sizeof的影响 单继承：\n当一个类从另一个类继承时，派生类对象的大小包括基类部分的大小和派生类自身成员变量的大小。\n例如：\n1 2 3 4 5 6 7 8 class Base { public: int baseData; }; class Derived : public Base { public: char derivedData; }; sizeof(Derived)的结果将大于等于sizeof(Base)+sizeof(char)，具体大小取决于内存对齐要求。\n多继承：\n在多继承的情况下，派生类对象的大小是各个基类部分大小之和，再加上派生类自身成员变量的大小以及可能的内存对齐所需的额外空间。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 class Base1 { public: int data1; }; class Base2 { public: double data2; }; class DerivedMulti : public Base1, public Base2 { public: char data3; }; sizeof(DerivedMulti)的结果将取决于Base1、Base2和DerivedMulti各自的大小以及内存对齐要求。\n虚函数与虚继承：\n如果一个类包含虚函数，编译器通常会为该类对象添加一个指向虚函数表的指针，这会增加类对象的大小。\n例如：\n1 2 3 4 5 class WithVirtual { public: virtual void doVirtual() {} int normalData; }; sizeof(WithVirtual)将大于sizeof(int)，因为需要额外的空间来存储虚函数表指针。\n如果一个类使用虚继承，也会增加类对象的大小，以存储额外的信息来解决多继承中的二义性问题。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-sizeof/","title":"C++ basic sizeof"},{"content":"C++面试基础系列-static 1.static含义 static关键字\n静态变量和静态类 类中的静态成员 在C++中，static 关键字有多个用途，包括定义静态变量、静态成员函数、静态数据成员、静态常量成员以及在函数中定义静态局部变量。以下是对 static 在C++中的详细描述：\n2.普通静态变量 2.1.静态全局变量 当 static 用于全局变量时，它限制了变量的链接范围，使其只在定义它的文件内部可见，其他文件无法访问。\n2.2.静态局部变量 在函数内部定义的 static 变量具有静态存储期。这意味着它们在程序的整个运行期间都存在，而不是仅在函数调用期间。每次函数调用时，static 局部变量都会保留上一次调用的值。\n3.类中静态变量 3.1.静态成员变量 类的静态成员变量属于类本身，而不是类的任何特定对象。它们在所有对象之间共享。静态成员变量在所有实例之前或之后初始化，在程序的整个生命周期内保持其值。\n3.2.静态常量成员 静态常量成员是类的一个特殊成员，它不仅具有静态存储期，还具有 const 特性。它们在定义时必须被初始化，并且不能被修改。\n3.3.静态成员函数 静态成员函数属于类本身，而不是类的任何对象。它们可以访问类的静态成员，但不能访问非静态成员，因为它们没有 this 指针。静态成员函数可以在没有创建类的对象的情况下被调用。\n3.4.静态类 从C++11开始，可以定义一个静态类，它只能包含静态成员，不能有构造函数、析构函数或基类。\n3.5.模板中的静态 在类模板中，静态成员具有特殊的行为。每个实例化的模板类都有自己的静态成员，它们不是共享的。\n3.6.嵌套静态类 在C++中，可以在类中定义静态类（也称为嵌套类），这些类在定义它们的类的外部是不可访问的。\n初始化： 静态数据成员通常在类的定义外部进行初始化，而不是在类内部。\n作用域： 静态成员的作用域是整个程序，它们可以在类的任何对象上通过类名直接访问。\n内存分配： 静态成员变量和静态局部变量存储在静态存储区，而不是堆栈或堆上。 以下是一些示例来说明 static 的使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 静态全局变量 static int globalVar = 42; // 只在定义它的文件内可见 void function() { // 静态局部变量 static int staticVar = 0; // 函数调用间保留值 staticVar++; } class MyClass { public: // 静态成员变量 static int staticMember; // 静态常量成员 static const int staticConstMember = 10; // 静态成员函数 static void staticMemberFunction() { staticMember++; // 可以访问静态成员变量 } }; // 在类外初始化静态成员变量 int MyClass::staticMember = 0; void functionWithStatic() { // 使用静态成员 MyClass::staticMemberFunction(); const int localStaticConst = 5; // 局部静态常量，作用域限制在函数内 } 关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-static/","title":"C++ basic static"},{"content":"C++面试基础系列-struct 1.C中struct struct里面只能放数据类型（基本数据类型，自定义数据类型，指针等），不能放置函数 C中不存在public、protected、private， C中，定义结构体变量，定义必须加struct。 C不存在继承 结构体与函数的名称可以相同 2.C++中struct C++中strcut基本和class一致\nC++中，struct默认是public，class默认是private C++中，存在public、protected、private C++中，使用时，可以不带strcut C++中，可以继承 C++中，若结构体的名字与函数名相同，可以正常调用！但是定义结构体变量时候只能用带struct的！ 2.1.同名函数 1 2 3 4 5 6 struct A { }; A(){} struct A s; //ok A s; //error 2.2.typedef定义结构体别名 A自带struct，不可以直接调用函数\n1 2 3 4 5 6 7 8 9 typedef struct a{ int a; }A; int main() { A a; return 0; } 2.3.继承 struct继承和class是一致\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; struct Base { int a; virtual void print() { std::cout \u0026lt;\u0026lt; \u0026#34;print\u0026#34; \u0026lt;\u0026lt; std::endl; } }; struct Derived : public Base { public: int v2; void print() { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;Derived\u0026#34;); }; }; int main() { Derived *b = new Derived(); b-\u0026gt;print(); return 0; } 3.总结 3.1.C和C++中的Struct区别 C C++ 不能将函数放在结构体声明 能将函数放在结构体声明 在C结构体声明中不能使用C++访问修饰符。 public、protected、private 在C++中可以使用。 在C中定义结构体变量，如果使用了下面定义必须加struct。 可以不加struct 结构体不能继承（没有这一概念）。 可以继承 若结构体的名字与函数名相同，可以正常运行且正常的调用！ 若结构体的名字与函数名相同，使用结构体，只能使用带struct定义！ 在C++中，struct和class都可以用来定义自定义数据类型，但它们之间存在一些关键的区别：\n默认访问权限： struct的成员默认是public，即可以被任何外部代码访问。 class的成员默认是private，即只能在类的内部访问。 继承访问权限： 当一个struct继承自另一个struct时，基类的public成员在派生类中默认也是public。 当一个class继承自另一个class时，基类的public成员在派生类中默认是private。 设计意图： struct通常用于简单的数据结构，如纯数据的聚合，没有太多的封装和抽象。 class通常用于创建具有封装、继承和多态性的面向对象结构。 构造函数和析构函数： struct可以有构造函数和析构函数，但它们默认是public的。 class也可以有构造函数和析构函数，但它们默认是private的，除非显式指定。 继承： struct可以被继承，并且基类的成员在派生类中保持原有的访问级别。 class也可以被继承，但基类的public成员在派生类中默认是private的。 多态： struct支持多态，但通常不会用struct来实现多态性，因为它通常不包含虚函数。 class支持多态，并且可以包含虚函数和抽象类。 语法： struct和class在语法上几乎相同，都可以包含数据成员、成员函数、继承等。 使用场景： struct通常用于类似C语言的简单记录结构，没有方法或行为。 class用于定义具有封装、继承和多态性的复杂数据类型。 C++11及以后： 从C++11开始，struct和class在使用上更加一致，struct也可以包含成员函数和构造函数。 在实际使用中，struct和class的区别主要在于默认的访问权限和设计意图。struct更适合简单的数据结构，而class更适合需要封装和继承的面向对象设计。然而，这种区分更多是传统和风格上的，技术上两者几乎可以互换使用。 4.struct字节对齐 结构体占用内存空间大小，结构体存在字节对齐现象，实际使用空间往往大于结构体内部定义的数据的大小总和。\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;iostream\u0026gt; struct A{ int a; char b; double c; }; int main() { std::cout\u0026lt;\u0026lt;\u0026#34;A size is\u0026#34; \u0026lt;\u0026lt; sizeof(A)\u0026lt;\u0026lt;std::endl; } 在64位系统中，实际占用空间为16字节，a,b共同占用8字节，c占用8字节\n5.struct与const 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026#34;stdio.h\u0026#34; #include \u0026lt;string.h\u0026gt; #define ADDRESS_USER 0x1000000 #define ADDRESS_LENGTH 100 unsigned char buffer1[ADDRESS_LENGTH]; unsigned char buffer2[ADDRESS_LENGTH]; unsigned char buffer3[ADDRESS_LENGTH]; unsigned char buffer4[ADDRESS_LENGTH]; typedef struct buffer { unsigned int address; unsigned int address_length; unsigned char *pbuffer; } Buffer; // const Buffer test1 = {ADDRESS_USER, ADDRESS_LENGTH, \u0026amp;buffer1[0]}; // const Buffer test2 = {ADDRESS_USER, ADDRESS_LENGTH, \u0026amp;buffer2[0]}; // const Buffer test3 = {ADDRESS_USER, ADDRESS_LENGTH, \u0026amp;buffer3[0]}; // const Buffer test4 = {ADDRESS_USER, ADDRESS_LENGTH, \u0026amp;buffer4[0]}; const Buffer test[4] = { {ADDRESS_USER, ADDRESS_LENGTH, \u0026amp;buffer1[0]}, {ADDRESS_USER, ADDRESS_LENGTH, \u0026amp;buffer2[0]}, {ADDRESS_USER, ADDRESS_LENGTH, \u0026amp;buffer3[0]}, {ADDRESS_USER, ADDRESS_LENGTH, \u0026amp;buffer4[0]}}; const Buffer *pstructbuffers[4] = { \u0026amp;test[0], \u0026amp;test[1], \u0026amp;test[2], \u0026amp;test[3]}; const Buffer **get_buffer() { return pstructbuffers; } int main() { // Buffer **tests = (Buffer **)pstructbuffers; const Buffer **tests; tests = get_buffer(); for (int i = 0; i \u0026lt; 4; i++) { memcpy(tests[i]-\u0026gt;pbuffer, \u0026#34;testestes\u0026#34;, i + 1); } for (int i = 0; i \u0026lt; 4; i++) { printf(\u0026#34;buffer = %s\\r\\n\u0026#34;, tests[i]-\u0026gt;pbuffer); } return 0; } 关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-struct/","title":"C++ basic struct"},{"content":"C++面试基础系列-this指针 [TOC]\nOverview 1.this指针 在 C++ 中，this 指针是一个特殊的指针，它在每个非静态成员函数中自动可用。this 指向调用成员函数的当前对象实例。以下是 this 指针的一些关键特性和用法：\n1.1.特性 隐式存在：在成员函数中，this 指针隐式地可用，不需要定义或声明。\n指向当前对象：this 指针指向调用成员函数的对象。\n类型为当前类的指针：this 的类型是成员函数所在类的指针类型。\n在静态成员函数中不可用：由于静态成员不属于任何对象实例，因此在静态成员函数中 this 指针不可用。\n用于区分成员变量和局部变量：当局部变量名与成员变量名相同时，this 可以用来区分它们。\n1.2.用法 访问成员变量\n1 2 3 4 5 6 7 class MyClass { int value; public: void setValue(int v) { this-\u0026gt;value = v; // 使用 this 指针访问成员变量 } }; 调用其他成员函数：\n1 2 3 4 5 6 7 8 9 class MyClass { void doSomething() { // ... } public: void execute() { this-\u0026gt;doSomething(); // 使用 this 指针调用另一个成员函数 } }; 在构造函数中使用：\n1 2 3 4 5 6 7 8 9 class MyClass { public: MyClass(int v) { this-\u0026gt;setValue(v); // 在构造函数中使用 this 指针调用成员函数 } void setValue(int v) { // ... } }; 实现赋值运算符：\n1 2 3 4 5 6 7 8 9 10 class MyClass { int value; public: MyClass\u0026amp; operator=(const MyClass\u0026amp; other) { if (this != \u0026amp;other) { // 检查自赋值 this-\u0026gt;value = other.value; } return *this; // 返回当前对象的引用 } }; 用于多态： 当涉及到多态时，this 指针可以被转换为派生类的指针：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Base { public: virtual ~Base() {} }; class Derived : public Base { int extraValue; public: void process() { // 安全地将 this 转换为 Derived 类型的指针 Derived* d = dynamic_cast\u0026lt;Derived*\u0026gt;(this); // 使用 d 指针 } }; 在 lambda 表达式中使用： 在成员函数中定义的 lambda 可以捕获 this 指针：\n1 2 3 4 5 6 7 8 9 10 11 12 class MyClass { public: void execute() { int value = 10; [=](){ // 通过值捕获 this 指针 doSomething(); }(); } void doSomething() { // ... } }; 避免对象复制： 使用 this 指针实现深拷贝或浅拷贝逻辑。\n1.3.注意事项 应谨慎使用 this 指针，避免不必要的使用，因为它可能会使代码的意图不够明确。 在多态情况下，使用 dynamic_cast 转换 this 指针时，只有在含有虚函数的类中才有效。 在构造函数和析构函数中也可以使用 this 指针，但要确保使用方式是安全的，因为这些特殊时期对象可能未完全构造或正在被销毁。 this 指针是 C++ 中一个强大的特性，正确使用它可以提高代码的灵活性和表达能力。\n当然可以。在 C++ 中，多态性通常通过虚函数实现，而 this 指针在多态类中可以用来调用成员函数或访问成员变量，尤其是在需要明确对象类型时。以下是一个使用 this 指针的多态类的示例：\n2.使用 \u0026rsquo;this\u0026rsquo; 指针的多态类的示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;memory\u0026gt; // 基类 class Animal { public: virtual ~Animal() {} // 虚函数，用于多态 virtual void speak() const { std::cout \u0026lt;\u0026lt; \u0026#34;Some generic animal sound\u0026#34; \u0026lt;\u0026lt; std::endl; } // 使用 this 指针调用其他成员函数 void performAction() { std::cout \u0026lt;\u0026lt; \u0026#34;The animal is performing an action.\u0026#34; \u0026lt;\u0026lt; std::endl; this-\u0026gt;speak(); // 调用虚函数 } }; // 派生类 class Dog : public Animal { public: void speak() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Woof! Woof!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Cat : public Animal { public: void speak() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Meow! Meow!\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 使用多态和 this 指针 void makeAnimalsSpeak(const std::vector\u0026lt;std::shared_ptr\u0026lt;Animal\u0026gt;\u0026gt;\u0026amp; animals) { for (const auto\u0026amp; animal : animals) { // 通过 this 指针明确调用 speak 函数 ((Animal*)this)-\u0026gt;speak(); // 错误的使用示例，仅用于说明 this 的作用 animal-\u0026gt;speak(); // 正确的多态调用 } } int main() { std::vector\u0026lt;std::shared_ptr\u0026lt;Animal\u0026gt;\u0026gt; animals; animals.push_back(std::make_shared\u0026lt;Dog\u0026gt;()); animals.push_back(std::make_shared\u0026lt;Cat\u0026gt;()); makeAnimalsSpeak(animals); return 0; } 在这个示例中：\nAnimal 是一个基类，有一个虚函数 speak() 和一个非虚函数 performAction()。performAction() 使用 this 指针调用 speak()，展示了如何在类内部使用 this 指针调用成员函数。 Dog 和 Cat 是从 Animal 派生的子类，它们重写了 speak() 函数，提供了具体的实现。 makeAnimalsSpeak() 函数接受一个 Animal 指针的 std::vector，并调用每个动物的 speak() 函数。这里展示了如何通过多态性使用 this 指针。注意，示例中的 ((Animal*)this)-\u0026gt;speak(); 是错误的用法，仅用于说明 this 的作用。正确的用法是 animal-\u0026gt;speak();，它利用了多态性调用正确的 speak() 版本。 在 main() 函数中，我们创建了一个 Animal 对象的向量，其中包括 Dog 和 Cat 的实例，并调用 makeAnimalsSpeak() 来演示多态性。 这个示例展示了如何在多态上下文中使用 this 指针，以及如何在派生类中重写虚函数来实现不同行为。\n3.在C++中，指针和对象本身有什么区别？ 在 C++ 中，指针和对象本身有几个关键的区别：\n存储内容：\n对象：对象是实际的数据实体，它占用内存并包含数据和可能的行为（通过成员函数）。 指针：指针是一个变量，它存储的是另一个对象的内存地址。 内存占用：\n对象：对象的大小通常比指针大，因为它包含了实际的数据。 指针：指针的大小在 32 位系统上通常是 4 字节，在 64 位系统上是 8 字节，与它所指向的对象大小无关。 访问数据：\n对象：可以直接访问对象的成员变量和函数。 指针：需要使用解引用操作符（*）来访问指针指向的对象的成员。 生命周期：\n对象：对象有自己的生命周期，它可能在栈上自动创建和销毁，或在堆上通过 new 和 delete 进行管理。 指针：指针本身有自己的生命周期，但它指向的对象可能有不同的生命周期。 别名：\n对象：对象通常只有一个标识符。 指针：可以通过多个指针引用同一个对象（别名），这可能导致复杂的内存管理问题。 可变性：\n对象：对象的地址在声明后通常不会改变（除非使用 std::move）。 指针：指针的值（即它所指向的地址）可以在运行时改变。 数组和指针：\n对象：不能直接将对象视为数组来处理。 指针：指针可以进行算术运算（如加法和减法），这使得指针可以像数组一样使用。 传递性能：\n对象：按值传递对象可能会涉及复制构造函数，这可能代价昂贵。 指针：指针传递的是地址，通常是很小的数据量，开销较小。 安全性：\n对象：使用对象通常更安全，因为它们不允许悬空或未定义的状态。 指针：指针需要小心管理，不当使用可能导致悬空指针、野指针或内存泄漏。 语法：\n对象：使用变量名直接访问。 指针：需要通过 -\u0026gt; 运算符来访问指针指向的对象的成员。 理解指针和对象之间的区别对于编写有效和安全的 C++ 程序至关重要。指针提供了强大的灵活性，但也需要更多的注意力来确保正确管理内存和对象的生命周期。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-this/","title":"C++ basic this"},{"content":"C++面试基础系列-union C++面试基础系列-union 1.union含义 2.union的关键点1 3.union的关键点2 4.union与struct的区别 关于作者 1.union含义 在C++中，union是一种特殊的数据类型，它允许在相同的内存位置存储不同的数据类型。union与struct类似，但它的所有成员都共享相同的内存地址。这意味着在任意时刻只能访问union中的一个成员，如果访问了一个新的成员，那么之前存储的值将被覆盖。\n1 2 3 4 5 6 union UnionName { type1 member1; type2 member2; ... typeN memberN; }; 这里的type1到typeN是数据类型，member1到memberN是成员变量。\n使用union的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 union Data { int i; char c; double d; }; int main() { Data data; // 存储一个整数 data.i = 10; std::cout \u0026lt;\u0026lt; \u0026#34;Integer: \u0026#34; \u0026lt;\u0026lt; data.i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 存储一个字符，这将覆盖data.i的值 data.c = \u0026#39;a\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Character: \u0026#34; \u0026lt;\u0026lt; data.c \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // data.i的值已经被覆盖，所以输出将不是10 std::cout \u0026lt;\u0026lt; \u0026#34;Integer after storing character: \u0026#34; \u0026lt;\u0026lt; data.i \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 2.union的关键点1 union的所有成员始于相同的内存地址。 union的大小等于其最大成员的大小。在上面的例子中，Data的大小将等于一个double的大小，因为double通常比int和char占用更多的字节。 union可用于内存对齐和打包，以及访问字节级数据。 union不允许有引用类型的成员，也不能有继承或虚函数。 union可以用于位域操作，尽管这通常不是推荐的做法。 3.union的关键点2 联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：\n默认访问控制符为 public 可以含有构造函数、析构函数 不能含有引用类型的成员 不能继承自其他类，不能作为基类 不能含有虚函数 匿名 union 在定义所在作用域可直接访问 union 成员 匿名 union 不能包含 protected 成员或 private 成员 全局匿名联合必须是静态（static）的 4.union与struct的区别 struct的每个成员都有自己的内存位置，而union的所有成员共享一个内存位置。 struct可以有构造函数、析构函数和成员函数，而union不能。 struct可以用于继承，而union不能。 union在需要节约内存或需要通过同一个内存位置访问不同类型的数据时非常有用，但使用时需要小心，以避免数据被意外覆盖。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-union/","title":"C++ basic union"},{"content":"C++面试基础系列-using [TOC]\nOverview 1.using关键字 在 C++ 中，using 关键字有几种不同的用法，主要用于别名声明、类型导入和命名空间的成员导入。以下是 using 的几种常见用法：\n1.1. 别名声明（Type Alias） 使用 using 为类型创建一个别名，简化复杂类型的书写。\n1 2 using int_ptr = std::shared_ptr\u0026lt;int\u0026gt;; int_ptr p = std::make_shared\u0026lt;int\u0026gt;(10); // 使用别名创建智能指针 1.2. 模板别名 为模板类型创建一个别名，简化模板类型的书写。\n1 2 using IntVector = std::vector\u0026lt;int\u0026gt;; IntVector v; // 使用别名创建向量 1.3. 类别名 为类或其指针、引用类型创建别名。\n1 2 3 4 5 6 class MyClass { // ... }; using MyHandle = MyClass*; // 创建类指针的别名 MyHandle h = new MyClass(); 1.4. 命名空间导入 使用 using 从命名空间中导入特定的名称，避免重复前缀。\n1 2 3 4 5 6 namespace NS { void foo() {} } using NS::foo; // 导入函数 foo(); // 直接调用 1.5. 命名空间别名 为命名空间创建别名，简化长命名空间的引用。\n1 2 namespace my_namespace = ::std::chrono; my_namespace::seconds sec(5); 1.6. 导入构造函数 使用 using 语句导入基类的构造函数，使得派生类具有与基类相同的构造函数签名。\n1 2 3 4 5 6 7 8 9 10 11 class Base { public: Base(int x) {} }; class Derived : Base { public: using Base::Base; // 导入 Base 类的构造函数 }; Derived d(10); // 直接使用 Base 的构造函数 1.7. 委托构造函数 C++11 允许在类内部使用 using 委托其他构造函数。\n1 2 3 4 5 6 7 class MyClass { public: MyClass() {} MyClass(int x) : MyClass() { // ... } }; 1.8. 注意事项 using 声明不应该与 using 指令混淆，后者是命名空间的另一种用法，用于使命名空间中的名称在当前作用域内可用。 using 声明是作用域限定的，它只在声明它们的作用域内有效。 在模板中使用 using 可以简化模板类型的书写，特别是在模板别名中。 正确使用 using 可以提高代码的可读性和可维护性，但过度使用或不当使用可能会导致代码可读性降低。\n在 C++ 中，using 声明（using declaration）和 using 指令（using directive）是两种不同的命名空间相关的关键字，它们各自有不同的用途和适用场景：\n2.C++ 中的 using 声明和 using 指令有什么区别？ C++ 中的 using 声明和 using 指令有什么区别，它们各自在什么情况下使用？\n2.1.using 声明 (using declaration) using 声明用于从命名空间中导入特定的名称（如函数、变量、类型等），使其在当前作用域内可以直接使用而不需要命名空间前缀。\n语法：\n1 using namespace::name; 示例：\n1 2 3 4 5 6 #include \u0026lt;vector\u0026gt; using std::vector; // 导入 std 命名空间中的 vector int main() { vector\u0026lt;int\u0026gt; v; // 直接使用 vector 而不需要 std:: 前缀 } 使用场景：\n当你需要在当前作用域内多次使用某个命名空间中的特定名称时。 当你想要简化代码书写，避免重复书写长命名空间前缀时。 2.2.using 指令 (using directive) using 指令用于将整个命名空间中的所有名称导入到当前作用域，使得所有名称都可以不加前缀地直接使用。\n语法：\n1 using namespace ns; 示例：\n1 2 3 4 5 6 #include \u0026lt;iostream\u0026gt; using namespace std; // 导入 std 命名空间中的所有内容 int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; endl; // 直接使用 cout 和 endl 而不需要 std:: 前缀 } 使用场景：\n当你需要在当前作用域内使用某个命名空间中的多个名称时。 当你确信当前作用域内不会发生名称冲突时。 2.3.区别 作用范围：using 声明只导入特定的名称，而 using 指令导入整个命名空间的所有名称。 名称冲突：使用 using 声明时，不容易造成名称冲突，因为只有特定的名称被导入；而 using 指令可能会引起名称冲突，因为它导入了所有名称。 代码清晰度：using 声明可以提高代码的清晰度，因为它明确了名称的来源；而 using 指令可能会降低代码的清晰度，因为它隐藏了名称的来源。 使用限制：using 指令不能用于类的作用域内，而 using 声明可以。 2.4.最佳实践 尽量避免在大型代码库或头文件中使用 using 指令，因为它可能导致名称冲突和降低代码的可读性。 优先使用 using 声明来导入所需的特定名称，这样可以提高代码的可维护性和可读性。 在确实需要使用 using 指令时，最好将其限制在较小的作用域内，如函数或代码块内部。 理解 using 声明和 using 指令的区别，以及它们各自的适用场景，有助于编写更清晰、更安全的 C++ 代码。\n3.using示例 以下是一个简单的 C++ 代码示例，展示了 using 声明和 using 指令的使用及其区别：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; // 使用 using 指令导入整个 std 命名空间 using namespace std; // main 函数 int main() { // 可以直接使用命名空间 std 中的类型和函数，无需前缀 cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; endl; vector\u0026lt;int\u0026gt; numbers = {1, 2, 3, 4, 5}; // 使用 using 声明导入特定函数 using string::npos; // 从 string 类中导入 npos 成员 // 使用导入的 npos string s = \u0026#34;Hello, using declaration!\u0026#34;; string::size_type pos = s.find(\u0026#34;using\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;Position of \u0026#39;using\u0026#39;: \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; // 输出找到的字符串位置 cout \u0026lt;\u0026lt; \u0026#34;Position of \u0026#39;example\u0026#39; (not found): \u0026#34; \u0026lt;\u0026lt; s.find(\u0026#34;example\u0026#34;, 0) \u0026lt;\u0026lt; endl; // 使用 npos 作为未找到的默认值 // 尝试使用 std::vector 的 size() 成员函数 cout \u0026lt;\u0026lt; \u0026#34;Size of vector: \u0026#34; \u0026lt;\u0026lt; numbers.size() \u0026lt;\u0026lt; endl; // 正确使用 // 如果注释掉 using namespace std; 则需要使用 std:: 前缀来调用 // cout \u0026lt;\u0026lt; \u0026#34;Size of vector (with prefix): \u0026#34; \u0026lt;\u0026lt; std::vector\u0026lt;int\u0026gt;::size() \u0026lt;\u0026lt; endl; return 0; } 在这个示例中：\n我们首先使用 using namespace std; 导入了整个 std 命名空间，这允许我们在 main 函数中直接使用 std 命名空间中的所有名称，如 cout、endl 和 vector。\n接着，我们使用 using string::npos; 声明导入了 std::string 类的 npos 成员。这是一种 using 声明，它只导入了 string 类中的 npos 常量，而不是整个 string 类或 std 命名空间。这样，我们就可以在不使用 std:: 前缀的情况下直接使用 npos。\n示例中展示了使用 npos 来查询字符串中未找到的子字符串的默认行为。\n我们可以直接使用 vector 的 size() 成员函数，因为我们已经通过 using namespace std; 导入了 std 命名空间。如果你注释掉 using namespace std;，则需要使用 std:: 前缀来访问 size()，如示例中注释的部分所示。\n这个示例展示了 using 声明和 using 指令如何影响作用域内名称的使用，以及如何通过它们来简化代码书写。使用 using 声明可以避免命名空间的冲突，而 using 指令则提供了一种快速访问命名空间中所有名称的方法，但可能会引起名称冲突。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-using/","title":"C++ basic using"},{"content":"C++面试基础系列-volatile 1.volatile核心规则 volatile修饰变量或指针功能 告诉编译器，被volatile修饰的变量或指针（寄存器或硬件寄存器），不要进行优化 变量或指针在中断服务子程序，用户函数中同时调用，不要进行优化 多线程，多任务同时调用变量或指针，使用volatile修饰，表示每次操作该变量或指针，都要从内存中取最新的值进行操作。 简单来说 编译器，不要优化 从内存取值 2.C与C++中volatile区别 在C和C++中，volatile关键字都用于告诉编译器一个变量可能会在程序的控制之外被改变，通常是由于硬件的作用。尽管C和C++都支持volatile，但它们在某些方面存在一些差异： 2.1.C语言中的volatile 在C语言中，volatile主要用于多线程环境或中断服务例程（ISR）中，指示编译器该变量可能会在任何时候被改变，因此每次使用时都应该从内存中重新读取，而不是从寄存器中。 C标准并没有详细说明volatile的所有行为，尤其是在多线程同步方面。 2.2.C++中的volatile C++中的volatile用法与C类似，但C++标准对volatile的行为有更明确的定义，特别是在多线程环境中。 在C++11及以后的版本中，标准定义了内存模型，volatile变量的访问将遵循这些规则，以确保在多线程环境中对它们的访问是原子的（如果需要）。 2.3.原子性和顺序 在C++11中，volatile关键字不保证操作的原子性，即使在多线程环境中也是如此。如果需要原子性，C++提供了std::atomic模板和相关的原子操作函数。 C++中的volatile也不保证编译器不会重排相关操作的顺序，这与C类似。 2.4.易失性 在C和C++中，volatile都可以用来指示编译器一个变量是易失性的，即它可能会因为外部硬件事件而改变。 2.5.优化 由于volatile告诉编译器变量可能在任何时候改变，编译器将不会对这个变量进行优化。 2.6.使用场景 在嵌入式编程中，volatile经常用于访问内存映射的硬件寄存器，因为这些寄存器可能会被外部硬件改变。 2.7.C++特有的特性 C++中volatile的使用可能会受到C++特有的特性影响，如类和对象模型。例如，C++中的volatile成员变量需要特别注意，因为它们的行为可能不如预期。 2.8.C++20引入的变化（如果有） C++20标准可能会对volatile有进一步的说明或改进，但截至知识截止日期，这些变化尚未明确。 总结来说，C和C++中的volatile在基本用途上相似，但C++标准提供了更明确的定义，尤其是在多线程环境中。在C++中，如果需要原子性或线程安全的同步，应该使用std::atomic或其他同步机制，而不是仅仅依赖volatile。\n3.volatile常见面试问题 在面试中，volatile 关键字是一个常见的话题，以下是一些可能会问到的问题以及相关的答案：\nvolatile 关键字是什么？ volatile 是一种类型修饰符，用于告诉编译器该变量可能会在程序的控制之外被改变，例如由中断服务程序、多线程或硬件修改。使用 volatile 可以防止编译器对这些变量进行优化，确保每次访问都直接从内存中读取或写入，从而保证数据的一致性。 volatile 变量的可见性如何保证？ volatile 变量保证了对所有线程的可见性。当一个线程修改了一个 volatile 变量时，其他线程能够立即看到这个修改，这是因为 volatile 变量的写操作会立即刷新到主内存中，而读操作会从主内存中读取最新值。 volatile 能否保证原子性？ volatile 关键字不能保证操作的原子性。它只能确保单次的读/写操作具有原子性，但对于复合操作，如自增（i++），volatile 无法保证整个操作的原子性。因此，对于需要原子性保证的操作，应该使用其他同步机制，如 synchronized 或 AtomicInteger。 volatile 变量在多线程中的使用场景有哪些？ volatile 变量适用于多线程环境下的某些特定场景，例如： 作为状态标志，用于控制线程间的协调，如退出循环的条件。 在没有其他同步机制的情况下，用于保护简单的状态变量，以确保变量的可见性和有序性。 与锁结合使用，实现读写锁模式，提高性能。 volatile 与 const 的区别是什么？ const 关键字用于定义常量，即值不能被修改的变量。而 volatile 用于定义可能会在程序的控制之外被改变的变量。const 保证的是值的不变性，而 volatile 保证的是变量的可见性和禁止指令重排序。 volatile 指针是什么？ volatile 指针是指指向的变量可能会在程序的控制之外被改变的指针。它可以是指向 volatile 变量的指针，也可以是指针本身的值是 volatile 的。在使用 volatile 指针时，编译器不会对通过该指针进行的操作进行优化。 在嵌入式系统中，volatile 的作用是什么？ 在嵌入式系统中，volatile 通常用于声明与硬件寄存器相关的变量，以确保编译器不会对与硬件交互的代码进行优化。这是因为硬件寄存器的值可能会由硬件本身的操作所改变，需要每次访问时都从内存中读取最新值。 volatile 能否替代 synchronized？ volatile 在某些情况下可以作为 synchronized 的轻量级替代，特别是在读操作远多于写操作的场景下。但是，由于 volatile 不能保证复合操作的原子性，它不能完全替代 synchronized。在需要原子性保证的情况下，仍然需要使用 synchronized 或其他同步机制。 理解 volatile 的作用和限制对于编写正确的多线程程序至关重要。在面试中，展示对 volatile 的深入理解可以体现候选人的专业知识和经验。\n4.volatile与const与指针 （1）一个参数既可以是const还可以是volatile吗？为什么？ 可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。 （2）一个指针可以是volatile吗？为什么？ 可以。尽管这并不常见。一个例子是当一个中断服务子程序修改一个指向一个buffer的指针时。 5.应用场景 在嵌入式系统开发中，正确地使用 volatile 关键字对于避免硬件中断对程序执行的影响至关重要。以下是一些关于如何在嵌入式系统中使用 volatile 的关键点：\n防止编译器优化：volatile 告诉编译器，即使在代码中看似没有改变，变量的值也可能在任何时候改变，因此编译器不应进行优化 中断服务程序中的变量：在中断服务程序（ISR）中，经常需要访问或修改一些变量。如果这些变量在主程序中也被访问，那么它们应该被声明为 volatile，以确保每次访问时都能获取最新的值 多线程共享变量：在多线程环境中，如果多个任务共享某些变量，并且这些变量的值可能被任何一个任务改变，那么这些变量也应该被声明为 volatile，以确保所有任务都能看到其他任务对共享变量的最新修改 硬件寄存器访问：在嵌入式编程中，硬件寄存器的值可能会被硬件本身的操作所改变。使用 volatile 修饰硬件寄存器可以确保每次访问都是直接从硬件寄存器中读取，而不是从CPU缓存中 保证内存顺序：volatile 还可以防止编译器和处理器对指令的重排序，确保指令按照代码中的顺序执行，这对于中断和主程序之间的同步尤为重要 使用场景：volatile 适用于并行设备的硬件寄存器、中断服务子程序中访问的非自动变量、多线程应用中被多个任务共享的变量，以及需要防止编译器优化的情况，如for循环延时程序 注意限制：虽然 volatile 可以确保变量的可见性，但它不保证操作的原子性。在多线程环境中，如果需要原子性，还需要使用其他同步机制，如互斥锁 性能影响：使用 volatile 可能会降低程序的性能，因为它阻止了编译器进行某些优化。因此，只有在必要时才应该使用 volatile 总结来说，volatile 在嵌入式系统中是一个关键的关键字，用于确保变量的值能够反映出最新的状态，特别是在中断服务程序和多线程环境中。然而，开发者应当谨慎使用，避免滥用，同时注意它并不能替代其他同步机制来保证操作的原子性。\n6.应用示例 （1）并行设备的硬件寄存器（如状态寄存器）。\n假设要对一个设备进行初始化，此设备的寄存器为0x0x80008004。 1 2 3 4 5 6 7 8 9 unsigned int *output = (unsigned int *)0x0x80008004; //定义一个IO端口； int main(void) { int i; for(i=0;i\u0026lt; 10;i++) { *output = i; } } 如果开启的 -O3 优化，那么经过编译器优化后，编译器认为前面循环，对最后的结果毫无影响。 最终只是将output这个指针赋值为 9，所以汇编后的程序相当于： 1 2 3 4 int init(void) { *output = 9; } 如果你需要程序完全按照你所写程序运行，那就用volatile修饰变量。 通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。 （2）一个中断服务子程序中访问到的变量；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static int i=0; int main() { while(1) { if(i) dosomething(); } } /* Interrupt service routine */ void IRS() { i=1; } 上面示例程序的本意是产生中断时，由中断服务子程序IRS响应中断，变更程序变量i，使在main函数中调用dosomething函数， 但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远不会被调用。 如果将变量i加上volatile修饰，则编译器保证对变量i的读写操作都不会被优化，从而保证了变量i被外部程序更改后能及时在原程序中得到感知。 （3）多线程应用中被多个任务共享的变量。\n当多个线程共享某一个变量时，该变量的值会被某一个线程更改，应该用 volatile 声明。 作用是防止编译器优化把变量从内存装入CPU寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。 volatile的作用是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。示例如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 volatile bool bStop=false; //bStop 为共享全局变量 //第一个线程 void threadFunc1() { ... while(!bStop){...} } //第二个线程终止上面的线程循环 void threadFunc2() { ... bStop = true; } 要想通过第二个线程终止第一个线程循环，如果bStop不使用volatile定义，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE， 加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。 关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-volatile/","title":"C++ basic volatile"},{"content":"C++面试基础系列-函数指针与指针函数 [toc]\nOverview 1.function_pointer函数指针 function_pointer函数指针也是一个指针， 只不过函数指针可以指向函数，可以通过该指针调用函数 联想到重载，多态，模板，只不过函数指针需要重新调整指针指向的函数类型 2.pointer_function指针函数 指针函数实际上只是函数返回值返回一个指针 3.面试中，最喜欢的是函数指针和指针函数的区别 函数指针和指针函数是两个不同的概念，主要区别如下：\n3.1.定义 指针函数： 本质是一个函数，其返回值是一个指针。 例如：int* fun() { /* 函数体 */ }，这里的函数 fun就是一个指针函数，它返回一个指向整数的指针。 函数指针： 是指向函数的指针变量。 例如：int (*pf)();，这里 pf是一个函数指针，它指向一个返回值为整数的函数。 3.2.用法 指针函数的用法：\n先调用指针函数，得到一个指针结果，然后通过这个指针访问其所指向的内存空间中的数据。\n例如：\n看出下面代码的错误了吗？\n1 2 3 4 5 6 7 8 9 int* fun() { int a = 10; return \u0026amp;a; } int main() { int* ptr = fun(); printf(\u0026#34;%d\\n\u0026#34;, *ptr);//error return 0; } ERROR:a是一个局部变量，调用指向a的指针，会出现内存泄漏，应避免这种用法。\n函数指针的用法：\n可以将函数指针作为参数传递给其他函数，实现回调函数的功能。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 void callback(int (*func)(int), int arg) { int result = func(arg); printf(\u0026#34;Result: %d\\n\u0026#34;, result); } int square(int num) { return num * num; } int main() { callback(square, 5); return 0; } 3.3.存储方式 指针函数：在内存中与普通函数一样，有特定的代码段存储函数体，执行时将在该代码段中运行。返回的指针则存储在相应的内存地址中。 函数指针：本身作为一个变量存储在内存中，它的值是所指向函数的入口地址。 4.函数指针用法 函数指针是C++中一种重要的特性，它允许将函数作为值来处理。以下是函数指针的一些常见用法：\n动态函数调用： 使用函数指针可以在运行时决定调用哪个函数。这在实现回调机制、策略模式或事件处理系统时非常有用。\n1 2 3 4 5 6 void function1() { std::cout \u0026lt;\u0026lt; \u0026#34;Function 1\u0026#34; \u0026lt;\u0026lt; std::endl; } void function2() { std::cout \u0026lt;\u0026lt; \u0026#34;Function 2\u0026#34; \u0026lt;\u0026lt; std::endl; } void (*functionPtr)() = function1; // 函数指针指向function1 functionPtr(); // 调用function1 functionPtr = function2; // 现在指向function2 functionPtr(); // 调用function2 实现回调函数： 函数指针经常用于回调函数，即作为参数传递给另一个函数，然后在该函数内部调用。\n1 2 3 4 5 6 7 8 9 void callback(void (*func)()) { func(); } void myFunction() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello from myFunction\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { callback(myFunction); } 作为数据成员： 在类中使用函数指针作为数据成员，允许对象根据行为的不同来调用不同的函数。\n1 2 3 4 5 6 7 class Event { public: void (*handler)(); // 函数指针作为数据成员 }; Event event; event.handler = myFunction; event.handler(); // 调用myFunction 数组和向量： 函数指针可以存储在数组或向量中，用于管理一组函数。\n1 2 3 4 void (*functions[])() = {function1, function2}; for (auto func : functions) { func(); } 函数指针类型转换： 在某些情况下，可能需要将一个函数指针转换为另一个类型的指针，或者反之。\n1 2 typedef void (*FuncType)(); int (*intFunc)(int) = static_cast\u0026lt;int (*)(int)\u0026gt;(function1); // 类型转换 实现多态： 函数指针可以用来实现类似多态的行为，尤其是在使用函数作为类的成员或参数时。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Base { public: virtual void execute() = 0; }; class Derived : public Base { public: void execute() override { std::cout \u0026lt;\u0026lt; \u0026#34;Execute in Derived\u0026#34; \u0026lt;\u0026lt; std::endl; } }; Base* basePtr = new Derived(); (*basePtr).execute(); // 多态调用 delete basePtr; 用于排序和搜索算法： 在标准库算法中，如 std::sort或 std::find_if，可以传递函数指针或函数对象来指定自定义的比较或谓词函数。\n1 2 3 int array[] = {5, 3, 2, 4, 1}; std::sort(std::begin(array), std::end(array), [](int a, int b) { return a \u0026gt; b; }); // lambda表达式作为函数指针使用 信号处理： 在Unix和类Unix系统中，signal函数允许为各种信号注册信号处理函数，这通常通过函数指针完成。\n1 2 3 4 5 void signalHandler(int signal) { std::cout \u0026lt;\u0026lt; \u0026#34;Signal received\u0026#34; \u0026lt;\u0026lt; std::endl; } // 注册信号处理函数 signal(SIGINT, signalHandler); 函数指针的指针： 可以创建函数指针的数组或指针，这在实现函数表或多级回调时很有用。\n1 2 3 void (*functionTable[])() = {function1, function2}; void (**functionTablePtr)() = functionTable; (*functionTablePtr)[0](); // 调用function1 与C ABI兼容： 由于C++兼容C的ABI（应用程序二进制接口），函数指针在C和C++之间可以互用，这在编写跨语言的库或接口时非常有用。\n函数指针是C++中实现多态、回调和高阶函数（即接受或返回函数的函数）的关键工具。然而，过度使用函数指针可能会使代码难以理解和维护，因此应谨慎使用，并考虑使用更现代的C++特性，如函数对象、lambda表达式和std::function。\n5.指针函数 指针函数是一种返回指针类型的函数。以下是指针函数的一些用法：\n5.1.动态内存分配 在 C 和 C++中，可以使用指针函数来动态分配内存并返回指向该内存的指针。例如：\n1 2 3 4 int* allocateArray(int size) { int* arr = new int[size]; return arr; } 在这个例子中，allocateArray函数接受一个整数参数 size，用于指定要分配的数组大小。函数内部使用 new关键字动态分配一个整数数组，并返回指向该数组的指针。使用时可以这样调用：\n1 2 3 4 5 6 int main() { int* myArray = allocateArray(10); // 使用 myArray delete[] myArray; return 0; } 5.2.返回复杂数据结构的指针 当需要从函数中返回一个复杂的数据结构时，可以使用指针函数。例如，假设有一个结构体表示学生信息：\n1 2 3 4 5 6 7 8 9 10 11 struct Student { std::string name; int age; }; Student* createStudent(std::string name, int age) { Student* s = new Student; s-\u0026gt;name = name; s-\u0026gt;age = age; return s; } 使用方式如下：\n1 2 3 4 5 6 int main() { Student* student = createStudent(\u0026#34;Tom\u0026#34;, 18); // 使用 student delete student; return 0; } 5.3.作为函数参数传递 指针函数的返回值可以作为其他函数的参数进行传递。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void processArray(int* arr, int size) { for (int i = 0; i \u0026lt; size; i++) { arr[i] *= 2; } } int* generateArray(int size) { int* arr = new int[size]; for (int i = 0; i \u0026lt; size; i++) { arr[i] = i + 1; } return arr; } 可以这样调用：\n1 2 3 4 5 6 7 int main() { int* myArray = generateArray(5); processArray(myArray, 5); // 使用 myArray delete[] myArray; return 0; } 在这个例子中，generateArray函数生成一个整数数组，然后将其作为参数传递给 processArray函数进行处理。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0/","title":"C++ basic 函数指针与指针函数"},{"content":"C++面试基础系列-指针和引用 [toc]\nOverview 1.指针和引用含义 在C++中，\u0026ldquo;pointer reference\u0026quot;这个术语可能引起一些混淆，因为\u0026quot;reference\u0026rdquo;（引用）和\u0026quot;pointer\u0026quot;（指针）是两种不同的概念，但它们可以一起使用。以下是对这两种概念的解释和它们如何一起使用的示例：\n1.1.指针（Pointer） 指针是一个变量，它存储了另一个变量的内存地址。指针允许你间接访问内存地址上存储的值。\n1 2 int value = 10; int* pointer = \u0026amp;value; // \u0026#39;pointer\u0026#39;是指向\u0026#39;value\u0026#39;的指针 1.2.引用（Reference） 引用是一个别名，为一个已存在的变量提供了另一个名字。一旦引用被初始化，它就不能重新绑定到另一个变量。\n1 2 int value = 10; int\u0026amp; reference = value; // \u0026#39;reference\u0026#39;是\u0026#39;value\u0026#39;的引用 1.3.指针和引用一起使用 你可以有一个指针到引用，这通常在函数参数中看到，以便传递一个对对象的引用而不是对象本身，同时还能保持指针的语义。\n1 2 3 4 5 6 7 void increment(int\u0026amp; ref) { ref += 1; } void process(int* ptr) { increment(*ptr); // 通过指针传递引用 } 在这个例子中，increment 函数接受一个引用作为参数。在 process 函数中，我们有一个指向 value 的指针 ptr。我们通过 *ptr（解引用指针以获取它所指向的值）来调用 increment，这样 increment 就可以修改 value 的原始值。\n1.4.指针引用（Pointer to Reference） 虽然不常见，但你可以有一个指向引用的指针。这通常在复杂的数据结构或模板元编程中看到。\n1 2 3 int value = 10; int\u0026amp; ref = value; int*\u0026amp; refRef = ref; // \u0026#39;refRef\u0026#39;是指向引用的引用，也指向\u0026#39;value\u0026#39; 在这个例子中，refRef 是一个引用到引用的指针。它首先声明为 ref 的引用，然后可以被当作一个指向 value 的指针使用。\n1.5.注意事项 引用必须在声明时被初始化，并且不能是nullptr。 指针可以是nullptr，表示它不指向任何地址。 引用的引用（或指向引用的指针）在大多数情况下是不推荐的，因为它可能导致代码难以理解和维护。 在实际编程中，通常建议使用常规的引用或指针，因为它们已经能够满足大多数需求，而且更易于理解和使用。\n2.指针和引用的区别 指针（Pointer）和引用（Reference）在C++中是两种不同的概念，它们在使用和行为上有着明显的区别：\n定义方式：\n指针是一个变量，它存储了另一个变量的内存地址。\n1 2 int a = 10; int* p = \u0026amp;a; // p是指向a的指针 引用是某个已存在变量的别名。\n1 2 int a = 10; int\u0026amp; r = a; // r是a的引用 初始化：\n指针可以在任何时候被初始化或重新指向另一个地址。 引用必须在声明时立即初始化，且一旦初始化后，就不能再指向另一个变量。 可修改性：\n指针可以在任何时间指向nullptr或被重新赋值为其他地址。 引用不能是nullptr，且一旦引用绑定到一个对象，就不能被修改为引用其他对象。 语法使用：\n通过指针访问其指向的值需要使用解引用操作符*。 引用使用起来就像使用原始变量一样，没有特别的语法需求。 内存分配：\n指针可能涉及到动态内存分配（使用new和delete）。 引用不涉及动态内存分配，它们只是现有变量的别名。 类型转换：\n指针可以进行类型转换，如从void*转换为具体类型指针。 引用通常不进行类型转换，它们在声明时类型就固定了。 数组和函数参数：\n指针可以用于数组和作为函数参数，以实现更复杂的数据操作。 引用通常用于函数参数，以提供对实际参数的直接修改能力，避免复制开销。 内存占用：\n指针变量本身占用内存，它们存储的是另一个变量的地址。 引用不占用额外内存，它们不存储地址，只是现有变量的一个别名。 安全性：\n指针可能更容易出错，如野指针、内存泄漏等。 引用由于其绑定的特性，使用起来更安全，不容易出现错误。 与const结合使用：\n可以有指向const的指针（指向常量的指针），这意味着不能通过这个指针修改其指向的值。 引用可以是const的，表示不能通过引用修改原始变量的值。 在实际编程中，选择使用指针还是引用通常取决于具体的应用场景和需求。引用通常用于简化代码和提高可读性，而指针则提供了更多的灵活性和控制能力。\n3.指针和引用使用方法 以下是一个简单的C++代码示例，展示了指针和引用的使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; void usePointer(int* ptr) { if (ptr != nullptr) { std::cout \u0026lt;\u0026lt; \u0026#34;Using pointer: \u0026#34; \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; std::endl; *ptr = 20; // 修改指针指向的值 } } void useReference(int\u0026amp; ref) { std::cout \u0026lt;\u0026lt; \u0026#34;Using reference: \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; std::endl; ref = 30; // 修改引用绑定的值 } int main() { int value = 10; // 使用指针 std::cout \u0026lt;\u0026lt; \u0026#34;Original value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; usePointer(\u0026amp;value); std::cout \u0026lt;\u0026lt; \u0026#34;Value after pointer function: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; std::endl; // 使用引用 std::cout \u0026lt;\u0026lt; \u0026#34;Original value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; useReference(value); std::cout \u0026lt;\u0026lt; \u0026#34;Value after reference function: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中：\nusePointer 函数接受一个int*类型的参数，即指向int的指针。在函数内部，我们首先检查指针是否不为nullptr，然后通过解引用操作符*来访问和修改指针指向的值。\nuseReference 函数接受一个int\u0026amp;类型的参数，即int的引用。在函数内部，我们直接使用引用来访问和修改它绑定的原始变量的值。\n在main函数中，我们声明了一个int类型的变量value并初始化为10。然后分别使用指针和引用的方式调用函数，并观察变量值的变化。\n这个示例展示了指针和引用在函数参数传递中的使用，以及它们如何影响原始变量的值。请注意，引用在函数内部被当作原始变量的别名来使用，而指针则需要通过解引用来访问其指向的值。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/","title":"C++ basic 指针和引用"},{"content":"C++面试基础系列-C++虚函数virtual [TOC]\nOverview 1.virtual 在 C++ 中，virtual 关键字用于实现多态性，它允许你定义虚函数。虚函数是一种成员函数，它可以在派生类中被重写（override），并且调用哪个函数版本是由对象的实际类型决定的，而不是由指针或引用的静态类型决定的。\n以下是 virtual 关键字的一些关键点和示例：\n1.1.虚函数 使用 virtual 关键字定义的函数可以在派生类中被重写。 调用虚函数时，将根据对象的实际类型调用相应的函数实现。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Base { public: virtual void show() { std::cout \u0026lt;\u0026lt; \u0026#34;Base show\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Base() {} // 虚析构函数确保派生类的析构函数被调用 }; class Derived : public Base { public: void show() override { // 使用 override 关键字明确重写意图 std::cout \u0026lt;\u0026lt; \u0026#34;Derived show\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 1.2.抽象类 如果类包含至少一个纯虚函数，它就成为了一个抽象类（abstract class），不能被实例化。 1 2 3 4 5 class AbstractBase { public: virtual void pureVirtualFunction() = 0; // 纯虚函数 // 其他成员函数... }; 1.3.虚析构函数 定义虚析构函数以确保在删除通过基类指针删除派生类对象时，正确的析构函数被调用。 1.4.虚继承 使用 virtual 关键字进行虚继承可以解决菱形继承问题，避免重复继承同一基类。 1 2 3 class Base1 {}; class Base2 {}; class Derived : virtual public Base1, virtual public Base2 {}; 1.5.多态的使用 通过基类指针或引用调用虚函数，可以实现多态行为。 1 2 3 Base* basePtr = new Derived(); basePtr-\u0026gt;show(); // 调用 Derived 类的 show 函数 delete basePtr; 1.6.final 关键字 使用 final 关键字可以阻止进一步的重写。 1 2 3 4 5 6 class FinalClass : public Base { public: void show() final { std::cout \u0026lt;\u0026lt; \u0026#34;FinalClass show\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 在这个例子中，FinalClass 中的 show 函数不能在任何派生类中被重写。\n1.7.注意事项 虚函数提供了运行时多态性，这是 C++ 的核心特性之一。 虚函数通常用于接口类或基类，以提供可扩展的行为。 确保正确使用虚析构函数，以避免资源泄漏。 虚函数和纯虚函数是实现多态和抽象类的基础。 virtual 关键字是 C++ 实现面向对象编程的重要工具，它允许更灵活和动态的代码设计。\n2.如何使用 C++ 的虚函数实现多态性？ 在 C++ 中，多态性是指允许不同类的对象对同一消息做出响应的能力，但响应的方式取决于发送消息的对象的实际类型。多态性主要通过虚函数实现。以下是使用虚函数实现多态性的步骤和示例：\n2.1. 定义基类和虚函数 首先，你需要定义一个基类，并在其中声明至少一个虚函数。虚函数使用 virtual 关键字声明。\n1 2 3 4 5 class Shape { public: virtual void draw() const = 0; // 纯虚函数，强制实现多态性 virtual ~Shape() {} // 虚析构函数，确保派生类的析构函数被调用 }; 2.2. 在派生类中重写虚函数 然后，在每个派生类中重写基类的虚函数。这允许每个类以自己的方式响应函数调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Circle : public Shape { public: void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a circle.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Square : public Shape { public: void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a square.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 2.3. 使用基类指针或引用 创建派生类对象的基类指针或引用，通过这些指针或引用调用虚函数。\n1 Shape* shapes[] = {new Circle(), new Square()}; 2.4. 调用虚函数 通过基类指针或引用调用虚函数，实际调用的是对象实际类型的函数实现。\n1 2 3 for (const Shape* shape : shapes) { shape-\u0026gt;draw(); // 根据对象的实际类型调用相应的 draw 函数 } 2.5. 释放资源 如果使用动态分配（new），不要忘记释放内存。如果基类有一个虚析构函数，那么通过基类指针删除派生类对象时，将正确地调用派生类的析构函数。\n1 2 3 for (auto* shape : shapes) { delete shape; } 2.6. 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // 基类 class Shape { public: virtual void draw() const = 0; // 纯虚函数 virtual ~Shape() {} // 虚析构函数 }; // 派生类 class Circle : public Shape { public: void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a circle.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Square : public Shape { public: void draw() const override { std::cout \u0026lt;\u0026lt; \u0026#34;Drawing a square.\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { std::vector\u0026lt;Shape*\u0026gt; shapes; shapes.push_back(new Circle()); shapes.push_back(new Square()); for (Shape* shape : shapes) { shape-\u0026gt;draw(); // 多态性：调用对象实际类型的 draw 函数 } // 清理资源 for (Shape* shape : shapes) { delete shape; } return 0; } 在这个示例中，Shape 类是一个抽象基类，它声明了一个纯虚函数 draw。Circle 和 Square 类是 Shape 的具体实现，它们重写了 draw 函数。通过基类指针数组 shapes 存储派生类对象的指针，然后在循环中调用 draw 函数，展示了多态性的行为。每个对象调用其实际类型的 draw 函数，而不是指针静态类型的函数。\n3.在C++中，虚函数和纯虚函数有什么区别？ 在 C++ 中，虚函数和纯虚函数都是用来实现多态性的，但它们之间存在一些关键区别：\n定义方式：\n虚函数：使用 virtual 关键字声明，可以有实现，也可以没有（即只有声明）。 纯虚函数：使用 virtual 关键字声明，并在函数声明末尾加上 = 0，必须没有实现。 实现：\n虚函数：可以在基类中提供默认实现，派生类可以选择重写它。 纯虚函数：没有实现，派生类必须提供实现，否则派生类也会变成抽象类。 抽象类：\n虚函数：基类中可以包含虚函数，但即使包含虚函数的类也不一定是抽象类。 纯虚函数：如果一个类包含至少一个纯虚函数，这个类就是抽象类，不能被实例化。 多态性：\n虚函数：允许在派生类中重写基类的行为，实现多态性。 纯虚函数：强制派生类提供具体实现，以确保每个派生类都有其特定的行为。 使用目的：\n虚函数：用于定义接口，同时提供默认行为，允许派生类根据需要重写。 纯虚函数：用于定义接口规范，确保派生类遵循接口，强制实现特定的行为。 析构函数：\n虚函数：虚析构函数用于确保通过基类指针删除派生类对象时，调用正确的析构函数。 纯虚函数：通常不用于析构函数，但技术上可以声明析构函数为纯虚函数（不推荐）。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Base { public: virtual void doSomething() { std::cout \u0026lt;\u0026lt; \u0026#34;Base implementation\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Base() {} // 虚析构函数 }; class Derived : public Base { public: void doSomething() override { std::cout \u0026lt;\u0026lt; \u0026#34;Derived implementation\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class AbstractBase { public: virtual void pureVirtualFunction() = 0; // 纯虚函数 }; // AbstractBase obj; // 错误：不能实例化抽象类 在这个示例中，Base 类中的 doSomething 是一个虚函数，可以在 Derived 类中被重写。Base 类的析构函数是一个虚析构函数。AbstractBase 类包含一个纯虚函数 pureVirtualFunction，使其成为一个抽象类，不能被直接实例化。\n理解虚函数和纯虚函数的区别对于设计灵活且可扩展的 C++ 程序非常重要。\n4.能否给我一个使用虚继承解决菱形继承问题的C++代码示例？ 当使用传统的多重继承时，可能会出现菱形继承问题，也称为钻石继承。在这种情况下，一个类（C）同时从两个类（A1 和 A2）继承，而这两个类又从同一个基类（B）继承。这会导致基类 B 的成员在类 C 中出现两次，从而产生歧义。\n虚继承可以用来解决这个问题，它确保了基类 B 的成员在派生类 C 中只有一个副本。以下是使用虚继承解决菱形继承问题的 C++ 代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; // 基类 B class B { public: B() { std::cout \u0026lt;\u0026lt; \u0026#34;B\u0026#39;s constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~B() { std::cout \u0026lt;\u0026lt; \u0026#34;B\u0026#39;s destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } void functionB() { std::cout \u0026lt;\u0026lt; \u0026#34;Function in B\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 中间类 A1 和 A2，都虚继承自 B class A1 : virtual public B { public: A1() { std::cout \u0026lt;\u0026lt; \u0026#34;A1\u0026#39;s constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } ~A1() { std::cout \u0026lt;\u0026lt; \u0026#34;A1\u0026#39;s destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } void functionA1() { std::cout \u0026lt;\u0026lt; \u0026#34;Function in A1\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class A2 : virtual public B { public: A2() { std::cout \u0026lt;\u0026lt; \u0026#34;A2\u0026#39;s constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } ~A2() { std::cout \u0026lt;\u0026lt; \u0026#34;A2\u0026#39;s destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } void functionA2() { std::cout \u0026lt;\u0026lt; \u0026#34;Function in A2\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // 派生类 C，继承自 A1 和 A2，它们都虚继承自 B class C : public A1, public A2 { public: C() { std::cout \u0026lt;\u0026lt; \u0026#34;C\u0026#39;s constructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } ~C() { std::cout \u0026lt;\u0026lt; \u0026#34;C\u0026#39;s destructor called.\u0026#34; \u0026lt;\u0026lt; std::endl; } void functionC() { std::cout \u0026lt;\u0026lt; \u0026#34;Function in C\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { C c; // 创建 C 的对象，只会调用一次 B 的构造函数和析构函数 c.functionB(); // 调用 B 中的函数 c.functionA1(); // 调用 A1 中的函数 c.functionA2(); // 调用 A2 中的函数; c.functionC(); // 调用 C 中的函数 return 0; } 在这个示例中：\n类 B 是一个基类，包含一个成员函数 functionB。 类 A1 和 A2 都通过虚继承从 B 继承，这意味着 B 的成员在 A1 和 A2 中只会有一个副本。 类 C 同时继承自 A1 和 A2。由于 A1 和 A2 是通过虚继承从 B 继承的，C 中不会出现 B 的重复成员。 在 main 函数中，创建 C 的对象时，B 的构造函数和析构函数只会被调用一次，这展示了虚继承解决了菱形继承问题。 使用虚继承可以避免对象中出现基类成员的多个副本，是处理复杂多重继承关系的有效方法。\n5.如果我想在派生类中调用基类的虚函数，但是不想让基类成为抽象类，我该怎么做？ 如果你想在派生类中调用基类的虚函数，但又不想让基类成为抽象类，你可以简单地在基类中提供一个虚函数的定义，而不是声明它为纯虚函数。这样，基类就不是抽象类，可以被实例化，同时派生类也可以重写这个虚函数。\n以下是如何做到这一点的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; // 基类 class Base { public: // 虚函数，不是纯虚函数 virtual void display() { std::cout \u0026lt;\u0026lt; \u0026#34;Display in Base\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Base() {} // 提供虚析构函数 }; // 派生类 class Derived : public Base { public: // 重写基类的虚函数 void display() override { std::cout \u0026lt;\u0026lt; \u0026#34;Display in Derived\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Base* basePtr = new Derived(); // 基类指针指向派生类对象 basePtr-\u0026gt;display(); // 调用派生类的 display 函数，展示多态性 // 在派生类中调用基类的虚函数 Base\u0026amp; baseRef = *basePtr; baseRef.display(); // 调用基类的 display 函数 delete basePtr; return 0; } 在这个示例中：\nBase 类包含一个虚函数 display()，它有一个具体的实现。这使得 Base 类可以被实例化，并且 display() 函数可以在对象上直接调用。 Derived 类继承自 Base 并重写了 display() 函数，提供了自己的实现。 在 main() 函数中，我们创建了一个 Derived 类型的指针 basePtr，它指向 Derived 的实例，并通过基类指针调用 display() 函数来展示多态性。 然后，我们演示了如何在派生类的对象中通过基类引用调用基类的 display() 函数。 通过这种方式，你可以保留基类的对象实例化能力，同时在派生类中重写虚函数以展示不同的行为。如果派生类没有重写基类的虚函数，那么通过派生类对象调用该函数将执行基类中的版本。\n6.常见面试问题 C++ 中的虚函数（virtual）是实现多态性的关键机制之一。虽然虚函数非常有用，但在使用过程中可能会遇到一些问题。以下是一些常见的问题以及它们的解决方案：\n6.1. 忘记虚析构函数 问题：如果基类没有虚析构函数，通过基类指针删除派生类对象时，只调用派生类的析构函数，不会调用基类的析构函数，导致资源泄漏。 解决方案：在基类中声明一个虚析构函数。\n1 2 3 4 5 6 class Base { public: virtual ~Base() { // 清理资源 } }; 6.2. 覆盖虚函数但未使用 override 问题：在派生类中覆盖虚函数时，如果忘记了 override 关键字，而函数签名与基类中的不完全匹配，编译器可能不会报错，导致潜在的bug。 解决方案：使用 override 关键字明确你的目的。\n1 2 3 class Derived : public Base { void foo() override; // 如果签名不匹配，编译器会报错 }; 6.3. 忘记虚函数的实现 问题：声明了虚函数但没有在基类或派生类中提供实现，导致链接错误。 解决方案：确保虚函数在基类或派生类中有定义。\n1 2 3 4 5 6 7 8 class Base { public: virtual void bar(); }; void Base::bar() { // 实现 } 6.4. 非虚函数与虚函数的混淆 问题：在派生类中声明了一个与基类中虚函数同名但签名不同的函数，导致调用时出现混淆。 解决方案：确保派生类中的函数覆盖是有意为之，并且签名完全匹配。\n1 2 3 4 5 6 7 8 9 class Base { public: virtual void baz(int x); }; class Derived : public Base { public: void baz(int x) override; // 正确覆盖 }; 6.5. 私有虚函数 问题：在基类中将虚函数声明为私有，派生类无法访问或覆盖它。 解决方案：确保虚函数在基类中是公共（public）或受保护（protected）的。\n1 2 3 4 class Base { public: virtual void foo(); // 公共访问权限 }; 6.6. 多重继承中的虚函数冲突 问题：在多重继承中，两个基类有相同名称的虚函数，派生类需要明确覆盖哪个基类的函数。 解决方案：使用作用域运算符（::）来指定要覆盖的基类中的虚函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Base1 { public: virtual void func(); }; class Base2 { public: virtual void func(); }; class Derived : public Base1, public Base2 { public: void Base1::func() override; // 覆盖 Base1 中的 func void Base2::func() override; // 覆盖 Base2 中的 func }; 6.7. 虚函数与模板 问题：在模板类中使用虚函数可能导致编译器错误或警告。 解决方案：确保模板类中的虚函数声明正确，并且在模板实例化时遵循虚函数的规则。\n1 2 3 4 5 template \u0026lt;typename T\u0026gt; class TemplateBase { public: virtual void templateFunc(T value) = 0; // 纯虚函数 }; 6.8. 虚函数与友元 问题：虚函数不能声明为友元函数，因为它们需要通过虚表（vtable）进行调用，而友元函数不具备这种机制。 解决方案：避免将友元函数声明为虚函数。\n理解并解决这些问题有助于你更有效地使用虚函数，并避免在 C++ 程序中引入难以发现的错误。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-%E8%99%9A%E5%87%BD%E6%95%B0virtual/","title":"C++ basic 虚函数virtual"},{"content":"C++面试基础系列-C++虚函数vptr_vtable [TOC]\nOverview 1.简单介绍 在 C++ 中，虚函数的实现细节涉及到虚表指针（vptr）和虚表（vtable）。这些是编译器用来实现运行时多态性的机制。以下是关于 vptr 和 vtable 的一些关键点：\n1.1.vptr（虚表指针） vptr 是一个指针，存储在对象的内存布局中，指向该对象的虚表。 每个包含虚函数的类都有自己的虚表。 vptr 的位置和大小可能因编译器而异，但通常位于对象的内存布局的开始处。 vptr 的存在是透明的，程序员不需要（也不应该）直接操作它。 1.2.vtable（虚表） vtable 是一个表格，包含了类中所有虚函数的地址。 每个类都有自己的 vtable，它包含了该类所有虚函数的指针。 当你调用一个虚函数时，程序会查找对象的 vptr 指向的 vtable，然后在表中查找正确的函数地址来执行。 1.3.工作原理 构造对象：当创建一个对象时，编译器会在对象的内存中安排 vptr 和类的成员变量。 调用虚函数：当通过对象调用虚函数时，程序会先访问对象的 vptr，然后查找 vtable 中对应的函数地址。 多态性：如果对象是派生类实例，但通过基类指针或引用调用，vtable 会确保调用正确的函数实现，即使基类指针或引用的静态类型不知道实际对象的动态类型。 1.4.示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Base { public: virtual void func() { std::cout \u0026lt;\u0026lt; \u0026#34;Base::func\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Base() {} }; class Derived : public Base { public: void func() override { std::cout \u0026lt;\u0026lt; \u0026#34;Derived::func\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Base* basePtr = new Derived(); basePtr-\u0026gt;func(); // 调用 Derived::func，展示了多态性 delete basePtr; return 0; } 在这个示例中，Base 类和 Derived 类都有自己的 vtable。Derived 类的 vtable 覆盖了 Base 类的 vtable 中的 func 条目。当通过 Base 类型的指针调用 func 时，实际调用的是 Derived 类的 func 函数。\n1.5.注意事项 不要直接操作 vptr 或 vtable，它们是编译器实现细节。 虚函数的使用可能会影响程序的性能，因为它们引入了间接调用。 当类中有虚函数时，复制或移动操作可能需要特别处理，以确保 vptr 正确设置。 vptr 和 vtable 是 C++ 实现多态性的核心机制，它们使得程序能够在运行时确定调用哪个函数实现。\n在 C++ 中，vptr（虚表指针）和 vtable（虚表）是实现多态性机制的底层技术。下面将更详细地介绍它们的工作原理和相关概念：\n2.强化认识 2.1.vtable（虚表） 结构：vtable 是一个或多个函数指针的数组。每个包含虚函数的类都有自己的 vtable。\n布局：vtable 通常按照类中虚函数的声明顺序排列，每个条目对应一个虚函数的地址。\n继承：当一个类继承自另一个类时，它的 vtable 会包含基类 vtable 的引用以及它自己新增的虚函数的地址。\n动态绑定：vtable 用于在运行时确定应该调用哪个函数。当调用一个虚函数时，程序会查找对象的 vptr 指向的 vtable，然后根据虚函数的声明顺序找到对应的函数地址。\n例子：\n1 2 3 4 5 class Base { public: virtual void func1() { std::cout \u0026lt;\u0026lt; \u0026#34;Base func1\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual void func2() { std::cout \u0026lt;\u0026lt; \u0026#34;Base func2\u0026#34; \u0026lt;\u0026lt; std::endl; } }; 在这个例子中，Base 类的 vtable 可能包含两个条目，每个条目指向 func1 和 func2 的实现。\n2.2.vptr（虚表指针） 存储：vptr 是一个指针，通常存储在对象的内存布局的最前面。\n作用：vptr 指向对象的 vtable，它用于访问类的虚函数。\n隐藏性：vptr 对程序员是透明的，由编译器自动管理。\n继承：在多重继承情况下，对象可能包含多个 vptr，每个 vptr 对应一个基类的 vtable。\n例子：\n1 Base obj; 在这个例子中，obj 的内存布局中会包含一个指向 Base 类 vtable 的 vptr。\n2.3.多态性实现 基类指针：当使用基类指针指向派生类对象时，通过基类指针调用虚函数，实际调用的是派生类版本的函数。\n构造和析构：在构造派生类对象时，会先构造基类部分，设置 vptr 指向正确的 vtable，然后再构造派生类新增的部分。在析构时，顺序相反。\n例子：\n1 2 3 Base* basePtr = new Derived(); basePtr-\u0026gt;func1(); // 调用 Derived::func1 delete basePtr; 在这个例子中，通过 Base 类型的指针 basePtr 调用 func1，实际执行的是 Derived 类重写的 func1 函数。\n2.4.性能考虑 间接调用：由于虚函数的调用需要通过 vptr 和 vtable，可能会引入一些性能开销。\n优化：现代编译器和优化器会使用诸如内联函数、虚函数表优化等技术来减少这些开销。\n2.5.内存布局 对象内存：对象的内存布局首先包含 vptr，然后是类的成员变量。\n多重继承：在多重继承情况下，对象的内存布局可能包含多个 vptr，每个对应一个基类的 vtable。\n2.6.注意事项 虚函数不能是静态的（static）或常量（const）成员函数。 虚函数的声明必须使用 virtual 关键字，而重写虚函数时可以使用 override 关键字来提高代码可读性。 理解 vptr 和 vtable 有助于深入学习 C++ 的内存管理和多态性机制。 通过深入理解 vptr 和 vtable，你可以更好地掌握 C++ 的多态性机制，编写出更高效、更安全的面向对象代码。\n关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-basic-%E8%99%9A%E5%87%BD%E6%95%B0vptr_vtable/","title":"C++ basic 虚函数vptr_vtable"},{"content":"Overview C++ C++ Basic 基础知识 C++ Basic 基础知识 abstract assert bit_field bit_operation C++Features const decltype double_colon enum explicit extern friend function_pointerANDpointer_function inline macro_definition pointerANDreferance polymorphic sizeof static struct this union using virtual volatile vptr_vtable C++ Practical-1 练习1 C++ Practical-1 day1-基本语法 day2-递归、结构体、枚举、静态变量等 day3-函数1 day4-函数2 day5-继承多态 day6-虚函数与抽象类 day7-运算符重载 day8-模版与STL day9-异常 day10-文件与流 C++ Practical-2 练习2 C++ Practical-2 1-运算符重载之中括号 2-运算符重载之时钟类++运算符 3-运算符重载之强制转换 4-运算符重载之输入输出运算符重载 5-模板之函数模板 6-类模板之栈 7-类模板特化之数组 8-动态数组 9-字典插入与查找 10-异常捕获 11-继承与封装 12-读写文件综合题 13-输出格式 关于作者 微信公众号:WeSiGJ GitHub:https://github.com/wesigj/cplusplusboys CSDN:https://blog.csdn.net/wesigj 微博: 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 ","date":"2024-09-07T15:07:39+08:00","permalink":"https://wesigj.github.io/p/c-series/","title":"C++ series"}]